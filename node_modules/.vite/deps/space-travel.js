// node_modules/space-travel/dist/space-travel.es.js
function e() {
}
Object.assign(e.prototype, { addEventListener: function(e2, t2) {
  void 0 === this._listeners && (this._listeners = {});
  const n2 = this._listeners;
  void 0 === n2[e2] && (n2[e2] = []), -1 === n2[e2].indexOf(t2) && n2[e2].push(t2);
}, hasEventListener: function(e2, t2) {
  if (void 0 === this._listeners) return false;
  const n2 = this._listeners;
  return void 0 !== n2[e2] && -1 !== n2[e2].indexOf(t2);
}, removeEventListener: function(e2, t2) {
  if (void 0 === this._listeners) return;
  const n2 = this._listeners[e2];
  if (void 0 !== n2) {
    const e3 = n2.indexOf(t2);
    -1 !== e3 && n2.splice(e3, 1);
  }
}, dispatchEvent: function(e2) {
  if (void 0 === this._listeners) return;
  const t2 = this._listeners[e2.type];
  if (void 0 !== t2) {
    e2.target = this;
    const n2 = t2.slice(0);
    for (let t3 = 0, i2 = n2.length; t3 < i2; t3++) n2[t3].call(this, e2);
    e2.target = null;
  }
} });
var t = [];
for (let xo = 0; xo < 256; xo++) t[xo] = (xo < 16 ? "0" : "") + xo.toString(16);
var n = 1234567;
var i = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function() {
  const e2 = 4294967295 * Math.random() | 0, n2 = 4294967295 * Math.random() | 0, i2 = 4294967295 * Math.random() | 0, r2 = 4294967295 * Math.random() | 0;
  return (t[255 & e2] + t[e2 >> 8 & 255] + t[e2 >> 16 & 255] + t[e2 >> 24 & 255] + "-" + t[255 & n2] + t[n2 >> 8 & 255] + "-" + t[n2 >> 16 & 15 | 64] + t[n2 >> 24 & 255] + "-" + t[63 & i2 | 128] + t[i2 >> 8 & 255] + "-" + t[i2 >> 16 & 255] + t[i2 >> 24 & 255] + t[255 & r2] + t[r2 >> 8 & 255] + t[r2 >> 16 & 255] + t[r2 >> 24 & 255]).toUpperCase();
}, clamp: function(e2, t2, n2) {
  return Math.max(t2, Math.min(n2, e2));
}, euclideanModulo: function(e2, t2) {
  return (e2 % t2 + t2) % t2;
}, mapLinear: function(e2, t2, n2, i2, r2) {
  return i2 + (e2 - t2) * (r2 - i2) / (n2 - t2);
}, inverseLerp: function(e2, t2, n2) {
  return e2 !== t2 ? (n2 - e2) / (t2 - e2) : 0;
}, lerp: function(e2, t2, n2) {
  return (1 - n2) * e2 + n2 * t2;
}, damp: function(e2, t2, n2, r2) {
  return i.lerp(e2, t2, 1 - Math.exp(-n2 * r2));
}, pingpong: function(e2, t2 = 1) {
  return t2 - Math.abs(i.euclideanModulo(e2, 2 * t2) - t2);
}, smoothstep: function(e2, t2, n2) {
  return e2 <= t2 ? 0 : e2 >= n2 ? 1 : (e2 = (e2 - t2) / (n2 - t2)) * e2 * (3 - 2 * e2);
}, smootherstep: function(e2, t2, n2) {
  return e2 <= t2 ? 0 : e2 >= n2 ? 1 : (e2 = (e2 - t2) / (n2 - t2)) * e2 * e2 * (e2 * (6 * e2 - 15) + 10);
}, randInt: function(e2, t2) {
  return e2 + Math.floor(Math.random() * (t2 - e2 + 1));
}, randFloat: function(e2, t2) {
  return e2 + Math.random() * (t2 - e2);
}, randFloatSpread: function(e2) {
  return e2 * (0.5 - Math.random());
}, seededRandom: function(e2) {
  return void 0 !== e2 && (n = e2 % 2147483647), n = 16807 * n % 2147483647, (n - 1) / 2147483646;
}, degToRad: function(e2) {
  return e2 * i.DEG2RAD;
}, radToDeg: function(e2) {
  return e2 * i.RAD2DEG;
}, isPowerOfTwo: function(e2) {
  return 0 == (e2 & e2 - 1) && 0 !== e2;
}, ceilPowerOfTwo: function(e2) {
  return Math.pow(2, Math.ceil(Math.log(e2) / Math.LN2));
}, floorPowerOfTwo: function(e2) {
  return Math.pow(2, Math.floor(Math.log(e2) / Math.LN2));
}, setQuaternionFromProperEuler: function(e2, t2, n2, i2, r2) {
  const a2 = Math.cos, o2 = Math.sin, s2 = a2(n2 / 2), l2 = o2(n2 / 2), c2 = a2((t2 + i2) / 2), h2 = o2((t2 + i2) / 2), u2 = a2((t2 - i2) / 2), d2 = o2((t2 - i2) / 2), p2 = a2((i2 - t2) / 2), f2 = o2((i2 - t2) / 2);
  switch (r2) {
    case "XYX":
      e2.set(s2 * h2, l2 * u2, l2 * d2, s2 * c2);
      break;
    case "YZY":
      e2.set(l2 * d2, s2 * h2, l2 * u2, s2 * c2);
      break;
    case "ZXZ":
      e2.set(l2 * u2, l2 * d2, s2 * h2, s2 * c2);
      break;
    case "XZX":
      e2.set(s2 * h2, l2 * f2, l2 * p2, s2 * c2);
      break;
    case "YXY":
      e2.set(l2 * p2, s2 * h2, l2 * f2, s2 * c2);
      break;
    case "ZYZ":
      e2.set(l2 * f2, l2 * p2, s2 * h2, s2 * c2);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r2);
  }
} };
var r = class {
  constructor(e2 = 0, t2 = 0) {
    this.x = e2, this.y = t2;
  }
  get width() {
    return this.x;
  }
  set width(e2) {
    this.x = e2;
  }
  get height() {
    return this.y;
  }
  set height(e2) {
    this.y = e2;
  }
  set(e2, t2) {
    return this.x = e2, this.y = t2, this;
  }
  setScalar(e2) {
    return this.x = e2, this.y = e2, this;
  }
  setX(e2) {
    return this.x = e2, this;
  }
  setY(e2) {
    return this.y = e2, this;
  }
  setComponent(e2, t2) {
    switch (e2) {
      case 0:
        this.x = t2;
        break;
      case 1:
        this.y = t2;
        break;
      default:
        throw new Error("index is out of range: " + e2);
    }
    return this;
  }
  getComponent(e2) {
    switch (e2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e2) {
    return this.x = e2.x, this.y = e2.y, this;
  }
  add(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this);
  }
  addScalar(e2) {
    return this.x += e2, this.y += e2, this;
  }
  addVectors(e2, t2) {
    return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this;
  }
  addScaledVector(e2, t2) {
    return this.x += e2.x * t2, this.y += e2.y * t2, this;
  }
  sub(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this);
  }
  subScalar(e2) {
    return this.x -= e2, this.y -= e2, this;
  }
  subVectors(e2, t2) {
    return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this;
  }
  multiply(e2) {
    return this.x *= e2.x, this.y *= e2.y, this;
  }
  multiplyScalar(e2) {
    return this.x *= e2, this.y *= e2, this;
  }
  divide(e2) {
    return this.x /= e2.x, this.y /= e2.y, this;
  }
  divideScalar(e2) {
    return this.multiplyScalar(1 / e2);
  }
  applyMatrix3(e2) {
    const t2 = this.x, n2 = this.y, i2 = e2.elements;
    return this.x = i2[0] * t2 + i2[3] * n2 + i2[6], this.y = i2[1] * t2 + i2[4] * n2 + i2[7], this;
  }
  min(e2) {
    return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this;
  }
  max(e2) {
    return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this;
  }
  clamp(e2, t2) {
    return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this;
  }
  clampScalar(e2, t2) {
    return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this;
  }
  clampLength(e2, t2) {
    const n2 = this.length();
    return this.divideScalar(n2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, n2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e2) {
    return this.x * e2.x + this.y * e2.y;
  }
  cross(e2) {
    return this.x * e2.y - this.y * e2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e2) {
    return Math.sqrt(this.distanceToSquared(e2));
  }
  distanceToSquared(e2) {
    const t2 = this.x - e2.x, n2 = this.y - e2.y;
    return t2 * t2 + n2 * n2;
  }
  manhattanDistanceTo(e2) {
    return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y);
  }
  setLength(e2) {
    return this.normalize().multiplyScalar(e2);
  }
  lerp(e2, t2) {
    return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this;
  }
  lerpVectors(e2, t2, n2) {
    return this.x = e2.x + (t2.x - e2.x) * n2, this.y = e2.y + (t2.y - e2.y) * n2, this;
  }
  equals(e2) {
    return e2.x === this.x && e2.y === this.y;
  }
  fromArray(e2, t2 = 0) {
    return this.x = e2[t2], this.y = e2[t2 + 1], this;
  }
  toArray(e2 = [], t2 = 0) {
    return e2[t2] = this.x, e2[t2 + 1] = this.y, e2;
  }
  fromBufferAttribute(e2, t2, n2) {
    return void 0 !== n2 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this;
  }
  rotateAround(e2, t2) {
    const n2 = Math.cos(t2), i2 = Math.sin(t2), r2 = this.x - e2.x, a2 = this.y - e2.y;
    return this.x = r2 * n2 - a2 * i2 + e2.x, this.y = r2 * i2 + a2 * n2 + e2.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
};
r.prototype.isVector2 = true;
var a = class {
  constructor() {
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e2, t2, n2, i2, r2, a2, o2, s2, l2) {
    const c2 = this.elements;
    return c2[0] = e2, c2[1] = i2, c2[2] = o2, c2[3] = t2, c2[4] = r2, c2[5] = s2, c2[6] = n2, c2[7] = a2, c2[8] = l2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e2) {
    const t2 = this.elements, n2 = e2.elements;
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], this;
  }
  extractBasis(e2, t2, n2) {
    return e2.setFromMatrix3Column(this, 0), t2.setFromMatrix3Column(this, 1), n2.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e2) {
    const t2 = e2.elements;
    return this.set(t2[0], t2[4], t2[8], t2[1], t2[5], t2[9], t2[2], t2[6], t2[10]), this;
  }
  multiply(e2) {
    return this.multiplyMatrices(this, e2);
  }
  premultiply(e2) {
    return this.multiplyMatrices(e2, this);
  }
  multiplyMatrices(e2, t2) {
    const n2 = e2.elements, i2 = t2.elements, r2 = this.elements, a2 = n2[0], o2 = n2[3], s2 = n2[6], l2 = n2[1], c2 = n2[4], h2 = n2[7], u2 = n2[2], d2 = n2[5], p2 = n2[8], f2 = i2[0], m2 = i2[3], g2 = i2[6], v2 = i2[1], x2 = i2[4], y2 = i2[7], _2 = i2[2], b2 = i2[5], w2 = i2[8];
    return r2[0] = a2 * f2 + o2 * v2 + s2 * _2, r2[3] = a2 * m2 + o2 * x2 + s2 * b2, r2[6] = a2 * g2 + o2 * y2 + s2 * w2, r2[1] = l2 * f2 + c2 * v2 + h2 * _2, r2[4] = l2 * m2 + c2 * x2 + h2 * b2, r2[7] = l2 * g2 + c2 * y2 + h2 * w2, r2[2] = u2 * f2 + d2 * v2 + p2 * _2, r2[5] = u2 * m2 + d2 * x2 + p2 * b2, r2[8] = u2 * g2 + d2 * y2 + p2 * w2, this;
  }
  multiplyScalar(e2) {
    const t2 = this.elements;
    return t2[0] *= e2, t2[3] *= e2, t2[6] *= e2, t2[1] *= e2, t2[4] *= e2, t2[7] *= e2, t2[2] *= e2, t2[5] *= e2, t2[8] *= e2, this;
  }
  determinant() {
    const e2 = this.elements, t2 = e2[0], n2 = e2[1], i2 = e2[2], r2 = e2[3], a2 = e2[4], o2 = e2[5], s2 = e2[6], l2 = e2[7], c2 = e2[8];
    return t2 * a2 * c2 - t2 * o2 * l2 - n2 * r2 * c2 + n2 * o2 * s2 + i2 * r2 * l2 - i2 * a2 * s2;
  }
  invert() {
    const e2 = this.elements, t2 = e2[0], n2 = e2[1], i2 = e2[2], r2 = e2[3], a2 = e2[4], o2 = e2[5], s2 = e2[6], l2 = e2[7], c2 = e2[8], h2 = c2 * a2 - o2 * l2, u2 = o2 * s2 - c2 * r2, d2 = l2 * r2 - a2 * s2, p2 = t2 * h2 + n2 * u2 + i2 * d2;
    if (0 === p2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const f2 = 1 / p2;
    return e2[0] = h2 * f2, e2[1] = (i2 * l2 - c2 * n2) * f2, e2[2] = (o2 * n2 - i2 * a2) * f2, e2[3] = u2 * f2, e2[4] = (c2 * t2 - i2 * s2) * f2, e2[5] = (i2 * r2 - o2 * t2) * f2, e2[6] = d2 * f2, e2[7] = (n2 * s2 - l2 * t2) * f2, e2[8] = (a2 * t2 - n2 * r2) * f2, this;
  }
  transpose() {
    let e2;
    const t2 = this.elements;
    return e2 = t2[1], t2[1] = t2[3], t2[3] = e2, e2 = t2[2], t2[2] = t2[6], t2[6] = e2, e2 = t2[5], t2[5] = t2[7], t2[7] = e2, this;
  }
  getNormalMatrix(e2) {
    return this.setFromMatrix4(e2).invert().transpose();
  }
  transposeIntoArray(e2) {
    const t2 = this.elements;
    return e2[0] = t2[0], e2[1] = t2[3], e2[2] = t2[6], e2[3] = t2[1], e2[4] = t2[4], e2[5] = t2[7], e2[6] = t2[2], e2[7] = t2[5], e2[8] = t2[8], this;
  }
  setUvTransform(e2, t2, n2, i2, r2, a2, o2) {
    const s2 = Math.cos(r2), l2 = Math.sin(r2);
    return this.set(n2 * s2, n2 * l2, -n2 * (s2 * a2 + l2 * o2) + a2 + e2, -i2 * l2, i2 * s2, -i2 * (-l2 * a2 + s2 * o2) + o2 + t2, 0, 0, 1), this;
  }
  scale(e2, t2) {
    const n2 = this.elements;
    return n2[0] *= e2, n2[3] *= e2, n2[6] *= e2, n2[1] *= t2, n2[4] *= t2, n2[7] *= t2, this;
  }
  rotate(e2) {
    const t2 = Math.cos(e2), n2 = Math.sin(e2), i2 = this.elements, r2 = i2[0], a2 = i2[3], o2 = i2[6], s2 = i2[1], l2 = i2[4], c2 = i2[7];
    return i2[0] = t2 * r2 + n2 * s2, i2[3] = t2 * a2 + n2 * l2, i2[6] = t2 * o2 + n2 * c2, i2[1] = -n2 * r2 + t2 * s2, i2[4] = -n2 * a2 + t2 * l2, i2[7] = -n2 * o2 + t2 * c2, this;
  }
  translate(e2, t2) {
    const n2 = this.elements;
    return n2[0] += e2 * n2[2], n2[3] += e2 * n2[5], n2[6] += e2 * n2[8], n2[1] += t2 * n2[2], n2[4] += t2 * n2[5], n2[7] += t2 * n2[8], this;
  }
  equals(e2) {
    const t2 = this.elements, n2 = e2.elements;
    for (let i2 = 0; i2 < 9; i2++) if (t2[i2] !== n2[i2]) return false;
    return true;
  }
  fromArray(e2, t2 = 0) {
    for (let n2 = 0; n2 < 9; n2++) this.elements[n2] = e2[n2 + t2];
    return this;
  }
  toArray(e2 = [], t2 = 0) {
    const n2 = this.elements;
    return e2[t2] = n2[0], e2[t2 + 1] = n2[1], e2[t2 + 2] = n2[2], e2[t2 + 3] = n2[3], e2[t2 + 4] = n2[4], e2[t2 + 5] = n2[5], e2[t2 + 6] = n2[6], e2[t2 + 7] = n2[7], e2[t2 + 8] = n2[8], e2;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var o;
a.prototype.isMatrix3 = true;
var s = { getDataURL: function(e2) {
  if (/^data:/i.test(e2.src)) return e2.src;
  if ("undefined" == typeof HTMLCanvasElement) return e2.src;
  let t2;
  if (e2 instanceof HTMLCanvasElement) t2 = e2;
  else {
    void 0 === o && (o = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), o.width = e2.width, o.height = e2.height;
    const n2 = o.getContext("2d");
    e2 instanceof ImageData ? n2.putImageData(e2, 0, 0) : n2.drawImage(e2, 0, 0, e2.width, e2.height), t2 = o;
  }
  return t2.width > 2048 || t2.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e2), t2.toDataURL("image/jpeg", 0.6)) : t2.toDataURL("image/png");
} };
var l = 0;
var c = class _c extends e {
  constructor(e2 = _c.DEFAULT_IMAGE, t2 = _c.DEFAULT_MAPPING, n2 = 1001, o2 = 1001, s2 = 1006, h2 = 1008, u2 = 1023, d2 = 1009, p2 = 1, f2 = 3e3) {
    super(), Object.defineProperty(this, "id", { value: l++ }), this.uuid = i.generateUUID(), this.name = "", this.image = e2, this.mipmaps = [], this.mapping = t2, this.wrapS = n2, this.wrapT = o2, this.magFilter = s2, this.minFilter = h2, this.anisotropy = p2, this.format = u2, this.internalFormat = null, this.type = d2, this.offset = new r(0, 0), this.repeat = new r(1, 1), this.center = new r(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new a(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = f2, this.version = 0, this.onUpdate = null;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e2) {
    return this.name = e2.name, this.image = e2.image, this.mipmaps = e2.mipmaps.slice(0), this.mapping = e2.mapping, this.wrapS = e2.wrapS, this.wrapT = e2.wrapT, this.magFilter = e2.magFilter, this.minFilter = e2.minFilter, this.anisotropy = e2.anisotropy, this.format = e2.format, this.internalFormat = e2.internalFormat, this.type = e2.type, this.offset.copy(e2.offset), this.repeat.copy(e2.repeat), this.center.copy(e2.center), this.rotation = e2.rotation, this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrix.copy(e2.matrix), this.generateMipmaps = e2.generateMipmaps, this.premultiplyAlpha = e2.premultiplyAlpha, this.flipY = e2.flipY, this.unpackAlignment = e2.unpackAlignment, this.encoding = e2.encoding, this;
  }
  toJSON(e2) {
    const t2 = void 0 === e2 || "string" == typeof e2;
    if (!t2 && void 0 !== e2.textures[this.uuid]) return e2.textures[this.uuid];
    const n2 = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    if (void 0 !== this.image) {
      const r2 = this.image;
      if (void 0 === r2.uuid && (r2.uuid = i.generateUUID()), !t2 && void 0 === e2.images[r2.uuid]) {
        let t3;
        if (Array.isArray(r2)) {
          t3 = [];
          for (let e3 = 0, n3 = r2.length; e3 < n3; e3++) r2[e3].isDataTexture ? t3.push(h(r2[e3].image)) : t3.push(h(r2[e3]));
        } else t3 = h(r2);
        e2.images[r2.uuid] = { uuid: r2.uuid, url: t3 };
      }
      n2.image = r2.uuid;
    }
    return t2 || (e2.textures[this.uuid] = n2), n2;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e2) {
    if (300 !== this.mapping) return e2;
    if (e2.applyMatrix3(this.matrix), e2.x < 0 || e2.x > 1) switch (this.wrapS) {
      case 1e3:
        e2.x = e2.x - Math.floor(e2.x);
        break;
      case 1001:
        e2.x = e2.x < 0 ? 0 : 1;
        break;
      case 1002:
        1 === Math.abs(Math.floor(e2.x) % 2) ? e2.x = Math.ceil(e2.x) - e2.x : e2.x = e2.x - Math.floor(e2.x);
    }
    if (e2.y < 0 || e2.y > 1) switch (this.wrapT) {
      case 1e3:
        e2.y = e2.y - Math.floor(e2.y);
        break;
      case 1001:
        e2.y = e2.y < 0 ? 0 : 1;
        break;
      case 1002:
        1 === Math.abs(Math.floor(e2.y) % 2) ? e2.y = Math.ceil(e2.y) - e2.y : e2.y = e2.y - Math.floor(e2.y);
    }
    return this.flipY && (e2.y = 1 - e2.y), e2;
  }
  set needsUpdate(e2) {
    true === e2 && this.version++;
  }
};
function h(e2) {
  return "undefined" != typeof HTMLImageElement && e2 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e2 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e2 instanceof ImageBitmap ? s.getDataURL(e2) : e2.data ? { data: Array.prototype.slice.call(e2.data), width: e2.width, height: e2.height, type: e2.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
c.DEFAULT_IMAGE = void 0, c.DEFAULT_MAPPING = 300, c.prototype.isTexture = true;
var u = class {
  constructor(e2 = 0, t2 = 0, n2 = 0, i2 = 1) {
    this.x = e2, this.y = t2, this.z = n2, this.w = i2;
  }
  get width() {
    return this.z;
  }
  set width(e2) {
    this.z = e2;
  }
  get height() {
    return this.w;
  }
  set height(e2) {
    this.w = e2;
  }
  set(e2, t2, n2, i2) {
    return this.x = e2, this.y = t2, this.z = n2, this.w = i2, this;
  }
  setScalar(e2) {
    return this.x = e2, this.y = e2, this.z = e2, this.w = e2, this;
  }
  setX(e2) {
    return this.x = e2, this;
  }
  setY(e2) {
    return this.y = e2, this;
  }
  setZ(e2) {
    return this.z = e2, this;
  }
  setW(e2) {
    return this.w = e2, this;
  }
  setComponent(e2, t2) {
    switch (e2) {
      case 0:
        this.x = t2;
        break;
      case 1:
        this.y = t2;
        break;
      case 2:
        this.z = t2;
        break;
      case 3:
        this.w = t2;
        break;
      default:
        throw new Error("index is out of range: " + e2);
    }
    return this;
  }
  getComponent(e2) {
    switch (e2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e2) {
    return this.x = e2.x, this.y = e2.y, this.z = e2.z, this.w = void 0 !== e2.w ? e2.w : 1, this;
  }
  add(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this.z += e2.z, this.w += e2.w, this);
  }
  addScalar(e2) {
    return this.x += e2, this.y += e2, this.z += e2, this.w += e2, this;
  }
  addVectors(e2, t2) {
    return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this.w = e2.w + t2.w, this;
  }
  addScaledVector(e2, t2) {
    return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this.w += e2.w * t2, this;
  }
  sub(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this.w -= e2.w, this);
  }
  subScalar(e2) {
    return this.x -= e2, this.y -= e2, this.z -= e2, this.w -= e2, this;
  }
  subVectors(e2, t2) {
    return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this.w = e2.w - t2.w, this;
  }
  multiply(e2) {
    return this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this.w *= e2.w, this;
  }
  multiplyScalar(e2) {
    return this.x *= e2, this.y *= e2, this.z *= e2, this.w *= e2, this;
  }
  applyMatrix4(e2) {
    const t2 = this.x, n2 = this.y, i2 = this.z, r2 = this.w, a2 = e2.elements;
    return this.x = a2[0] * t2 + a2[4] * n2 + a2[8] * i2 + a2[12] * r2, this.y = a2[1] * t2 + a2[5] * n2 + a2[9] * i2 + a2[13] * r2, this.z = a2[2] * t2 + a2[6] * n2 + a2[10] * i2 + a2[14] * r2, this.w = a2[3] * t2 + a2[7] * n2 + a2[11] * i2 + a2[15] * r2, this;
  }
  divideScalar(e2) {
    return this.multiplyScalar(1 / e2);
  }
  setAxisAngleFromQuaternion(e2) {
    this.w = 2 * Math.acos(e2.w);
    const t2 = Math.sqrt(1 - e2.w * e2.w);
    return t2 < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e2.x / t2, this.y = e2.y / t2, this.z = e2.z / t2), this;
  }
  setAxisAngleFromRotationMatrix(e2) {
    let t2, n2, i2, r2;
    const a2 = 0.01, o2 = 0.1, s2 = e2.elements, l2 = s2[0], c2 = s2[4], h2 = s2[8], u2 = s2[1], d2 = s2[5], p2 = s2[9], f2 = s2[2], m2 = s2[6], g2 = s2[10];
    if (Math.abs(c2 - u2) < a2 && Math.abs(h2 - f2) < a2 && Math.abs(p2 - m2) < a2) {
      if (Math.abs(c2 + u2) < o2 && Math.abs(h2 + f2) < o2 && Math.abs(p2 + m2) < o2 && Math.abs(l2 + d2 + g2 - 3) < o2) return this.set(1, 0, 0, 0), this;
      t2 = Math.PI;
      const e3 = (l2 + 1) / 2, s3 = (d2 + 1) / 2, v3 = (g2 + 1) / 2, x2 = (c2 + u2) / 4, y2 = (h2 + f2) / 4, _2 = (p2 + m2) / 4;
      return e3 > s3 && e3 > v3 ? e3 < a2 ? (n2 = 0, i2 = 0.707106781, r2 = 0.707106781) : (n2 = Math.sqrt(e3), i2 = x2 / n2, r2 = y2 / n2) : s3 > v3 ? s3 < a2 ? (n2 = 0.707106781, i2 = 0, r2 = 0.707106781) : (i2 = Math.sqrt(s3), n2 = x2 / i2, r2 = _2 / i2) : v3 < a2 ? (n2 = 0.707106781, i2 = 0.707106781, r2 = 0) : (r2 = Math.sqrt(v3), n2 = y2 / r2, i2 = _2 / r2), this.set(n2, i2, r2, t2), this;
    }
    let v2 = Math.sqrt((m2 - p2) * (m2 - p2) + (h2 - f2) * (h2 - f2) + (u2 - c2) * (u2 - c2));
    return Math.abs(v2) < 1e-3 && (v2 = 1), this.x = (m2 - p2) / v2, this.y = (h2 - f2) / v2, this.z = (u2 - c2) / v2, this.w = Math.acos((l2 + d2 + g2 - 1) / 2), this;
  }
  min(e2) {
    return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this.w = Math.min(this.w, e2.w), this;
  }
  max(e2) {
    return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this.w = Math.max(this.w, e2.w), this;
  }
  clamp(e2, t2) {
    return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this.w = Math.max(e2.w, Math.min(t2.w, this.w)), this;
  }
  clampScalar(e2, t2) {
    return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this.w = Math.max(e2, Math.min(t2, this.w)), this;
  }
  clampLength(e2, t2) {
    const n2 = this.length();
    return this.divideScalar(n2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, n2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e2) {
    return this.x * e2.x + this.y * e2.y + this.z * e2.z + this.w * e2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e2) {
    return this.normalize().multiplyScalar(e2);
  }
  lerp(e2, t2) {
    return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this.w += (e2.w - this.w) * t2, this;
  }
  lerpVectors(e2, t2, n2) {
    return this.x = e2.x + (t2.x - e2.x) * n2, this.y = e2.y + (t2.y - e2.y) * n2, this.z = e2.z + (t2.z - e2.z) * n2, this.w = e2.w + (t2.w - e2.w) * n2, this;
  }
  equals(e2) {
    return e2.x === this.x && e2.y === this.y && e2.z === this.z && e2.w === this.w;
  }
  fromArray(e2, t2 = 0) {
    return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this.w = e2[t2 + 3], this;
  }
  toArray(e2 = [], t2 = 0) {
    return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2[t2 + 3] = this.w, e2;
  }
  fromBufferAttribute(e2, t2, n2) {
    return void 0 !== n2 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this.w = e2.getW(t2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
};
u.prototype.isVector4 = true;
var d = class extends e {
  constructor(e2, t2, n2) {
    super(), this.width = e2, this.height = t2, this.depth = 1, this.scissor = new u(0, 0, e2, t2), this.scissorTest = false, this.viewport = new u(0, 0, e2, t2), n2 = n2 || {}, this.texture = new c(void 0, n2.mapping, n2.wrapS, n2.wrapT, n2.magFilter, n2.minFilter, n2.format, n2.type, n2.anisotropy, n2.encoding), this.texture.image = {}, this.texture.image.width = e2, this.texture.image.height = t2, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== n2.generateMipmaps && n2.generateMipmaps, this.texture.minFilter = void 0 !== n2.minFilter ? n2.minFilter : 1006, this.depthBuffer = void 0 === n2.depthBuffer || n2.depthBuffer, this.stencilBuffer = void 0 !== n2.stencilBuffer && n2.stencilBuffer, this.depthTexture = void 0 !== n2.depthTexture ? n2.depthTexture : null;
  }
  setTexture(e2) {
    e2.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = e2;
  }
  setSize(e2, t2, n2 = 1) {
    this.width === e2 && this.height === t2 && this.depth === n2 || (this.width = e2, this.height = t2, this.depth = n2, this.texture.image.width = e2, this.texture.image.height = t2, this.texture.image.depth = n2, this.dispose()), this.viewport.set(0, 0, e2, t2), this.scissor.set(0, 0, e2, t2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e2) {
    return this.width = e2.width, this.height = e2.height, this.depth = e2.depth, this.viewport.copy(e2.viewport), this.texture = e2.texture.clone(), this.depthBuffer = e2.depthBuffer, this.stencilBuffer = e2.stencilBuffer, this.depthTexture = e2.depthTexture, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
d.prototype.isWebGLRenderTarget = true;
var p = class {
  constructor(e2 = 0, t2 = 0, n2 = 0, i2 = 1) {
    this._x = e2, this._y = t2, this._z = n2, this._w = i2;
  }
  static slerp(e2, t2, n2, i2) {
    return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n2.slerpQuaternions(e2, t2, i2);
  }
  static slerpFlat(e2, t2, n2, i2, r2, a2, o2) {
    let s2 = n2[i2 + 0], l2 = n2[i2 + 1], c2 = n2[i2 + 2], h2 = n2[i2 + 3];
    const u2 = r2[a2 + 0], d2 = r2[a2 + 1], p2 = r2[a2 + 2], f2 = r2[a2 + 3];
    if (0 === o2) return e2[t2 + 0] = s2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, void (e2[t2 + 3] = h2);
    if (1 === o2) return e2[t2 + 0] = u2, e2[t2 + 1] = d2, e2[t2 + 2] = p2, void (e2[t2 + 3] = f2);
    if (h2 !== f2 || s2 !== u2 || l2 !== d2 || c2 !== p2) {
      let e3 = 1 - o2;
      const t3 = s2 * u2 + l2 * d2 + c2 * p2 + h2 * f2, n3 = t3 >= 0 ? 1 : -1, i3 = 1 - t3 * t3;
      if (i3 > Number.EPSILON) {
        const r4 = Math.sqrt(i3), a3 = Math.atan2(r4, t3 * n3);
        e3 = Math.sin(e3 * a3) / r4, o2 = Math.sin(o2 * a3) / r4;
      }
      const r3 = o2 * n3;
      if (s2 = s2 * e3 + u2 * r3, l2 = l2 * e3 + d2 * r3, c2 = c2 * e3 + p2 * r3, h2 = h2 * e3 + f2 * r3, e3 === 1 - o2) {
        const e4 = 1 / Math.sqrt(s2 * s2 + l2 * l2 + c2 * c2 + h2 * h2);
        s2 *= e4, l2 *= e4, c2 *= e4, h2 *= e4;
      }
    }
    e2[t2] = s2, e2[t2 + 1] = l2, e2[t2 + 2] = c2, e2[t2 + 3] = h2;
  }
  static multiplyQuaternionsFlat(e2, t2, n2, i2, r2, a2) {
    const o2 = n2[i2], s2 = n2[i2 + 1], l2 = n2[i2 + 2], c2 = n2[i2 + 3], h2 = r2[a2], u2 = r2[a2 + 1], d2 = r2[a2 + 2], p2 = r2[a2 + 3];
    return e2[t2] = o2 * p2 + c2 * h2 + s2 * d2 - l2 * u2, e2[t2 + 1] = s2 * p2 + c2 * u2 + l2 * h2 - o2 * d2, e2[t2 + 2] = l2 * p2 + c2 * d2 + o2 * u2 - s2 * h2, e2[t2 + 3] = c2 * p2 - o2 * h2 - s2 * u2 - l2 * d2, e2;
  }
  get x() {
    return this._x;
  }
  set x(e2) {
    this._x = e2, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e2) {
    this._y = e2, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e2) {
    this._z = e2, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e2) {
    this._w = e2, this._onChangeCallback();
  }
  set(e2, t2, n2, i2) {
    return this._x = e2, this._y = t2, this._z = n2, this._w = i2, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e2) {
    return this._x = e2.x, this._y = e2.y, this._z = e2.z, this._w = e2.w, this._onChangeCallback(), this;
  }
  setFromEuler(e2, t2) {
    if (!e2 || !e2.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const n2 = e2._x, i2 = e2._y, r2 = e2._z, a2 = e2._order, o2 = Math.cos, s2 = Math.sin, l2 = o2(n2 / 2), c2 = o2(i2 / 2), h2 = o2(r2 / 2), u2 = s2(n2 / 2), d2 = s2(i2 / 2), p2 = s2(r2 / 2);
    switch (a2) {
      case "XYZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "YXZ":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "ZXY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "ZYX":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      case "YZX":
        this._x = u2 * c2 * h2 + l2 * d2 * p2, this._y = l2 * d2 * h2 + u2 * c2 * p2, this._z = l2 * c2 * p2 - u2 * d2 * h2, this._w = l2 * c2 * h2 - u2 * d2 * p2;
        break;
      case "XZY":
        this._x = u2 * c2 * h2 - l2 * d2 * p2, this._y = l2 * d2 * h2 - u2 * c2 * p2, this._z = l2 * c2 * p2 + u2 * d2 * h2, this._w = l2 * c2 * h2 + u2 * d2 * p2;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a2);
    }
    return false !== t2 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e2, t2) {
    const n2 = t2 / 2, i2 = Math.sin(n2);
    return this._x = e2.x * i2, this._y = e2.y * i2, this._z = e2.z * i2, this._w = Math.cos(n2), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e2) {
    const t2 = e2.elements, n2 = t2[0], i2 = t2[4], r2 = t2[8], a2 = t2[1], o2 = t2[5], s2 = t2[9], l2 = t2[2], c2 = t2[6], h2 = t2[10], u2 = n2 + o2 + h2;
    if (u2 > 0) {
      const e3 = 0.5 / Math.sqrt(u2 + 1);
      this._w = 0.25 / e3, this._x = (c2 - s2) * e3, this._y = (r2 - l2) * e3, this._z = (a2 - i2) * e3;
    } else if (n2 > o2 && n2 > h2) {
      const e3 = 2 * Math.sqrt(1 + n2 - o2 - h2);
      this._w = (c2 - s2) / e3, this._x = 0.25 * e3, this._y = (i2 + a2) / e3, this._z = (r2 + l2) / e3;
    } else if (o2 > h2) {
      const e3 = 2 * Math.sqrt(1 + o2 - n2 - h2);
      this._w = (r2 - l2) / e3, this._x = (i2 + a2) / e3, this._y = 0.25 * e3, this._z = (s2 + c2) / e3;
    } else {
      const e3 = 2 * Math.sqrt(1 + h2 - n2 - o2);
      this._w = (a2 - i2) / e3, this._x = (r2 + l2) / e3, this._y = (s2 + c2) / e3, this._z = 0.25 * e3;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e2, t2) {
    let n2 = e2.dot(t2) + 1;
    return n2 < Number.EPSILON ? (n2 = 0, Math.abs(e2.x) > Math.abs(e2.z) ? (this._x = -e2.y, this._y = e2.x, this._z = 0, this._w = n2) : (this._x = 0, this._y = -e2.z, this._z = e2.y, this._w = n2)) : (this._x = e2.y * t2.z - e2.z * t2.y, this._y = e2.z * t2.x - e2.x * t2.z, this._z = e2.x * t2.y - e2.y * t2.x, this._w = n2), this.normalize();
  }
  angleTo(e2) {
    return 2 * Math.acos(Math.abs(i.clamp(this.dot(e2), -1, 1)));
  }
  rotateTowards(e2, t2) {
    const n2 = this.angleTo(e2);
    if (0 === n2) return this;
    const i2 = Math.min(1, t2 / n2);
    return this.slerp(e2, i2), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e2) {
    return this._x * e2._x + this._y * e2._y + this._z * e2._z + this._w * e2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e2 = this.length();
    return 0 === e2 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e2 = 1 / e2, this._x = this._x * e2, this._y = this._y * e2, this._z = this._z * e2, this._w = this._w * e2), this._onChangeCallback(), this;
  }
  multiply(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e2, t2)) : this.multiplyQuaternions(this, e2);
  }
  premultiply(e2) {
    return this.multiplyQuaternions(e2, this);
  }
  multiplyQuaternions(e2, t2) {
    const n2 = e2._x, i2 = e2._y, r2 = e2._z, a2 = e2._w, o2 = t2._x, s2 = t2._y, l2 = t2._z, c2 = t2._w;
    return this._x = n2 * c2 + a2 * o2 + i2 * l2 - r2 * s2, this._y = i2 * c2 + a2 * s2 + r2 * o2 - n2 * l2, this._z = r2 * c2 + a2 * l2 + n2 * s2 - i2 * o2, this._w = a2 * c2 - n2 * o2 - i2 * s2 - r2 * l2, this._onChangeCallback(), this;
  }
  slerp(e2, t2) {
    if (0 === t2) return this;
    if (1 === t2) return this.copy(e2);
    const n2 = this._x, i2 = this._y, r2 = this._z, a2 = this._w;
    let o2 = a2 * e2._w + n2 * e2._x + i2 * e2._y + r2 * e2._z;
    if (o2 < 0 ? (this._w = -e2._w, this._x = -e2._x, this._y = -e2._y, this._z = -e2._z, o2 = -o2) : this.copy(e2), o2 >= 1) return this._w = a2, this._x = n2, this._y = i2, this._z = r2, this;
    const s2 = 1 - o2 * o2;
    if (s2 <= Number.EPSILON) {
      const e3 = 1 - t2;
      return this._w = e3 * a2 + t2 * this._w, this._x = e3 * n2 + t2 * this._x, this._y = e3 * i2 + t2 * this._y, this._z = e3 * r2 + t2 * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const l2 = Math.sqrt(s2), c2 = Math.atan2(l2, o2), h2 = Math.sin((1 - t2) * c2) / l2, u2 = Math.sin(t2 * c2) / l2;
    return this._w = a2 * h2 + this._w * u2, this._x = n2 * h2 + this._x * u2, this._y = i2 * h2 + this._y * u2, this._z = r2 * h2 + this._z * u2, this._onChangeCallback(), this;
  }
  slerpQuaternions(e2, t2, n2) {
    this.copy(e2).slerp(t2, n2);
  }
  equals(e2) {
    return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._w === this._w;
  }
  fromArray(e2, t2 = 0) {
    return this._x = e2[t2], this._y = e2[t2 + 1], this._z = e2[t2 + 2], this._w = e2[t2 + 3], this._onChangeCallback(), this;
  }
  toArray(e2 = [], t2 = 0) {
    return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._w, e2;
  }
  fromBufferAttribute(e2, t2) {
    return this._x = e2.getX(t2), this._y = e2.getY(t2), this._z = e2.getZ(t2), this._w = e2.getW(t2), this;
  }
  _onChange(e2) {
    return this._onChangeCallback = e2, this;
  }
  _onChangeCallback() {
  }
};
p.prototype.isQuaternion = true;
var f = class {
  constructor(e2 = 0, t2 = 0, n2 = 0) {
    this.x = e2, this.y = t2, this.z = n2;
  }
  set(e2, t2, n2) {
    return void 0 === n2 && (n2 = this.z), this.x = e2, this.y = t2, this.z = n2, this;
  }
  setScalar(e2) {
    return this.x = e2, this.y = e2, this.z = e2, this;
  }
  setX(e2) {
    return this.x = e2, this;
  }
  setY(e2) {
    return this.y = e2, this;
  }
  setZ(e2) {
    return this.z = e2, this;
  }
  setComponent(e2, t2) {
    switch (e2) {
      case 0:
        this.x = t2;
        break;
      case 1:
        this.y = t2;
        break;
      case 2:
        this.z = t2;
        break;
      default:
        throw new Error("index is out of range: " + e2);
    }
    return this;
  }
  getComponent(e2) {
    switch (e2) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e2);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e2) {
    return this.x = e2.x, this.y = e2.y, this.z = e2.z, this;
  }
  add(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e2, t2)) : (this.x += e2.x, this.y += e2.y, this.z += e2.z, this);
  }
  addScalar(e2) {
    return this.x += e2, this.y += e2, this.z += e2, this;
  }
  addVectors(e2, t2) {
    return this.x = e2.x + t2.x, this.y = e2.y + t2.y, this.z = e2.z + t2.z, this;
  }
  addScaledVector(e2, t2) {
    return this.x += e2.x * t2, this.y += e2.y * t2, this.z += e2.z * t2, this;
  }
  sub(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e2, t2)) : (this.x -= e2.x, this.y -= e2.y, this.z -= e2.z, this);
  }
  subScalar(e2) {
    return this.x -= e2, this.y -= e2, this.z -= e2, this;
  }
  subVectors(e2, t2) {
    return this.x = e2.x - t2.x, this.y = e2.y - t2.y, this.z = e2.z - t2.z, this;
  }
  multiply(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e2, t2)) : (this.x *= e2.x, this.y *= e2.y, this.z *= e2.z, this);
  }
  multiplyScalar(e2) {
    return this.x *= e2, this.y *= e2, this.z *= e2, this;
  }
  multiplyVectors(e2, t2) {
    return this.x = e2.x * t2.x, this.y = e2.y * t2.y, this.z = e2.z * t2.z, this;
  }
  applyEuler(e2) {
    return e2 && e2.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(g.setFromEuler(e2));
  }
  applyAxisAngle(e2, t2) {
    return this.applyQuaternion(g.setFromAxisAngle(e2, t2));
  }
  applyMatrix3(e2) {
    const t2 = this.x, n2 = this.y, i2 = this.z, r2 = e2.elements;
    return this.x = r2[0] * t2 + r2[3] * n2 + r2[6] * i2, this.y = r2[1] * t2 + r2[4] * n2 + r2[7] * i2, this.z = r2[2] * t2 + r2[5] * n2 + r2[8] * i2, this;
  }
  applyNormalMatrix(e2) {
    return this.applyMatrix3(e2).normalize();
  }
  applyMatrix4(e2) {
    const t2 = this.x, n2 = this.y, i2 = this.z, r2 = e2.elements, a2 = 1 / (r2[3] * t2 + r2[7] * n2 + r2[11] * i2 + r2[15]);
    return this.x = (r2[0] * t2 + r2[4] * n2 + r2[8] * i2 + r2[12]) * a2, this.y = (r2[1] * t2 + r2[5] * n2 + r2[9] * i2 + r2[13]) * a2, this.z = (r2[2] * t2 + r2[6] * n2 + r2[10] * i2 + r2[14]) * a2, this;
  }
  applyQuaternion(e2) {
    const t2 = this.x, n2 = this.y, i2 = this.z, r2 = e2.x, a2 = e2.y, o2 = e2.z, s2 = e2.w, l2 = s2 * t2 + a2 * i2 - o2 * n2, c2 = s2 * n2 + o2 * t2 - r2 * i2, h2 = s2 * i2 + r2 * n2 - a2 * t2, u2 = -r2 * t2 - a2 * n2 - o2 * i2;
    return this.x = l2 * s2 + u2 * -r2 + c2 * -o2 - h2 * -a2, this.y = c2 * s2 + u2 * -a2 + h2 * -r2 - l2 * -o2, this.z = h2 * s2 + u2 * -o2 + l2 * -a2 - c2 * -r2, this;
  }
  project(e2) {
    return this.applyMatrix4(e2.matrixWorldInverse).applyMatrix4(e2.projectionMatrix);
  }
  unproject(e2) {
    return this.applyMatrix4(e2.projectionMatrixInverse).applyMatrix4(e2.matrixWorld);
  }
  transformDirection(e2) {
    const t2 = this.x, n2 = this.y, i2 = this.z, r2 = e2.elements;
    return this.x = r2[0] * t2 + r2[4] * n2 + r2[8] * i2, this.y = r2[1] * t2 + r2[5] * n2 + r2[9] * i2, this.z = r2[2] * t2 + r2[6] * n2 + r2[10] * i2, this.normalize();
  }
  divide(e2) {
    return this.x /= e2.x, this.y /= e2.y, this.z /= e2.z, this;
  }
  divideScalar(e2) {
    return this.multiplyScalar(1 / e2);
  }
  min(e2) {
    return this.x = Math.min(this.x, e2.x), this.y = Math.min(this.y, e2.y), this.z = Math.min(this.z, e2.z), this;
  }
  max(e2) {
    return this.x = Math.max(this.x, e2.x), this.y = Math.max(this.y, e2.y), this.z = Math.max(this.z, e2.z), this;
  }
  clamp(e2, t2) {
    return this.x = Math.max(e2.x, Math.min(t2.x, this.x)), this.y = Math.max(e2.y, Math.min(t2.y, this.y)), this.z = Math.max(e2.z, Math.min(t2.z, this.z)), this;
  }
  clampScalar(e2, t2) {
    return this.x = Math.max(e2, Math.min(t2, this.x)), this.y = Math.max(e2, Math.min(t2, this.y)), this.z = Math.max(e2, Math.min(t2, this.z)), this;
  }
  clampLength(e2, t2) {
    const n2 = this.length();
    return this.divideScalar(n2 || 1).multiplyScalar(Math.max(e2, Math.min(t2, n2)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e2) {
    return this.x * e2.x + this.y * e2.y + this.z * e2.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e2) {
    return this.normalize().multiplyScalar(e2);
  }
  lerp(e2, t2) {
    return this.x += (e2.x - this.x) * t2, this.y += (e2.y - this.y) * t2, this.z += (e2.z - this.z) * t2, this;
  }
  lerpVectors(e2, t2, n2) {
    return this.x = e2.x + (t2.x - e2.x) * n2, this.y = e2.y + (t2.y - e2.y) * n2, this.z = e2.z + (t2.z - e2.z) * n2, this;
  }
  cross(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e2, t2)) : this.crossVectors(this, e2);
  }
  crossVectors(e2, t2) {
    const n2 = e2.x, i2 = e2.y, r2 = e2.z, a2 = t2.x, o2 = t2.y, s2 = t2.z;
    return this.x = i2 * s2 - r2 * o2, this.y = r2 * a2 - n2 * s2, this.z = n2 * o2 - i2 * a2, this;
  }
  projectOnVector(e2) {
    const t2 = e2.lengthSq();
    if (0 === t2) return this.set(0, 0, 0);
    const n2 = e2.dot(this) / t2;
    return this.copy(e2).multiplyScalar(n2);
  }
  projectOnPlane(e2) {
    return m.copy(this).projectOnVector(e2), this.sub(m);
  }
  reflect(e2) {
    return this.sub(m.copy(e2).multiplyScalar(2 * this.dot(e2)));
  }
  angleTo(e2) {
    const t2 = Math.sqrt(this.lengthSq() * e2.lengthSq());
    if (0 === t2) return Math.PI / 2;
    const n2 = this.dot(e2) / t2;
    return Math.acos(i.clamp(n2, -1, 1));
  }
  distanceTo(e2) {
    return Math.sqrt(this.distanceToSquared(e2));
  }
  distanceToSquared(e2) {
    const t2 = this.x - e2.x, n2 = this.y - e2.y, i2 = this.z - e2.z;
    return t2 * t2 + n2 * n2 + i2 * i2;
  }
  manhattanDistanceTo(e2) {
    return Math.abs(this.x - e2.x) + Math.abs(this.y - e2.y) + Math.abs(this.z - e2.z);
  }
  setFromSpherical(e2) {
    return this.setFromSphericalCoords(e2.radius, e2.phi, e2.theta);
  }
  setFromSphericalCoords(e2, t2, n2) {
    const i2 = Math.sin(t2) * e2;
    return this.x = i2 * Math.sin(n2), this.y = Math.cos(t2) * e2, this.z = i2 * Math.cos(n2), this;
  }
  setFromCylindrical(e2) {
    return this.setFromCylindricalCoords(e2.radius, e2.theta, e2.y);
  }
  setFromCylindricalCoords(e2, t2, n2) {
    return this.x = e2 * Math.sin(t2), this.y = n2, this.z = e2 * Math.cos(t2), this;
  }
  setFromMatrixPosition(e2) {
    const t2 = e2.elements;
    return this.x = t2[12], this.y = t2[13], this.z = t2[14], this;
  }
  setFromMatrixScale(e2) {
    const t2 = this.setFromMatrixColumn(e2, 0).length(), n2 = this.setFromMatrixColumn(e2, 1).length(), i2 = this.setFromMatrixColumn(e2, 2).length();
    return this.x = t2, this.y = n2, this.z = i2, this;
  }
  setFromMatrixColumn(e2, t2) {
    return this.fromArray(e2.elements, 4 * t2);
  }
  setFromMatrix3Column(e2, t2) {
    return this.fromArray(e2.elements, 3 * t2);
  }
  equals(e2) {
    return e2.x === this.x && e2.y === this.y && e2.z === this.z;
  }
  fromArray(e2, t2 = 0) {
    return this.x = e2[t2], this.y = e2[t2 + 1], this.z = e2[t2 + 2], this;
  }
  toArray(e2 = [], t2 = 0) {
    return e2[t2] = this.x, e2[t2 + 1] = this.y, e2[t2 + 2] = this.z, e2;
  }
  fromBufferAttribute(e2, t2, n2) {
    return void 0 !== n2 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e2.getX(t2), this.y = e2.getY(t2), this.z = e2.getZ(t2), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
};
f.prototype.isVector3 = true;
var m = new f();
var g = new p();
var v = class {
  constructor(e2 = new f(1 / 0, 1 / 0, 1 / 0), t2 = new f(-1 / 0, -1 / 0, -1 / 0)) {
    this.min = e2, this.max = t2;
  }
  set(e2, t2) {
    return this.min.copy(e2), this.max.copy(t2), this;
  }
  setFromArray(e2) {
    let t2 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, a2 = -1 / 0, o2 = -1 / 0;
    for (let s2 = 0, l2 = e2.length; s2 < l2; s2 += 3) {
      const l3 = e2[s2], c2 = e2[s2 + 1], h2 = e2[s2 + 2];
      l3 < t2 && (t2 = l3), c2 < n2 && (n2 = c2), h2 < i2 && (i2 = h2), l3 > r2 && (r2 = l3), c2 > a2 && (a2 = c2), h2 > o2 && (o2 = h2);
    }
    return this.min.set(t2, n2, i2), this.max.set(r2, a2, o2), this;
  }
  setFromBufferAttribute(e2) {
    let t2 = 1 / 0, n2 = 1 / 0, i2 = 1 / 0, r2 = -1 / 0, a2 = -1 / 0, o2 = -1 / 0;
    for (let s2 = 0, l2 = e2.count; s2 < l2; s2++) {
      const l3 = e2.getX(s2), c2 = e2.getY(s2), h2 = e2.getZ(s2);
      l3 < t2 && (t2 = l3), c2 < n2 && (n2 = c2), h2 < i2 && (i2 = h2), l3 > r2 && (r2 = l3), c2 > a2 && (a2 = c2), h2 > o2 && (o2 = h2);
    }
    return this.min.set(t2, n2, i2), this.max.set(r2, a2, o2), this;
  }
  setFromPoints(e2) {
    this.makeEmpty();
    for (let t2 = 0, n2 = e2.length; t2 < n2; t2++) this.expandByPoint(e2[t2]);
    return this;
  }
  setFromCenterAndSize(e2, t2) {
    const n2 = y.copy(t2).multiplyScalar(0.5);
    return this.min.copy(e2).sub(n2), this.max.copy(e2).add(n2), this;
  }
  setFromObject(e2) {
    return this.makeEmpty(), this.expandByObject(e2);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e2) {
    return this.min.copy(e2.min), this.max.copy(e2.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e2) {
    return void 0 === e2 && (console.warn("THREE.Box3: .getCenter() target is now required"), e2 = new f()), this.isEmpty() ? e2.set(0, 0, 0) : e2.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e2) {
    return void 0 === e2 && (console.warn("THREE.Box3: .getSize() target is now required"), e2 = new f()), this.isEmpty() ? e2.set(0, 0, 0) : e2.subVectors(this.max, this.min);
  }
  expandByPoint(e2) {
    return this.min.min(e2), this.max.max(e2), this;
  }
  expandByVector(e2) {
    return this.min.sub(e2), this.max.add(e2), this;
  }
  expandByScalar(e2) {
    return this.min.addScalar(-e2), this.max.addScalar(e2), this;
  }
  expandByObject(e2) {
    e2.updateWorldMatrix(false, false);
    const t2 = e2.geometry;
    void 0 !== t2 && (null === t2.boundingBox && t2.computeBoundingBox(), _.copy(t2.boundingBox), _.applyMatrix4(e2.matrixWorld), this.union(_));
    const n2 = e2.children;
    for (let i2 = 0, r2 = n2.length; i2 < r2; i2++) this.expandByObject(n2[i2]);
    return this;
  }
  containsPoint(e2) {
    return !(e2.x < this.min.x || e2.x > this.max.x || e2.y < this.min.y || e2.y > this.max.y || e2.z < this.min.z || e2.z > this.max.z);
  }
  containsBox(e2) {
    return this.min.x <= e2.min.x && e2.max.x <= this.max.x && this.min.y <= e2.min.y && e2.max.y <= this.max.y && this.min.z <= e2.min.z && e2.max.z <= this.max.z;
  }
  getParameter(e2, t2) {
    return void 0 === t2 && (console.warn("THREE.Box3: .getParameter() target is now required"), t2 = new f()), t2.set((e2.x - this.min.x) / (this.max.x - this.min.x), (e2.y - this.min.y) / (this.max.y - this.min.y), (e2.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e2) {
    return !(e2.max.x < this.min.x || e2.min.x > this.max.x || e2.max.y < this.min.y || e2.min.y > this.max.y || e2.max.z < this.min.z || e2.min.z > this.max.z);
  }
  intersectsSphere(e2) {
    return this.clampPoint(e2.center, y), y.distanceToSquared(e2.center) <= e2.radius * e2.radius;
  }
  intersectsPlane(e2) {
    let t2, n2;
    return e2.normal.x > 0 ? (t2 = e2.normal.x * this.min.x, n2 = e2.normal.x * this.max.x) : (t2 = e2.normal.x * this.max.x, n2 = e2.normal.x * this.min.x), e2.normal.y > 0 ? (t2 += e2.normal.y * this.min.y, n2 += e2.normal.y * this.max.y) : (t2 += e2.normal.y * this.max.y, n2 += e2.normal.y * this.min.y), e2.normal.z > 0 ? (t2 += e2.normal.z * this.min.z, n2 += e2.normal.z * this.max.z) : (t2 += e2.normal.z * this.max.z, n2 += e2.normal.z * this.min.z), t2 <= -e2.constant && n2 >= -e2.constant;
  }
  intersectsTriangle(e2) {
    if (this.isEmpty()) return false;
    this.getCenter(L), R.subVectors(this.max, L), b.subVectors(e2.a, L), w.subVectors(e2.b, L), M.subVectors(e2.c, L), S.subVectors(w, b), T.subVectors(M, w), E.subVectors(b, M);
    let t2 = [0, -S.z, S.y, 0, -T.z, T.y, 0, -E.z, E.y, S.z, 0, -S.x, T.z, 0, -T.x, E.z, 0, -E.x, -S.y, S.x, 0, -T.y, T.x, 0, -E.y, E.x, 0];
    return !!C(t2, b, w, M, R) && (t2 = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!C(t2, b, w, M, R) && (A.crossVectors(S, T), t2 = [A.x, A.y, A.z], C(t2, b, w, M, R)));
  }
  clampPoint(e2, t2) {
    return void 0 === t2 && (console.warn("THREE.Box3: .clampPoint() target is now required"), t2 = new f()), t2.copy(e2).clamp(this.min, this.max);
  }
  distanceToPoint(e2) {
    return y.copy(e2).clamp(this.min, this.max).sub(e2).length();
  }
  getBoundingSphere(e2) {
    return void 0 === e2 && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e2.center), e2.radius = 0.5 * this.getSize(y).length(), e2;
  }
  intersect(e2) {
    return this.min.max(e2.min), this.max.min(e2.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e2) {
    return this.min.min(e2.min), this.max.max(e2.max), this;
  }
  applyMatrix4(e2) {
    return this.isEmpty() || (x[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e2), x[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e2), x[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e2), x[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e2), x[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e2), x[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e2), x[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e2), x[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e2), this.setFromPoints(x)), this;
  }
  translate(e2) {
    return this.min.add(e2), this.max.add(e2), this;
  }
  equals(e2) {
    return e2.min.equals(this.min) && e2.max.equals(this.max);
  }
};
v.prototype.isBox3 = true;
var x = [new f(), new f(), new f(), new f(), new f(), new f(), new f(), new f()];
var y = new f();
var _ = new v();
var b = new f();
var w = new f();
var M = new f();
var S = new f();
var T = new f();
var E = new f();
var L = new f();
var R = new f();
var A = new f();
var P = new f();
function C(e2, t2, n2, i2, r2) {
  for (let a2 = 0, o2 = e2.length - 3; a2 <= o2; a2 += 3) {
    P.fromArray(e2, a2);
    const o3 = r2.x * Math.abs(P.x) + r2.y * Math.abs(P.y) + r2.z * Math.abs(P.z), s2 = t2.dot(P), l2 = n2.dot(P), c2 = i2.dot(P);
    if (Math.max(-Math.max(s2, l2, c2), Math.min(s2, l2, c2)) > o3) return false;
  }
  return true;
}
var D = new v();
var I = new f();
var N = new f();
var O = new f();
var U = class {
  constructor(e2 = new f(), t2 = -1) {
    this.center = e2, this.radius = t2;
  }
  set(e2, t2) {
    return this.center.copy(e2), this.radius = t2, this;
  }
  setFromPoints(e2, t2) {
    const n2 = this.center;
    void 0 !== t2 ? n2.copy(t2) : D.setFromPoints(e2).getCenter(n2);
    let i2 = 0;
    for (let r2 = 0, a2 = e2.length; r2 < a2; r2++) i2 = Math.max(i2, n2.distanceToSquared(e2[r2]));
    return this.radius = Math.sqrt(i2), this;
  }
  copy(e2) {
    return this.center.copy(e2.center), this.radius = e2.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e2) {
    return e2.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e2) {
    return e2.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e2) {
    const t2 = this.radius + e2.radius;
    return e2.center.distanceToSquared(this.center) <= t2 * t2;
  }
  intersectsBox(e2) {
    return e2.intersectsSphere(this);
  }
  intersectsPlane(e2) {
    return Math.abs(e2.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e2, t2) {
    const n2 = this.center.distanceToSquared(e2);
    return void 0 === t2 && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t2 = new f()), t2.copy(e2), n2 > this.radius * this.radius && (t2.sub(this.center).normalize(), t2.multiplyScalar(this.radius).add(this.center)), t2;
  }
  getBoundingBox(e2) {
    return void 0 === e2 && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e2 = new v()), this.isEmpty() ? (e2.makeEmpty(), e2) : (e2.set(this.center, this.center), e2.expandByScalar(this.radius), e2);
  }
  applyMatrix4(e2) {
    return this.center.applyMatrix4(e2), this.radius = this.radius * e2.getMaxScaleOnAxis(), this;
  }
  translate(e2) {
    return this.center.add(e2), this;
  }
  expandByPoint(e2) {
    O.subVectors(e2, this.center);
    const t2 = O.lengthSq();
    if (t2 > this.radius * this.radius) {
      const e3 = Math.sqrt(t2), n2 = 0.5 * (e3 - this.radius);
      this.center.add(O.multiplyScalar(n2 / e3)), this.radius += n2;
    }
    return this;
  }
  union(e2) {
    return N.subVectors(e2.center, this.center).normalize().multiplyScalar(e2.radius), this.expandByPoint(I.copy(e2.center).add(N)), this.expandByPoint(I.copy(e2.center).sub(N)), this;
  }
  equals(e2) {
    return e2.center.equals(this.center) && e2.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var F = new f();
var H = new f();
var z = new f();
var B = new f();
var G = new f();
var k = new f();
var V = new f();
var W = class {
  constructor(e2 = new f(), t2 = new f(0, 0, -1)) {
    this.origin = e2, this.direction = t2;
  }
  set(e2, t2) {
    return this.origin.copy(e2), this.direction.copy(t2), this;
  }
  copy(e2) {
    return this.origin.copy(e2.origin), this.direction.copy(e2.direction), this;
  }
  at(e2, t2) {
    return void 0 === t2 && (console.warn("THREE.Ray: .at() target is now required"), t2 = new f()), t2.copy(this.direction).multiplyScalar(e2).add(this.origin);
  }
  lookAt(e2) {
    return this.direction.copy(e2).sub(this.origin).normalize(), this;
  }
  recast(e2) {
    return this.origin.copy(this.at(e2, F)), this;
  }
  closestPointToPoint(e2, t2) {
    void 0 === t2 && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t2 = new f()), t2.subVectors(e2, this.origin);
    const n2 = t2.dot(this.direction);
    return n2 < 0 ? t2.copy(this.origin) : t2.copy(this.direction).multiplyScalar(n2).add(this.origin);
  }
  distanceToPoint(e2) {
    return Math.sqrt(this.distanceSqToPoint(e2));
  }
  distanceSqToPoint(e2) {
    const t2 = F.subVectors(e2, this.origin).dot(this.direction);
    return t2 < 0 ? this.origin.distanceToSquared(e2) : (F.copy(this.direction).multiplyScalar(t2).add(this.origin), F.distanceToSquared(e2));
  }
  distanceSqToSegment(e2, t2, n2, i2) {
    H.copy(e2).add(t2).multiplyScalar(0.5), z.copy(t2).sub(e2).normalize(), B.copy(this.origin).sub(H);
    const r2 = 0.5 * e2.distanceTo(t2), a2 = -this.direction.dot(z), o2 = B.dot(this.direction), s2 = -B.dot(z), l2 = B.lengthSq(), c2 = Math.abs(1 - a2 * a2);
    let h2, u2, d2, p2;
    if (c2 > 0) if (h2 = a2 * s2 - o2, u2 = a2 * o2 - s2, p2 = r2 * c2, h2 >= 0) if (u2 >= -p2) if (u2 <= p2) {
      const e3 = 1 / c2;
      h2 *= e3, u2 *= e3, d2 = h2 * (h2 + a2 * u2 + 2 * o2) + u2 * (a2 * h2 + u2 + 2 * s2) + l2;
    } else u2 = r2, h2 = Math.max(0, -(a2 * u2 + o2)), d2 = -h2 * h2 + u2 * (u2 + 2 * s2) + l2;
    else u2 = -r2, h2 = Math.max(0, -(a2 * u2 + o2)), d2 = -h2 * h2 + u2 * (u2 + 2 * s2) + l2;
    else u2 <= -p2 ? (h2 = Math.max(0, -(-a2 * r2 + o2)), u2 = h2 > 0 ? -r2 : Math.min(Math.max(-r2, -s2), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * s2) + l2) : u2 <= p2 ? (h2 = 0, u2 = Math.min(Math.max(-r2, -s2), r2), d2 = u2 * (u2 + 2 * s2) + l2) : (h2 = Math.max(0, -(a2 * r2 + o2)), u2 = h2 > 0 ? r2 : Math.min(Math.max(-r2, -s2), r2), d2 = -h2 * h2 + u2 * (u2 + 2 * s2) + l2);
    else u2 = a2 > 0 ? -r2 : r2, h2 = Math.max(0, -(a2 * u2 + o2)), d2 = -h2 * h2 + u2 * (u2 + 2 * s2) + l2;
    return n2 && n2.copy(this.direction).multiplyScalar(h2).add(this.origin), i2 && i2.copy(z).multiplyScalar(u2).add(H), d2;
  }
  intersectSphere(e2, t2) {
    F.subVectors(e2.center, this.origin);
    const n2 = F.dot(this.direction), i2 = F.dot(F) - n2 * n2, r2 = e2.radius * e2.radius;
    if (i2 > r2) return null;
    const a2 = Math.sqrt(r2 - i2), o2 = n2 - a2, s2 = n2 + a2;
    return o2 < 0 && s2 < 0 ? null : o2 < 0 ? this.at(s2, t2) : this.at(o2, t2);
  }
  intersectsSphere(e2) {
    return this.distanceSqToPoint(e2.center) <= e2.radius * e2.radius;
  }
  distanceToPlane(e2) {
    const t2 = e2.normal.dot(this.direction);
    if (0 === t2) return 0 === e2.distanceToPoint(this.origin) ? 0 : null;
    const n2 = -(this.origin.dot(e2.normal) + e2.constant) / t2;
    return n2 >= 0 ? n2 : null;
  }
  intersectPlane(e2, t2) {
    const n2 = this.distanceToPlane(e2);
    return null === n2 ? null : this.at(n2, t2);
  }
  intersectsPlane(e2) {
    const t2 = e2.distanceToPoint(this.origin);
    if (0 === t2) return true;
    return e2.normal.dot(this.direction) * t2 < 0;
  }
  intersectBox(e2, t2) {
    let n2, i2, r2, a2, o2, s2;
    const l2 = 1 / this.direction.x, c2 = 1 / this.direction.y, h2 = 1 / this.direction.z, u2 = this.origin;
    return l2 >= 0 ? (n2 = (e2.min.x - u2.x) * l2, i2 = (e2.max.x - u2.x) * l2) : (n2 = (e2.max.x - u2.x) * l2, i2 = (e2.min.x - u2.x) * l2), c2 >= 0 ? (r2 = (e2.min.y - u2.y) * c2, a2 = (e2.max.y - u2.y) * c2) : (r2 = (e2.max.y - u2.y) * c2, a2 = (e2.min.y - u2.y) * c2), n2 > a2 || r2 > i2 ? null : ((r2 > n2 || n2 != n2) && (n2 = r2), (a2 < i2 || i2 != i2) && (i2 = a2), h2 >= 0 ? (o2 = (e2.min.z - u2.z) * h2, s2 = (e2.max.z - u2.z) * h2) : (o2 = (e2.max.z - u2.z) * h2, s2 = (e2.min.z - u2.z) * h2), n2 > s2 || o2 > i2 ? null : ((o2 > n2 || n2 != n2) && (n2 = o2), (s2 < i2 || i2 != i2) && (i2 = s2), i2 < 0 ? null : this.at(n2 >= 0 ? n2 : i2, t2)));
  }
  intersectsBox(e2) {
    return null !== this.intersectBox(e2, F);
  }
  intersectTriangle(e2, t2, n2, i2, r2) {
    G.subVectors(t2, e2), k.subVectors(n2, e2), V.crossVectors(G, k);
    let a2, o2 = this.direction.dot(V);
    if (o2 > 0) {
      if (i2) return null;
      a2 = 1;
    } else {
      if (!(o2 < 0)) return null;
      a2 = -1, o2 = -o2;
    }
    B.subVectors(this.origin, e2);
    const s2 = a2 * this.direction.dot(k.crossVectors(B, k));
    if (s2 < 0) return null;
    const l2 = a2 * this.direction.dot(G.cross(B));
    if (l2 < 0) return null;
    if (s2 + l2 > o2) return null;
    const c2 = -a2 * B.dot(V);
    return c2 < 0 ? null : this.at(c2 / o2, r2);
  }
  applyMatrix4(e2) {
    return this.origin.applyMatrix4(e2), this.direction.transformDirection(e2), this;
  }
  equals(e2) {
    return e2.origin.equals(this.origin) && e2.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var j = class _j {
  constructor() {
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
  }
  set(e2, t2, n2, i2, r2, a2, o2, s2, l2, c2, h2, u2, d2, p2, f2, m2) {
    const g2 = this.elements;
    return g2[0] = e2, g2[4] = t2, g2[8] = n2, g2[12] = i2, g2[1] = r2, g2[5] = a2, g2[9] = o2, g2[13] = s2, g2[2] = l2, g2[6] = c2, g2[10] = h2, g2[14] = u2, g2[3] = d2, g2[7] = p2, g2[11] = f2, g2[15] = m2, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new _j().fromArray(this.elements);
  }
  copy(e2) {
    const t2 = this.elements, n2 = e2.elements;
    return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2[6] = n2[6], t2[7] = n2[7], t2[8] = n2[8], t2[9] = n2[9], t2[10] = n2[10], t2[11] = n2[11], t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15], this;
  }
  copyPosition(e2) {
    const t2 = this.elements, n2 = e2.elements;
    return t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], this;
  }
  setFromMatrix3(e2) {
    const t2 = e2.elements;
    return this.set(t2[0], t2[3], t2[6], 0, t2[1], t2[4], t2[7], 0, t2[2], t2[5], t2[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e2, t2, n2) {
    return e2.setFromMatrixColumn(this, 0), t2.setFromMatrixColumn(this, 1), n2.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e2, t2, n2) {
    return this.set(e2.x, t2.x, n2.x, 0, e2.y, t2.y, n2.y, 0, e2.z, t2.z, n2.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e2) {
    const t2 = this.elements, n2 = e2.elements, i2 = 1 / q.setFromMatrixColumn(e2, 0).length(), r2 = 1 / q.setFromMatrixColumn(e2, 1).length(), a2 = 1 / q.setFromMatrixColumn(e2, 2).length();
    return t2[0] = n2[0] * i2, t2[1] = n2[1] * i2, t2[2] = n2[2] * i2, t2[3] = 0, t2[4] = n2[4] * r2, t2[5] = n2[5] * r2, t2[6] = n2[6] * r2, t2[7] = 0, t2[8] = n2[8] * a2, t2[9] = n2[9] * a2, t2[10] = n2[10] * a2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
  }
  makeRotationFromEuler(e2) {
    e2 && e2.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    const t2 = this.elements, n2 = e2.x, i2 = e2.y, r2 = e2.z, a2 = Math.cos(n2), o2 = Math.sin(n2), s2 = Math.cos(i2), l2 = Math.sin(i2), c2 = Math.cos(r2), h2 = Math.sin(r2);
    if ("XYZ" === e2.order) {
      const e3 = a2 * c2, n3 = a2 * h2, i3 = o2 * c2, r3 = o2 * h2;
      t2[0] = s2 * c2, t2[4] = -s2 * h2, t2[8] = l2, t2[1] = n3 + i3 * l2, t2[5] = e3 - r3 * l2, t2[9] = -o2 * s2, t2[2] = r3 - e3 * l2, t2[6] = i3 + n3 * l2, t2[10] = a2 * s2;
    } else if ("YXZ" === e2.order) {
      const e3 = s2 * c2, n3 = s2 * h2, i3 = l2 * c2, r3 = l2 * h2;
      t2[0] = e3 + r3 * o2, t2[4] = i3 * o2 - n3, t2[8] = a2 * l2, t2[1] = a2 * h2, t2[5] = a2 * c2, t2[9] = -o2, t2[2] = n3 * o2 - i3, t2[6] = r3 + e3 * o2, t2[10] = a2 * s2;
    } else if ("ZXY" === e2.order) {
      const e3 = s2 * c2, n3 = s2 * h2, i3 = l2 * c2, r3 = l2 * h2;
      t2[0] = e3 - r3 * o2, t2[4] = -a2 * h2, t2[8] = i3 + n3 * o2, t2[1] = n3 + i3 * o2, t2[5] = a2 * c2, t2[9] = r3 - e3 * o2, t2[2] = -a2 * l2, t2[6] = o2, t2[10] = a2 * s2;
    } else if ("ZYX" === e2.order) {
      const e3 = a2 * c2, n3 = a2 * h2, i3 = o2 * c2, r3 = o2 * h2;
      t2[0] = s2 * c2, t2[4] = i3 * l2 - n3, t2[8] = e3 * l2 + r3, t2[1] = s2 * h2, t2[5] = r3 * l2 + e3, t2[9] = n3 * l2 - i3, t2[2] = -l2, t2[6] = o2 * s2, t2[10] = a2 * s2;
    } else if ("YZX" === e2.order) {
      const e3 = a2 * s2, n3 = a2 * l2, i3 = o2 * s2, r3 = o2 * l2;
      t2[0] = s2 * c2, t2[4] = r3 - e3 * h2, t2[8] = i3 * h2 + n3, t2[1] = h2, t2[5] = a2 * c2, t2[9] = -o2 * c2, t2[2] = -l2 * c2, t2[6] = n3 * h2 + i3, t2[10] = e3 - r3 * h2;
    } else if ("XZY" === e2.order) {
      const e3 = a2 * s2, n3 = a2 * l2, i3 = o2 * s2, r3 = o2 * l2;
      t2[0] = s2 * c2, t2[4] = -h2, t2[8] = l2 * c2, t2[1] = e3 * h2 + r3, t2[5] = a2 * c2, t2[9] = n3 * h2 - i3, t2[2] = i3 * h2 - n3, t2[6] = o2 * c2, t2[10] = r3 * h2 + e3;
    }
    return t2[3] = 0, t2[7] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, this;
  }
  makeRotationFromQuaternion(e2) {
    return this.compose(Y, e2, Z);
  }
  lookAt(e2, t2, n2) {
    const i2 = this.elements;
    return Q.subVectors(e2, t2), 0 === Q.lengthSq() && (Q.z = 1), Q.normalize(), J.crossVectors(n2, Q), 0 === J.lengthSq() && (1 === Math.abs(n2.z) ? Q.x += 1e-4 : Q.z += 1e-4, Q.normalize(), J.crossVectors(n2, Q)), J.normalize(), K.crossVectors(Q, J), i2[0] = J.x, i2[4] = K.x, i2[8] = Q.x, i2[1] = J.y, i2[5] = K.y, i2[9] = Q.y, i2[2] = J.z, i2[6] = K.z, i2[10] = Q.z, this;
  }
  multiply(e2, t2) {
    return void 0 !== t2 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e2, t2)) : this.multiplyMatrices(this, e2);
  }
  premultiply(e2) {
    return this.multiplyMatrices(e2, this);
  }
  multiplyMatrices(e2, t2) {
    const n2 = e2.elements, i2 = t2.elements, r2 = this.elements, a2 = n2[0], o2 = n2[4], s2 = n2[8], l2 = n2[12], c2 = n2[1], h2 = n2[5], u2 = n2[9], d2 = n2[13], p2 = n2[2], f2 = n2[6], m2 = n2[10], g2 = n2[14], v2 = n2[3], x2 = n2[7], y2 = n2[11], _2 = n2[15], b2 = i2[0], w2 = i2[4], M2 = i2[8], S2 = i2[12], T2 = i2[1], E2 = i2[5], L2 = i2[9], R2 = i2[13], A2 = i2[2], P2 = i2[6], C2 = i2[10], D2 = i2[14], I2 = i2[3], N2 = i2[7], O2 = i2[11], U2 = i2[15];
    return r2[0] = a2 * b2 + o2 * T2 + s2 * A2 + l2 * I2, r2[4] = a2 * w2 + o2 * E2 + s2 * P2 + l2 * N2, r2[8] = a2 * M2 + o2 * L2 + s2 * C2 + l2 * O2, r2[12] = a2 * S2 + o2 * R2 + s2 * D2 + l2 * U2, r2[1] = c2 * b2 + h2 * T2 + u2 * A2 + d2 * I2, r2[5] = c2 * w2 + h2 * E2 + u2 * P2 + d2 * N2, r2[9] = c2 * M2 + h2 * L2 + u2 * C2 + d2 * O2, r2[13] = c2 * S2 + h2 * R2 + u2 * D2 + d2 * U2, r2[2] = p2 * b2 + f2 * T2 + m2 * A2 + g2 * I2, r2[6] = p2 * w2 + f2 * E2 + m2 * P2 + g2 * N2, r2[10] = p2 * M2 + f2 * L2 + m2 * C2 + g2 * O2, r2[14] = p2 * S2 + f2 * R2 + m2 * D2 + g2 * U2, r2[3] = v2 * b2 + x2 * T2 + y2 * A2 + _2 * I2, r2[7] = v2 * w2 + x2 * E2 + y2 * P2 + _2 * N2, r2[11] = v2 * M2 + x2 * L2 + y2 * C2 + _2 * O2, r2[15] = v2 * S2 + x2 * R2 + y2 * D2 + _2 * U2, this;
  }
  multiplyScalar(e2) {
    const t2 = this.elements;
    return t2[0] *= e2, t2[4] *= e2, t2[8] *= e2, t2[12] *= e2, t2[1] *= e2, t2[5] *= e2, t2[9] *= e2, t2[13] *= e2, t2[2] *= e2, t2[6] *= e2, t2[10] *= e2, t2[14] *= e2, t2[3] *= e2, t2[7] *= e2, t2[11] *= e2, t2[15] *= e2, this;
  }
  determinant() {
    const e2 = this.elements, t2 = e2[0], n2 = e2[4], i2 = e2[8], r2 = e2[12], a2 = e2[1], o2 = e2[5], s2 = e2[9], l2 = e2[13], c2 = e2[2], h2 = e2[6], u2 = e2[10], d2 = e2[14];
    return e2[3] * (+r2 * s2 * h2 - i2 * l2 * h2 - r2 * o2 * u2 + n2 * l2 * u2 + i2 * o2 * d2 - n2 * s2 * d2) + e2[7] * (+t2 * s2 * d2 - t2 * l2 * u2 + r2 * a2 * u2 - i2 * a2 * d2 + i2 * l2 * c2 - r2 * s2 * c2) + e2[11] * (+t2 * l2 * h2 - t2 * o2 * d2 - r2 * a2 * h2 + n2 * a2 * d2 + r2 * o2 * c2 - n2 * l2 * c2) + e2[15] * (-i2 * o2 * c2 - t2 * s2 * h2 + t2 * o2 * u2 + i2 * a2 * h2 - n2 * a2 * u2 + n2 * s2 * c2);
  }
  transpose() {
    const e2 = this.elements;
    let t2;
    return t2 = e2[1], e2[1] = e2[4], e2[4] = t2, t2 = e2[2], e2[2] = e2[8], e2[8] = t2, t2 = e2[6], e2[6] = e2[9], e2[9] = t2, t2 = e2[3], e2[3] = e2[12], e2[12] = t2, t2 = e2[7], e2[7] = e2[13], e2[13] = t2, t2 = e2[11], e2[11] = e2[14], e2[14] = t2, this;
  }
  setPosition(e2, t2, n2) {
    const i2 = this.elements;
    return e2.isVector3 ? (i2[12] = e2.x, i2[13] = e2.y, i2[14] = e2.z) : (i2[12] = e2, i2[13] = t2, i2[14] = n2), this;
  }
  invert() {
    const e2 = this.elements, t2 = e2[0], n2 = e2[1], i2 = e2[2], r2 = e2[3], a2 = e2[4], o2 = e2[5], s2 = e2[6], l2 = e2[7], c2 = e2[8], h2 = e2[9], u2 = e2[10], d2 = e2[11], p2 = e2[12], f2 = e2[13], m2 = e2[14], g2 = e2[15], v2 = h2 * m2 * l2 - f2 * u2 * l2 + f2 * s2 * d2 - o2 * m2 * d2 - h2 * s2 * g2 + o2 * u2 * g2, x2 = p2 * u2 * l2 - c2 * m2 * l2 - p2 * s2 * d2 + a2 * m2 * d2 + c2 * s2 * g2 - a2 * u2 * g2, y2 = c2 * f2 * l2 - p2 * h2 * l2 + p2 * o2 * d2 - a2 * f2 * d2 - c2 * o2 * g2 + a2 * h2 * g2, _2 = p2 * h2 * s2 - c2 * f2 * s2 - p2 * o2 * u2 + a2 * f2 * u2 + c2 * o2 * m2 - a2 * h2 * m2, b2 = t2 * v2 + n2 * x2 + i2 * y2 + r2 * _2;
    if (0 === b2) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w2 = 1 / b2;
    return e2[0] = v2 * w2, e2[1] = (f2 * u2 * r2 - h2 * m2 * r2 - f2 * i2 * d2 + n2 * m2 * d2 + h2 * i2 * g2 - n2 * u2 * g2) * w2, e2[2] = (o2 * m2 * r2 - f2 * s2 * r2 + f2 * i2 * l2 - n2 * m2 * l2 - o2 * i2 * g2 + n2 * s2 * g2) * w2, e2[3] = (h2 * s2 * r2 - o2 * u2 * r2 - h2 * i2 * l2 + n2 * u2 * l2 + o2 * i2 * d2 - n2 * s2 * d2) * w2, e2[4] = x2 * w2, e2[5] = (c2 * m2 * r2 - p2 * u2 * r2 + p2 * i2 * d2 - t2 * m2 * d2 - c2 * i2 * g2 + t2 * u2 * g2) * w2, e2[6] = (p2 * s2 * r2 - a2 * m2 * r2 - p2 * i2 * l2 + t2 * m2 * l2 + a2 * i2 * g2 - t2 * s2 * g2) * w2, e2[7] = (a2 * u2 * r2 - c2 * s2 * r2 + c2 * i2 * l2 - t2 * u2 * l2 - a2 * i2 * d2 + t2 * s2 * d2) * w2, e2[8] = y2 * w2, e2[9] = (p2 * h2 * r2 - c2 * f2 * r2 - p2 * n2 * d2 + t2 * f2 * d2 + c2 * n2 * g2 - t2 * h2 * g2) * w2, e2[10] = (a2 * f2 * r2 - p2 * o2 * r2 + p2 * n2 * l2 - t2 * f2 * l2 - a2 * n2 * g2 + t2 * o2 * g2) * w2, e2[11] = (c2 * o2 * r2 - a2 * h2 * r2 - c2 * n2 * l2 + t2 * h2 * l2 + a2 * n2 * d2 - t2 * o2 * d2) * w2, e2[12] = _2 * w2, e2[13] = (c2 * f2 * i2 - p2 * h2 * i2 + p2 * n2 * u2 - t2 * f2 * u2 - c2 * n2 * m2 + t2 * h2 * m2) * w2, e2[14] = (p2 * o2 * i2 - a2 * f2 * i2 - p2 * n2 * s2 + t2 * f2 * s2 + a2 * n2 * m2 - t2 * o2 * m2) * w2, e2[15] = (a2 * h2 * i2 - c2 * o2 * i2 + c2 * n2 * s2 - t2 * h2 * s2 - a2 * n2 * u2 + t2 * o2 * u2) * w2, this;
  }
  scale(e2) {
    const t2 = this.elements, n2 = e2.x, i2 = e2.y, r2 = e2.z;
    return t2[0] *= n2, t2[4] *= i2, t2[8] *= r2, t2[1] *= n2, t2[5] *= i2, t2[9] *= r2, t2[2] *= n2, t2[6] *= i2, t2[10] *= r2, t2[3] *= n2, t2[7] *= i2, t2[11] *= r2, this;
  }
  getMaxScaleOnAxis() {
    const e2 = this.elements, t2 = e2[0] * e2[0] + e2[1] * e2[1] + e2[2] * e2[2], n2 = e2[4] * e2[4] + e2[5] * e2[5] + e2[6] * e2[6], i2 = e2[8] * e2[8] + e2[9] * e2[9] + e2[10] * e2[10];
    return Math.sqrt(Math.max(t2, n2, i2));
  }
  makeTranslation(e2, t2, n2) {
    return this.set(1, 0, 0, e2, 0, 1, 0, t2, 0, 0, 1, n2, 0, 0, 0, 1), this;
  }
  makeRotationX(e2) {
    const t2 = Math.cos(e2), n2 = Math.sin(e2);
    return this.set(1, 0, 0, 0, 0, t2, -n2, 0, 0, n2, t2, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e2) {
    const t2 = Math.cos(e2), n2 = Math.sin(e2);
    return this.set(t2, 0, n2, 0, 0, 1, 0, 0, -n2, 0, t2, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e2) {
    const t2 = Math.cos(e2), n2 = Math.sin(e2);
    return this.set(t2, -n2, 0, 0, n2, t2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e2, t2) {
    const n2 = Math.cos(t2), i2 = Math.sin(t2), r2 = 1 - n2, a2 = e2.x, o2 = e2.y, s2 = e2.z, l2 = r2 * a2, c2 = r2 * o2;
    return this.set(l2 * a2 + n2, l2 * o2 - i2 * s2, l2 * s2 + i2 * o2, 0, l2 * o2 + i2 * s2, c2 * o2 + n2, c2 * s2 - i2 * a2, 0, l2 * s2 - i2 * o2, c2 * s2 + i2 * a2, r2 * s2 * s2 + n2, 0, 0, 0, 0, 1), this;
  }
  makeScale(e2, t2, n2) {
    return this.set(e2, 0, 0, 0, 0, t2, 0, 0, 0, 0, n2, 0, 0, 0, 0, 1), this;
  }
  makeShear(e2, t2, n2) {
    return this.set(1, t2, n2, 0, e2, 1, n2, 0, e2, t2, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e2, t2, n2) {
    const i2 = this.elements, r2 = t2._x, a2 = t2._y, o2 = t2._z, s2 = t2._w, l2 = r2 + r2, c2 = a2 + a2, h2 = o2 + o2, u2 = r2 * l2, d2 = r2 * c2, p2 = r2 * h2, f2 = a2 * c2, m2 = a2 * h2, g2 = o2 * h2, v2 = s2 * l2, x2 = s2 * c2, y2 = s2 * h2, _2 = n2.x, b2 = n2.y, w2 = n2.z;
    return i2[0] = (1 - (f2 + g2)) * _2, i2[1] = (d2 + y2) * _2, i2[2] = (p2 - x2) * _2, i2[3] = 0, i2[4] = (d2 - y2) * b2, i2[5] = (1 - (u2 + g2)) * b2, i2[6] = (m2 + v2) * b2, i2[7] = 0, i2[8] = (p2 + x2) * w2, i2[9] = (m2 - v2) * w2, i2[10] = (1 - (u2 + f2)) * w2, i2[11] = 0, i2[12] = e2.x, i2[13] = e2.y, i2[14] = e2.z, i2[15] = 1, this;
  }
  decompose(e2, t2, n2) {
    const i2 = this.elements;
    let r2 = q.set(i2[0], i2[1], i2[2]).length();
    const a2 = q.set(i2[4], i2[5], i2[6]).length(), o2 = q.set(i2[8], i2[9], i2[10]).length();
    this.determinant() < 0 && (r2 = -r2), e2.x = i2[12], e2.y = i2[13], e2.z = i2[14], X.copy(this);
    const s2 = 1 / r2, l2 = 1 / a2, c2 = 1 / o2;
    return X.elements[0] *= s2, X.elements[1] *= s2, X.elements[2] *= s2, X.elements[4] *= l2, X.elements[5] *= l2, X.elements[6] *= l2, X.elements[8] *= c2, X.elements[9] *= c2, X.elements[10] *= c2, t2.setFromRotationMatrix(X), n2.x = r2, n2.y = a2, n2.z = o2, this;
  }
  makePerspective(e2, t2, n2, i2, r2, a2) {
    void 0 === a2 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
    const o2 = this.elements, s2 = 2 * r2 / (t2 - e2), l2 = 2 * r2 / (n2 - i2), c2 = (t2 + e2) / (t2 - e2), h2 = (n2 + i2) / (n2 - i2), u2 = -(a2 + r2) / (a2 - r2), d2 = -2 * a2 * r2 / (a2 - r2);
    return o2[0] = s2, o2[4] = 0, o2[8] = c2, o2[12] = 0, o2[1] = 0, o2[5] = l2, o2[9] = h2, o2[13] = 0, o2[2] = 0, o2[6] = 0, o2[10] = u2, o2[14] = d2, o2[3] = 0, o2[7] = 0, o2[11] = -1, o2[15] = 0, this;
  }
  makeOrthographic(e2, t2, n2, i2, r2, a2) {
    const o2 = this.elements, s2 = 1 / (t2 - e2), l2 = 1 / (n2 - i2), c2 = 1 / (a2 - r2), h2 = (t2 + e2) * s2, u2 = (n2 + i2) * l2, d2 = (a2 + r2) * c2;
    return o2[0] = 2 * s2, o2[4] = 0, o2[8] = 0, o2[12] = -h2, o2[1] = 0, o2[5] = 2 * l2, o2[9] = 0, o2[13] = -u2, o2[2] = 0, o2[6] = 0, o2[10] = -2 * c2, o2[14] = -d2, o2[3] = 0, o2[7] = 0, o2[11] = 0, o2[15] = 1, this;
  }
  equals(e2) {
    const t2 = this.elements, n2 = e2.elements;
    for (let i2 = 0; i2 < 16; i2++) if (t2[i2] !== n2[i2]) return false;
    return true;
  }
  fromArray(e2, t2 = 0) {
    for (let n2 = 0; n2 < 16; n2++) this.elements[n2] = e2[n2 + t2];
    return this;
  }
  toArray(e2 = [], t2 = 0) {
    const n2 = this.elements;
    return e2[t2] = n2[0], e2[t2 + 1] = n2[1], e2[t2 + 2] = n2[2], e2[t2 + 3] = n2[3], e2[t2 + 4] = n2[4], e2[t2 + 5] = n2[5], e2[t2 + 6] = n2[6], e2[t2 + 7] = n2[7], e2[t2 + 8] = n2[8], e2[t2 + 9] = n2[9], e2[t2 + 10] = n2[10], e2[t2 + 11] = n2[11], e2[t2 + 12] = n2[12], e2[t2 + 13] = n2[13], e2[t2 + 14] = n2[14], e2[t2 + 15] = n2[15], e2;
  }
};
j.prototype.isMatrix4 = true;
var q = new f();
var X = new j();
var Y = new f(0, 0, 0);
var Z = new f(1, 1, 1);
var J = new f();
var K = new f();
var Q = new f();
var $ = new j();
var ee = new p();
var te = class _te {
  constructor(e2 = 0, t2 = 0, n2 = 0, i2 = _te.DefaultOrder) {
    this._x = e2, this._y = t2, this._z = n2, this._order = i2;
  }
  get x() {
    return this._x;
  }
  set x(e2) {
    this._x = e2, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e2) {
    this._y = e2, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e2) {
    this._z = e2, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e2) {
    this._order = e2, this._onChangeCallback();
  }
  set(e2, t2, n2, i2) {
    return this._x = e2, this._y = t2, this._z = n2, this._order = i2 || this._order, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e2) {
    return this._x = e2._x, this._y = e2._y, this._z = e2._z, this._order = e2._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e2, t2, n2) {
    const r2 = i.clamp, a2 = e2.elements, o2 = a2[0], s2 = a2[4], l2 = a2[8], c2 = a2[1], h2 = a2[5], u2 = a2[9], d2 = a2[2], p2 = a2[6], f2 = a2[10];
    switch (t2 = t2 || this._order) {
      case "XYZ":
        this._y = Math.asin(r2(l2, -1, 1)), Math.abs(l2) < 0.9999999 ? (this._x = Math.atan2(-u2, f2), this._z = Math.atan2(-s2, o2)) : (this._x = Math.atan2(p2, h2), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-r2(u2, -1, 1)), Math.abs(u2) < 0.9999999 ? (this._y = Math.atan2(l2, f2), this._z = Math.atan2(c2, h2)) : (this._y = Math.atan2(-d2, o2), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(r2(p2, -1, 1)), Math.abs(p2) < 0.9999999 ? (this._y = Math.atan2(-d2, f2), this._z = Math.atan2(-s2, h2)) : (this._y = 0, this._z = Math.atan2(c2, o2));
        break;
      case "ZYX":
        this._y = Math.asin(-r2(d2, -1, 1)), Math.abs(d2) < 0.9999999 ? (this._x = Math.atan2(p2, f2), this._z = Math.atan2(c2, o2)) : (this._x = 0, this._z = Math.atan2(-s2, h2));
        break;
      case "YZX":
        this._z = Math.asin(r2(c2, -1, 1)), Math.abs(c2) < 0.9999999 ? (this._x = Math.atan2(-u2, h2), this._y = Math.atan2(-d2, o2)) : (this._x = 0, this._y = Math.atan2(l2, f2));
        break;
      case "XZY":
        this._z = Math.asin(-r2(s2, -1, 1)), Math.abs(s2) < 0.9999999 ? (this._x = Math.atan2(p2, h2), this._y = Math.atan2(l2, o2)) : (this._x = Math.atan2(-u2, f2), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t2);
    }
    return this._order = t2, false !== n2 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e2, t2, n2) {
    return $.makeRotationFromQuaternion(e2), this.setFromRotationMatrix($, t2, n2);
  }
  setFromVector3(e2, t2) {
    return this.set(e2.x, e2.y, e2.z, t2 || this._order);
  }
  reorder(e2) {
    return ee.setFromEuler(this), this.setFromQuaternion(ee, e2);
  }
  equals(e2) {
    return e2._x === this._x && e2._y === this._y && e2._z === this._z && e2._order === this._order;
  }
  fromArray(e2) {
    return this._x = e2[0], this._y = e2[1], this._z = e2[2], void 0 !== e2[3] && (this._order = e2[3]), this._onChangeCallback(), this;
  }
  toArray(e2 = [], t2 = 0) {
    return e2[t2] = this._x, e2[t2 + 1] = this._y, e2[t2 + 2] = this._z, e2[t2 + 3] = this._order, e2;
  }
  toVector3(e2) {
    return e2 ? e2.set(this._x, this._y, this._z) : new f(this._x, this._y, this._z);
  }
  _onChange(e2) {
    return this._onChangeCallback = e2, this;
  }
  _onChangeCallback() {
  }
};
te.prototype.isEuler = true, te.DefaultOrder = "XYZ", te.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
var ne = class {
  constructor() {
    this.mask = 1;
  }
  set(e2) {
    this.mask = 1 << e2 | 0;
  }
  enable(e2) {
    this.mask |= 1 << e2 | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e2) {
    this.mask ^= 1 << e2 | 0;
  }
  disable(e2) {
    this.mask &= ~(1 << e2 | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e2) {
    return 0 != (this.mask & e2.mask);
  }
};
var ie = 0;
var re = new f();
var ae = new p();
var oe = new j();
var se = new f();
var le = new f();
var ce = new f();
var he = new p();
var ue = new f(1, 0, 0);
var de = new f(0, 1, 0);
var pe = new f(0, 0, 1);
var fe = { type: "added" };
var me = { type: "removed" };
function ge() {
  Object.defineProperty(this, "id", { value: ie++ }), this.uuid = i.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ge.DefaultUp.clone();
  const e2 = new f(), t2 = new te(), n2 = new p(), r2 = new f(1, 1, 1);
  t2._onChange(function() {
    n2.setFromEuler(t2, false);
  }), n2._onChange(function() {
    t2.setFromQuaternion(n2, void 0, false);
  }), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e2 }, rotation: { configurable: true, enumerable: true, value: t2 }, quaternion: { configurable: true, enumerable: true, value: n2 }, scale: { configurable: true, enumerable: true, value: r2 }, modelViewMatrix: { value: new j() }, normalMatrix: { value: new a() } }), this.matrix = new j(), this.matrixWorld = new j(), this.matrixAutoUpdate = ge.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new ne(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
}
ge.DefaultUp = new f(0, 1, 0), ge.DefaultMatrixAutoUpdate = true, ge.prototype = Object.assign(Object.create(e.prototype), { constructor: ge, isObject3D: true, onBeforeRender: function() {
}, onAfterRender: function() {
}, applyMatrix4: function(e2) {
  this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e2), this.matrix.decompose(this.position, this.quaternion, this.scale);
}, applyQuaternion: function(e2) {
  return this.quaternion.premultiply(e2), this;
}, setRotationFromAxisAngle: function(e2, t2) {
  this.quaternion.setFromAxisAngle(e2, t2);
}, setRotationFromEuler: function(e2) {
  this.quaternion.setFromEuler(e2, true);
}, setRotationFromMatrix: function(e2) {
  this.quaternion.setFromRotationMatrix(e2);
}, setRotationFromQuaternion: function(e2) {
  this.quaternion.copy(e2);
}, rotateOnAxis: function(e2, t2) {
  return ae.setFromAxisAngle(e2, t2), this.quaternion.multiply(ae), this;
}, rotateOnWorldAxis: function(e2, t2) {
  return ae.setFromAxisAngle(e2, t2), this.quaternion.premultiply(ae), this;
}, rotateX: function(e2) {
  return this.rotateOnAxis(ue, e2);
}, rotateY: function(e2) {
  return this.rotateOnAxis(de, e2);
}, rotateZ: function(e2) {
  return this.rotateOnAxis(pe, e2);
}, translateOnAxis: function(e2, t2) {
  return re.copy(e2).applyQuaternion(this.quaternion), this.position.add(re.multiplyScalar(t2)), this;
}, translateX: function(e2) {
  return this.translateOnAxis(ue, e2);
}, translateY: function(e2) {
  return this.translateOnAxis(de, e2);
}, translateZ: function(e2) {
  return this.translateOnAxis(pe, e2);
}, localToWorld: function(e2) {
  return e2.applyMatrix4(this.matrixWorld);
}, worldToLocal: function(e2) {
  return e2.applyMatrix4(oe.copy(this.matrixWorld).invert());
}, lookAt: function(e2, t2, n2) {
  e2.isVector3 ? se.copy(e2) : se.set(e2, t2, n2);
  const i2 = this.parent;
  this.updateWorldMatrix(true, false), le.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? oe.lookAt(le, se, this.up) : oe.lookAt(se, le, this.up), this.quaternion.setFromRotationMatrix(oe), i2 && (oe.extractRotation(i2.matrixWorld), ae.setFromRotationMatrix(oe), this.quaternion.premultiply(ae.invert()));
}, add: function(e2) {
  if (arguments.length > 1) {
    for (let e3 = 0; e3 < arguments.length; e3++) this.add(arguments[e3]);
    return this;
  }
  return e2 === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e2), this) : (e2 && e2.isObject3D ? (null !== e2.parent && e2.parent.remove(e2), e2.parent = this, this.children.push(e2), e2.dispatchEvent(fe)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e2), this);
}, remove: function(e2) {
  if (arguments.length > 1) {
    for (let e3 = 0; e3 < arguments.length; e3++) this.remove(arguments[e3]);
    return this;
  }
  const t2 = this.children.indexOf(e2);
  return -1 !== t2 && (e2.parent = null, this.children.splice(t2, 1), e2.dispatchEvent(me)), this;
}, clear: function() {
  for (let e2 = 0; e2 < this.children.length; e2++) {
    const t2 = this.children[e2];
    t2.parent = null, t2.dispatchEvent(me);
  }
  return this.children.length = 0, this;
}, attach: function(e2) {
  return this.updateWorldMatrix(true, false), oe.copy(this.matrixWorld).invert(), null !== e2.parent && (e2.parent.updateWorldMatrix(true, false), oe.multiply(e2.parent.matrixWorld)), e2.applyMatrix4(oe), this.add(e2), e2.updateWorldMatrix(false, true), this;
}, getObjectById: function(e2) {
  return this.getObjectByProperty("id", e2);
}, getObjectByName: function(e2) {
  return this.getObjectByProperty("name", e2);
}, getObjectByProperty: function(e2, t2) {
  if (this[e2] === t2) return this;
  for (let n2 = 0, i2 = this.children.length; n2 < i2; n2++) {
    const i3 = this.children[n2].getObjectByProperty(e2, t2);
    if (void 0 !== i3) return i3;
  }
}, getWorldPosition: function(e2) {
  return void 0 === e2 && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e2 = new f()), this.updateWorldMatrix(true, false), e2.setFromMatrixPosition(this.matrixWorld);
}, getWorldQuaternion: function(e2) {
  return void 0 === e2 && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e2 = new p()), this.updateWorldMatrix(true, false), this.matrixWorld.decompose(le, e2, ce), e2;
}, getWorldScale: function(e2) {
  return void 0 === e2 && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e2 = new f()), this.updateWorldMatrix(true, false), this.matrixWorld.decompose(le, he, e2), e2;
}, getWorldDirection: function(e2) {
  void 0 === e2 && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e2 = new f()), this.updateWorldMatrix(true, false);
  const t2 = this.matrixWorld.elements;
  return e2.set(t2[8], t2[9], t2[10]).normalize();
}, raycast: function() {
}, traverse: function(e2) {
  e2(this);
  const t2 = this.children;
  for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) t2[n2].traverse(e2);
}, traverseVisible: function(e2) {
  if (false === this.visible) return;
  e2(this);
  const t2 = this.children;
  for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) t2[n2].traverseVisible(e2);
}, traverseAncestors: function(e2) {
  const t2 = this.parent;
  null !== t2 && (e2(t2), t2.traverseAncestors(e2));
}, updateMatrix: function() {
  this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
}, updateMatrixWorld: function(e2) {
  this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e2) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e2 = true);
  const t2 = this.children;
  for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) t2[n2].updateMatrixWorld(e2);
}, updateWorldMatrix: function(e2, t2) {
  const n2 = this.parent;
  if (true === e2 && null !== n2 && n2.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), true === t2) {
    const e3 = this.children;
    for (let t3 = 0, n3 = e3.length; t3 < n3; t3++) e3[t3].updateWorldMatrix(false, true);
  }
}, toJSON: function(e2) {
  const t2 = void 0 === e2 || "string" == typeof e2, n2 = {};
  t2 && (e2 = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n2.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
  const i2 = {};
  function r2(t3, n3) {
    return void 0 === t3[n3.uuid] && (t3[n3.uuid] = n3.toJSON(e2)), n3.uuid;
  }
  if (i2.uuid = this.uuid, i2.type = this.type, "" !== this.name && (i2.name = this.name), true === this.castShadow && (i2.castShadow = true), true === this.receiveShadow && (i2.receiveShadow = true), false === this.visible && (i2.visible = false), false === this.frustumCulled && (i2.frustumCulled = false), 0 !== this.renderOrder && (i2.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i2.userData = this.userData), i2.layers = this.layers.mask, i2.matrix = this.matrix.toArray(), false === this.matrixAutoUpdate && (i2.matrixAutoUpdate = false), this.isInstancedMesh && (i2.type = "InstancedMesh", i2.count = this.count, i2.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i2.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) {
    i2.geometry = r2(e2.geometries, this.geometry);
    const t3 = this.geometry.parameters;
    if (void 0 !== t3 && void 0 !== t3.shapes) {
      const n3 = t3.shapes;
      if (Array.isArray(n3)) for (let t4 = 0, i3 = n3.length; t4 < i3; t4++) {
        const i4 = n3[t4];
        r2(e2.shapes, i4);
      }
      else r2(e2.shapes, n3);
    }
  }
  if (this.isSkinnedMesh && (i2.bindMode = this.bindMode, i2.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r2(e2.skeletons, this.skeleton), i2.skeleton = this.skeleton.uuid)), void 0 !== this.material) if (Array.isArray(this.material)) {
    const t3 = [];
    for (let n3 = 0, i3 = this.material.length; n3 < i3; n3++) t3.push(r2(e2.materials, this.material[n3]));
    i2.material = t3;
  } else i2.material = r2(e2.materials, this.material);
  if (this.children.length > 0) {
    i2.children = [];
    for (let t3 = 0; t3 < this.children.length; t3++) i2.children.push(this.children[t3].toJSON(e2).object);
  }
  if (this.animations.length > 0) {
    i2.animations = [];
    for (let t3 = 0; t3 < this.animations.length; t3++) {
      const n3 = this.animations[t3];
      i2.animations.push(r2(e2.animations, n3));
    }
  }
  if (t2) {
    const t3 = a2(e2.geometries), i3 = a2(e2.materials), r3 = a2(e2.textures), o2 = a2(e2.images), s2 = a2(e2.shapes), l2 = a2(e2.skeletons), c2 = a2(e2.animations);
    t3.length > 0 && (n2.geometries = t3), i3.length > 0 && (n2.materials = i3), r3.length > 0 && (n2.textures = r3), o2.length > 0 && (n2.images = o2), s2.length > 0 && (n2.shapes = s2), l2.length > 0 && (n2.skeletons = l2), c2.length > 0 && (n2.animations = c2);
  }
  return n2.object = i2, n2;
  function a2(e3) {
    const t3 = [];
    for (const n3 in e3) {
      const i3 = e3[n3];
      delete i3.metadata, t3.push(i3);
    }
    return t3;
  }
}, clone: function(e2) {
  return new this.constructor().copy(this, e2);
}, copy: function(e2, t2 = true) {
  if (this.name = e2.name, this.up.copy(e2.up), this.position.copy(e2.position), this.rotation.order = e2.rotation.order, this.quaternion.copy(e2.quaternion), this.scale.copy(e2.scale), this.matrix.copy(e2.matrix), this.matrixWorld.copy(e2.matrixWorld), this.matrixAutoUpdate = e2.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e2.matrixWorldNeedsUpdate, this.layers.mask = e2.layers.mask, this.visible = e2.visible, this.castShadow = e2.castShadow, this.receiveShadow = e2.receiveShadow, this.frustumCulled = e2.frustumCulled, this.renderOrder = e2.renderOrder, this.userData = JSON.parse(JSON.stringify(e2.userData)), true === t2) for (let n2 = 0; n2 < e2.children.length; n2++) {
    const t3 = e2.children[n2];
    this.add(t3.clone());
  }
  return this;
} });
var ve = new f();
var xe = new f();
var ye = new a();
var _e = class {
  constructor(e2 = new f(1, 0, 0), t2 = 0) {
    this.normal = e2, this.constant = t2;
  }
  set(e2, t2) {
    return this.normal.copy(e2), this.constant = t2, this;
  }
  setComponents(e2, t2, n2, i2) {
    return this.normal.set(e2, t2, n2), this.constant = i2, this;
  }
  setFromNormalAndCoplanarPoint(e2, t2) {
    return this.normal.copy(e2), this.constant = -t2.dot(this.normal), this;
  }
  setFromCoplanarPoints(e2, t2, n2) {
    const i2 = ve.subVectors(n2, t2).cross(xe.subVectors(e2, t2)).normalize();
    return this.setFromNormalAndCoplanarPoint(i2, e2), this;
  }
  copy(e2) {
    return this.normal.copy(e2.normal), this.constant = e2.constant, this;
  }
  normalize() {
    const e2 = 1 / this.normal.length();
    return this.normal.multiplyScalar(e2), this.constant *= e2, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e2) {
    return this.normal.dot(e2) + this.constant;
  }
  distanceToSphere(e2) {
    return this.distanceToPoint(e2.center) - e2.radius;
  }
  projectPoint(e2, t2) {
    return void 0 === t2 && (console.warn("THREE.Plane: .projectPoint() target is now required"), t2 = new f()), t2.copy(this.normal).multiplyScalar(-this.distanceToPoint(e2)).add(e2);
  }
  intersectLine(e2, t2) {
    void 0 === t2 && (console.warn("THREE.Plane: .intersectLine() target is now required"), t2 = new f());
    const n2 = e2.delta(ve), i2 = this.normal.dot(n2);
    if (0 === i2) return 0 === this.distanceToPoint(e2.start) ? t2.copy(e2.start) : null;
    const r2 = -(e2.start.dot(this.normal) + this.constant) / i2;
    return r2 < 0 || r2 > 1 ? null : t2.copy(n2).multiplyScalar(r2).add(e2.start);
  }
  intersectsLine(e2) {
    const t2 = this.distanceToPoint(e2.start), n2 = this.distanceToPoint(e2.end);
    return t2 < 0 && n2 > 0 || n2 < 0 && t2 > 0;
  }
  intersectsBox(e2) {
    return e2.intersectsPlane(this);
  }
  intersectsSphere(e2) {
    return e2.intersectsPlane(this);
  }
  coplanarPoint(e2) {
    return void 0 === e2 && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e2 = new f()), e2.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e2, t2) {
    const n2 = t2 || ye.getNormalMatrix(e2), i2 = this.coplanarPoint(ve).applyMatrix4(e2), r2 = this.normal.applyMatrix3(n2).normalize();
    return this.constant = -i2.dot(r2), this;
  }
  translate(e2) {
    return this.constant -= e2.dot(this.normal), this;
  }
  equals(e2) {
    return e2.normal.equals(this.normal) && e2.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
_e.prototype.isPlane = true;
var be = new f();
var we = new f();
var Me = new f();
var Se = new f();
var Te = new f();
var Ee = new f();
var Le = new f();
var Re = new f();
var Ae = new f();
var Pe = new f();
var Ce = class _Ce {
  constructor(e2 = new f(), t2 = new f(), n2 = new f()) {
    this.a = e2, this.b = t2, this.c = n2;
  }
  static getNormal(e2, t2, n2, i2) {
    void 0 === i2 && (console.warn("THREE.Triangle: .getNormal() target is now required"), i2 = new f()), i2.subVectors(n2, t2), be.subVectors(e2, t2), i2.cross(be);
    const r2 = i2.lengthSq();
    return r2 > 0 ? i2.multiplyScalar(1 / Math.sqrt(r2)) : i2.set(0, 0, 0);
  }
  static getBarycoord(e2, t2, n2, i2, r2) {
    be.subVectors(i2, t2), we.subVectors(n2, t2), Me.subVectors(e2, t2);
    const a2 = be.dot(be), o2 = be.dot(we), s2 = be.dot(Me), l2 = we.dot(we), c2 = we.dot(Me), h2 = a2 * l2 - o2 * o2;
    if (void 0 === r2 && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r2 = new f()), 0 === h2) return r2.set(-2, -1, -1);
    const u2 = 1 / h2, d2 = (l2 * s2 - o2 * c2) * u2, p2 = (a2 * c2 - o2 * s2) * u2;
    return r2.set(1 - d2 - p2, p2, d2);
  }
  static containsPoint(e2, t2, n2, i2) {
    return this.getBarycoord(e2, t2, n2, i2, Se), Se.x >= 0 && Se.y >= 0 && Se.x + Se.y <= 1;
  }
  static getUV(e2, t2, n2, i2, r2, a2, o2, s2) {
    return this.getBarycoord(e2, t2, n2, i2, Se), s2.set(0, 0), s2.addScaledVector(r2, Se.x), s2.addScaledVector(a2, Se.y), s2.addScaledVector(o2, Se.z), s2;
  }
  static isFrontFacing(e2, t2, n2, i2) {
    return be.subVectors(n2, t2), we.subVectors(e2, t2), be.cross(we).dot(i2) < 0;
  }
  set(e2, t2, n2) {
    return this.a.copy(e2), this.b.copy(t2), this.c.copy(n2), this;
  }
  setFromPointsAndIndices(e2, t2, n2, i2) {
    return this.a.copy(e2[t2]), this.b.copy(e2[n2]), this.c.copy(e2[i2]), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e2) {
    return this.a.copy(e2.a), this.b.copy(e2.b), this.c.copy(e2.c), this;
  }
  getArea() {
    return be.subVectors(this.c, this.b), we.subVectors(this.a, this.b), 0.5 * be.cross(we).length();
  }
  getMidpoint(e2) {
    return void 0 === e2 && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e2 = new f()), e2.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e2) {
    return _Ce.getNormal(this.a, this.b, this.c, e2);
  }
  getPlane(e2) {
    return void 0 === e2 && (console.warn("THREE.Triangle: .getPlane() target is now required"), e2 = new _e()), e2.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e2, t2) {
    return _Ce.getBarycoord(e2, this.a, this.b, this.c, t2);
  }
  getUV(e2, t2, n2, i2, r2) {
    return _Ce.getUV(e2, this.a, this.b, this.c, t2, n2, i2, r2);
  }
  containsPoint(e2) {
    return _Ce.containsPoint(e2, this.a, this.b, this.c);
  }
  isFrontFacing(e2) {
    return _Ce.isFrontFacing(this.a, this.b, this.c, e2);
  }
  intersectsBox(e2) {
    return e2.intersectsTriangle(this);
  }
  closestPointToPoint(e2, t2) {
    void 0 === t2 && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t2 = new f());
    const n2 = this.a, i2 = this.b, r2 = this.c;
    let a2, o2;
    Te.subVectors(i2, n2), Ee.subVectors(r2, n2), Re.subVectors(e2, n2);
    const s2 = Te.dot(Re), l2 = Ee.dot(Re);
    if (s2 <= 0 && l2 <= 0) return t2.copy(n2);
    Ae.subVectors(e2, i2);
    const c2 = Te.dot(Ae), h2 = Ee.dot(Ae);
    if (c2 >= 0 && h2 <= c2) return t2.copy(i2);
    const u2 = s2 * h2 - c2 * l2;
    if (u2 <= 0 && s2 >= 0 && c2 <= 0) return a2 = s2 / (s2 - c2), t2.copy(n2).addScaledVector(Te, a2);
    Pe.subVectors(e2, r2);
    const d2 = Te.dot(Pe), p2 = Ee.dot(Pe);
    if (p2 >= 0 && d2 <= p2) return t2.copy(r2);
    const m2 = d2 * l2 - s2 * p2;
    if (m2 <= 0 && l2 >= 0 && p2 <= 0) return o2 = l2 / (l2 - p2), t2.copy(n2).addScaledVector(Ee, o2);
    const g2 = c2 * p2 - d2 * h2;
    if (g2 <= 0 && h2 - c2 >= 0 && d2 - p2 >= 0) return Le.subVectors(r2, i2), o2 = (h2 - c2) / (h2 - c2 + (d2 - p2)), t2.copy(i2).addScaledVector(Le, o2);
    const v2 = 1 / (g2 + m2 + u2);
    return a2 = m2 * v2, o2 = u2 * v2, t2.copy(n2).addScaledVector(Te, a2).addScaledVector(Ee, o2);
  }
  equals(e2) {
    return e2.a.equals(this.a) && e2.b.equals(this.b) && e2.c.equals(this.c);
  }
};
var De = 0;
function Ie() {
  Object.defineProperty(this, "id", { value: De++ }), this.uuid = i.generateUUID(), this.name = "", this.type = "Material", this.fog = true, this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaTest = 0, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0;
}
Ie.prototype = Object.assign(Object.create(e.prototype), { constructor: Ie, isMaterial: true, onBeforeCompile: function() {
}, customProgramCacheKey: function() {
  return this.onBeforeCompile.toString();
}, setValues: function(e2) {
  if (void 0 !== e2) for (const t2 in e2) {
    const n2 = e2[t2];
    if (void 0 === n2) {
      console.warn("THREE.Material: '" + t2 + "' parameter is undefined.");
      continue;
    }
    if ("shading" === t2) {
      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n2;
      continue;
    }
    const i2 = this[t2];
    void 0 !== i2 ? i2 && i2.isColor ? i2.set(n2) : i2 && i2.isVector3 && n2 && n2.isVector3 ? i2.copy(n2) : this[t2] = n2 : console.warn("THREE." + this.type + ": '" + t2 + "' is not a property of this material.");
  }
}, toJSON: function(e2) {
  const t2 = void 0 === e2 || "string" == typeof e2;
  t2 && (e2 = { textures: {}, images: {} });
  const n2 = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
  function i2(e3) {
    const t3 = [];
    for (const n3 in e3) {
      const i3 = e3[n3];
      delete i3.metadata, t3.push(i3);
    }
    return t3;
  }
  if (n2.uuid = this.uuid, n2.type = this.type, "" !== this.name && (n2.name = this.name), this.color && this.color.isColor && (n2.color = this.color.getHex()), void 0 !== this.roughness && (n2.roughness = this.roughness), void 0 !== this.metalness && (n2.metalness = this.metalness), this.sheen && this.sheen.isColor && (n2.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n2.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n2.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n2.specular = this.specular.getHex()), void 0 !== this.shininess && (n2.shininess = this.shininess), void 0 !== this.clearcoat && (n2.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n2.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n2.clearcoatMap = this.clearcoatMap.toJSON(e2).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e2).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e2).uuid, n2.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n2.map = this.map.toJSON(e2).uuid), this.matcap && this.matcap.isTexture && (n2.matcap = this.matcap.toJSON(e2).uuid), this.alphaMap && this.alphaMap.isTexture && (n2.alphaMap = this.alphaMap.toJSON(e2).uuid), this.lightMap && this.lightMap.isTexture && (n2.lightMap = this.lightMap.toJSON(e2).uuid, n2.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n2.aoMap = this.aoMap.toJSON(e2).uuid, n2.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n2.bumpMap = this.bumpMap.toJSON(e2).uuid, n2.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n2.normalMap = this.normalMap.toJSON(e2).uuid, n2.normalMapType = this.normalMapType, n2.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n2.displacementMap = this.displacementMap.toJSON(e2).uuid, n2.displacementScale = this.displacementScale, n2.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n2.roughnessMap = this.roughnessMap.toJSON(e2).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n2.metalnessMap = this.metalnessMap.toJSON(e2).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n2.emissiveMap = this.emissiveMap.toJSON(e2).uuid), this.specularMap && this.specularMap.isTexture && (n2.specularMap = this.specularMap.toJSON(e2).uuid), this.envMap && this.envMap.isTexture && (n2.envMap = this.envMap.toJSON(e2).uuid, n2.reflectivity = this.reflectivity, n2.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n2.combine = this.combine), void 0 !== this.envMapIntensity && (n2.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n2.gradientMap = this.gradientMap.toJSON(e2).uuid), void 0 !== this.size && (n2.size = this.size), null !== this.shadowSide && (n2.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n2.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n2.blending = this.blending), 0 !== this.side && (n2.side = this.side), this.vertexColors && (n2.vertexColors = true), this.opacity < 1 && (n2.opacity = this.opacity), true === this.transparent && (n2.transparent = this.transparent), n2.depthFunc = this.depthFunc, n2.depthTest = this.depthTest, n2.depthWrite = this.depthWrite, n2.colorWrite = this.colorWrite, n2.stencilWrite = this.stencilWrite, n2.stencilWriteMask = this.stencilWriteMask, n2.stencilFunc = this.stencilFunc, n2.stencilRef = this.stencilRef, n2.stencilFuncMask = this.stencilFuncMask, n2.stencilFail = this.stencilFail, n2.stencilZFail = this.stencilZFail, n2.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n2.rotation = this.rotation), true === this.polygonOffset && (n2.polygonOffset = true), 0 !== this.polygonOffsetFactor && (n2.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n2.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n2.linewidth = this.linewidth), void 0 !== this.dashSize && (n2.dashSize = this.dashSize), void 0 !== this.gapSize && (n2.gapSize = this.gapSize), void 0 !== this.scale && (n2.scale = this.scale), true === this.dithering && (n2.dithering = true), this.alphaTest > 0 && (n2.alphaTest = this.alphaTest), true === this.alphaToCoverage && (n2.alphaToCoverage = this.alphaToCoverage), true === this.premultipliedAlpha && (n2.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (n2.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n2.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n2.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n2.wireframeLinejoin = this.wireframeLinejoin), true === this.morphTargets && (n2.morphTargets = true), true === this.morphNormals && (n2.morphNormals = true), true === this.skinning && (n2.skinning = true), true === this.flatShading && (n2.flatShading = this.flatShading), false === this.visible && (n2.visible = false), false === this.toneMapped && (n2.toneMapped = false), "{}" !== JSON.stringify(this.userData) && (n2.userData = this.userData), t2) {
    const t3 = i2(e2.textures), r2 = i2(e2.images);
    t3.length > 0 && (n2.textures = t3), r2.length > 0 && (n2.images = r2);
  }
  return n2;
}, clone: function() {
  return new this.constructor().copy(this);
}, copy: function(e2) {
  this.name = e2.name, this.fog = e2.fog, this.blending = e2.blending, this.side = e2.side, this.vertexColors = e2.vertexColors, this.opacity = e2.opacity, this.transparent = e2.transparent, this.blendSrc = e2.blendSrc, this.blendDst = e2.blendDst, this.blendEquation = e2.blendEquation, this.blendSrcAlpha = e2.blendSrcAlpha, this.blendDstAlpha = e2.blendDstAlpha, this.blendEquationAlpha = e2.blendEquationAlpha, this.depthFunc = e2.depthFunc, this.depthTest = e2.depthTest, this.depthWrite = e2.depthWrite, this.stencilWriteMask = e2.stencilWriteMask, this.stencilFunc = e2.stencilFunc, this.stencilRef = e2.stencilRef, this.stencilFuncMask = e2.stencilFuncMask, this.stencilFail = e2.stencilFail, this.stencilZFail = e2.stencilZFail, this.stencilZPass = e2.stencilZPass, this.stencilWrite = e2.stencilWrite;
  const t2 = e2.clippingPlanes;
  let n2 = null;
  if (null !== t2) {
    const e3 = t2.length;
    n2 = new Array(e3);
    for (let i2 = 0; i2 !== e3; ++i2) n2[i2] = t2[i2].clone();
  }
  return this.clippingPlanes = n2, this.clipIntersection = e2.clipIntersection, this.clipShadows = e2.clipShadows, this.shadowSide = e2.shadowSide, this.colorWrite = e2.colorWrite, this.precision = e2.precision, this.polygonOffset = e2.polygonOffset, this.polygonOffsetFactor = e2.polygonOffsetFactor, this.polygonOffsetUnits = e2.polygonOffsetUnits, this.dithering = e2.dithering, this.alphaTest = e2.alphaTest, this.alphaToCoverage = e2.alphaToCoverage, this.premultipliedAlpha = e2.premultipliedAlpha, this.visible = e2.visible, this.toneMapped = e2.toneMapped, this.userData = JSON.parse(JSON.stringify(e2.userData)), this;
}, dispose: function() {
  this.dispatchEvent({ type: "dispose" });
} }), Object.defineProperty(Ie.prototype, "needsUpdate", { set: function(e2) {
  true === e2 && this.version++;
} });
var Ne = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
var Oe = { h: 0, s: 0, l: 0 };
var Ue = { h: 0, s: 0, l: 0 };
function Fe(e2, t2, n2) {
  return n2 < 0 && (n2 += 1), n2 > 1 && (n2 -= 1), n2 < 1 / 6 ? e2 + 6 * (t2 - e2) * n2 : n2 < 0.5 ? t2 : n2 < 2 / 3 ? e2 + 6 * (t2 - e2) * (2 / 3 - n2) : e2;
}
function He(e2) {
  return e2 < 0.04045 ? 0.0773993808 * e2 : Math.pow(0.9478672986 * e2 + 0.0521327014, 2.4);
}
function ze(e2) {
  return e2 < 31308e-7 ? 12.92 * e2 : 1.055 * Math.pow(e2, 0.41666) - 0.055;
}
var Be = class {
  constructor(e2, t2, n2) {
    return void 0 === t2 && void 0 === n2 ? this.set(e2) : this.setRGB(e2, t2, n2);
  }
  set(e2) {
    return e2 && e2.isColor ? this.copy(e2) : "number" == typeof e2 ? this.setHex(e2) : "string" == typeof e2 && this.setStyle(e2), this;
  }
  setScalar(e2) {
    return this.r = e2, this.g = e2, this.b = e2, this;
  }
  setHex(e2) {
    return e2 = Math.floor(e2), this.r = (e2 >> 16 & 255) / 255, this.g = (e2 >> 8 & 255) / 255, this.b = (255 & e2) / 255, this;
  }
  setRGB(e2, t2, n2) {
    return this.r = e2, this.g = t2, this.b = n2, this;
  }
  setHSL(e2, t2, n2) {
    if (e2 = i.euclideanModulo(e2, 1), t2 = i.clamp(t2, 0, 1), n2 = i.clamp(n2, 0, 1), 0 === t2) this.r = this.g = this.b = n2;
    else {
      const i2 = n2 <= 0.5 ? n2 * (1 + t2) : n2 + t2 - n2 * t2, r2 = 2 * n2 - i2;
      this.r = Fe(r2, i2, e2 + 1 / 3), this.g = Fe(r2, i2, e2), this.b = Fe(r2, i2, e2 - 1 / 3);
    }
    return this;
  }
  setStyle(e2) {
    function t2(t3) {
      void 0 !== t3 && parseFloat(t3) < 1 && console.warn("THREE.Color: Alpha component of " + e2 + " will be ignored.");
    }
    let n2;
    if (n2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e2)) {
      let e3;
      const i2 = n2[1], r2 = n2[2];
      switch (i2) {
        case "rgb":
        case "rgba":
          if (e3 = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) return this.r = Math.min(255, parseInt(e3[1], 10)) / 255, this.g = Math.min(255, parseInt(e3[2], 10)) / 255, this.b = Math.min(255, parseInt(e3[3], 10)) / 255, t2(e3[4]), this;
          if (e3 = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) return this.r = Math.min(100, parseInt(e3[1], 10)) / 100, this.g = Math.min(100, parseInt(e3[2], 10)) / 100, this.b = Math.min(100, parseInt(e3[3], 10)) / 100, t2(e3[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (e3 = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r2)) {
            const n3 = parseFloat(e3[1]) / 360, i3 = parseInt(e3[2], 10) / 100, r3 = parseInt(e3[3], 10) / 100;
            return t2(e3[4]), this.setHSL(n3, i3, r3);
          }
      }
    } else if (n2 = /^\#([A-Fa-f\d]+)$/.exec(e2)) {
      const e3 = n2[1], t3 = e3.length;
      if (3 === t3) return this.r = parseInt(e3.charAt(0) + e3.charAt(0), 16) / 255, this.g = parseInt(e3.charAt(1) + e3.charAt(1), 16) / 255, this.b = parseInt(e3.charAt(2) + e3.charAt(2), 16) / 255, this;
      if (6 === t3) return this.r = parseInt(e3.charAt(0) + e3.charAt(1), 16) / 255, this.g = parseInt(e3.charAt(2) + e3.charAt(3), 16) / 255, this.b = parseInt(e3.charAt(4) + e3.charAt(5), 16) / 255, this;
    }
    return e2 && e2.length > 0 ? this.setColorName(e2) : this;
  }
  setColorName(e2) {
    const t2 = Ne[e2];
    return void 0 !== t2 ? this.setHex(t2) : console.warn("THREE.Color: Unknown color " + e2), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e2) {
    return this.r = e2.r, this.g = e2.g, this.b = e2.b, this;
  }
  copyGammaToLinear(e2, t2 = 2) {
    return this.r = Math.pow(e2.r, t2), this.g = Math.pow(e2.g, t2), this.b = Math.pow(e2.b, t2), this;
  }
  copyLinearToGamma(e2, t2 = 2) {
    const n2 = t2 > 0 ? 1 / t2 : 1;
    return this.r = Math.pow(e2.r, n2), this.g = Math.pow(e2.g, n2), this.b = Math.pow(e2.b, n2), this;
  }
  convertGammaToLinear(e2) {
    return this.copyGammaToLinear(this, e2), this;
  }
  convertLinearToGamma(e2) {
    return this.copyLinearToGamma(this, e2), this;
  }
  copySRGBToLinear(e2) {
    return this.r = He(e2.r), this.g = He(e2.g), this.b = He(e2.b), this;
  }
  copyLinearToSRGB(e2) {
    return this.r = ze(e2.r), this.g = ze(e2.g), this.b = ze(e2.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex() {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0;
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6);
  }
  getHSL(e2) {
    void 0 === e2 && (console.warn("THREE.Color: .getHSL() target is now required"), e2 = { h: 0, s: 0, l: 0 });
    const t2 = this.r, n2 = this.g, i2 = this.b, r2 = Math.max(t2, n2, i2), a2 = Math.min(t2, n2, i2);
    let o2, s2;
    const l2 = (a2 + r2) / 2;
    if (a2 === r2) o2 = 0, s2 = 0;
    else {
      const e3 = r2 - a2;
      switch (s2 = l2 <= 0.5 ? e3 / (r2 + a2) : e3 / (2 - r2 - a2), r2) {
        case t2:
          o2 = (n2 - i2) / e3 + (n2 < i2 ? 6 : 0);
          break;
        case n2:
          o2 = (i2 - t2) / e3 + 2;
          break;
        case i2:
          o2 = (t2 - n2) / e3 + 4;
      }
      o2 /= 6;
    }
    return e2.h = o2, e2.s = s2, e2.l = l2, e2;
  }
  getStyle() {
    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")";
  }
  offsetHSL(e2, t2, n2) {
    return this.getHSL(Oe), Oe.h += e2, Oe.s += t2, Oe.l += n2, this.setHSL(Oe.h, Oe.s, Oe.l), this;
  }
  add(e2) {
    return this.r += e2.r, this.g += e2.g, this.b += e2.b, this;
  }
  addColors(e2, t2) {
    return this.r = e2.r + t2.r, this.g = e2.g + t2.g, this.b = e2.b + t2.b, this;
  }
  addScalar(e2) {
    return this.r += e2, this.g += e2, this.b += e2, this;
  }
  sub(e2) {
    return this.r = Math.max(0, this.r - e2.r), this.g = Math.max(0, this.g - e2.g), this.b = Math.max(0, this.b - e2.b), this;
  }
  multiply(e2) {
    return this.r *= e2.r, this.g *= e2.g, this.b *= e2.b, this;
  }
  multiplyScalar(e2) {
    return this.r *= e2, this.g *= e2, this.b *= e2, this;
  }
  lerp(e2, t2) {
    return this.r += (e2.r - this.r) * t2, this.g += (e2.g - this.g) * t2, this.b += (e2.b - this.b) * t2, this;
  }
  lerpColors(e2, t2, n2) {
    return this.r = e2.r + (t2.r - e2.r) * n2, this.g = e2.g + (t2.g - e2.g) * n2, this.b = e2.b + (t2.b - e2.b) * n2, this;
  }
  lerpHSL(e2, t2) {
    this.getHSL(Oe), e2.getHSL(Ue);
    const n2 = i.lerp(Oe.h, Ue.h, t2), r2 = i.lerp(Oe.s, Ue.s, t2), a2 = i.lerp(Oe.l, Ue.l, t2);
    return this.setHSL(n2, r2, a2), this;
  }
  equals(e2) {
    return e2.r === this.r && e2.g === this.g && e2.b === this.b;
  }
  fromArray(e2, t2 = 0) {
    return this.r = e2[t2], this.g = e2[t2 + 1], this.b = e2[t2 + 2], this;
  }
  toArray(e2 = [], t2 = 0) {
    return e2[t2] = this.r, e2[t2 + 1] = this.g, e2[t2 + 2] = this.b, e2;
  }
  fromBufferAttribute(e2, t2) {
    return this.r = e2.getX(t2), this.g = e2.getY(t2), this.b = e2.getZ(t2), true === e2.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
};
Be.NAMES = Ne, Be.prototype.isColor = true, Be.prototype.r = 1, Be.prototype.g = 1, Be.prototype.b = 1;
var Ge = class extends Ie {
  constructor(e2) {
    super(), this.type = "MeshBasicMaterial", this.color = new Be(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.setValues(e2);
  }
  copy(e2) {
    return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.specularMap = e2.specularMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.combine = e2.combine, this.reflectivity = e2.reflectivity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.skinning = e2.skinning, this.morphTargets = e2.morphTargets, this;
  }
};
Ge.prototype.isMeshBasicMaterial = true;
var ke = new f();
var Ve = new r();
function We(e2, t2, n2) {
  if (Array.isArray(e2)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
  this.name = "", this.array = e2, this.itemSize = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.normalized = true === n2, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
}
function je(e2, t2, n2) {
  We.call(this, new Int8Array(e2), t2, n2);
}
function qe(e2, t2, n2) {
  We.call(this, new Uint8Array(e2), t2, n2);
}
function Xe(e2, t2, n2) {
  We.call(this, new Uint8ClampedArray(e2), t2, n2);
}
function Ye(e2, t2, n2) {
  We.call(this, new Int16Array(e2), t2, n2);
}
function Ze(e2, t2, n2) {
  We.call(this, new Uint16Array(e2), t2, n2);
}
function Je(e2, t2, n2) {
  We.call(this, new Int32Array(e2), t2, n2);
}
function Ke(e2, t2, n2) {
  We.call(this, new Uint32Array(e2), t2, n2);
}
function Qe(e2, t2, n2) {
  We.call(this, new Uint16Array(e2), t2, n2);
}
function $e(e2, t2, n2) {
  We.call(this, new Float32Array(e2), t2, n2);
}
function et(e2, t2, n2) {
  We.call(this, new Float64Array(e2), t2, n2);
}
function tt(e2) {
  if (0 === e2.length) return -1 / 0;
  let t2 = e2[0];
  for (let n2 = 1, i2 = e2.length; n2 < i2; ++n2) e2[n2] > t2 && (t2 = e2[n2]);
  return t2;
}
Object.defineProperty(We.prototype, "needsUpdate", { set: function(e2) {
  true === e2 && this.version++;
} }), Object.assign(We.prototype, { isBufferAttribute: true, onUploadCallback: function() {
}, setUsage: function(e2) {
  return this.usage = e2, this;
}, copy: function(e2) {
  return this.name = e2.name, this.array = new e2.array.constructor(e2.array), this.itemSize = e2.itemSize, this.count = e2.count, this.normalized = e2.normalized, this.usage = e2.usage, this;
}, copyAt: function(e2, t2, n2) {
  e2 *= this.itemSize, n2 *= t2.itemSize;
  for (let i2 = 0, r2 = this.itemSize; i2 < r2; i2++) this.array[e2 + i2] = t2.array[n2 + i2];
  return this;
}, copyArray: function(e2) {
  return this.array.set(e2), this;
}, copyColorsArray: function(e2) {
  const t2 = this.array;
  let n2 = 0;
  for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) {
    let r3 = e2[i2];
    void 0 === r3 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2), r3 = new Be()), t2[n2++] = r3.r, t2[n2++] = r3.g, t2[n2++] = r3.b;
  }
  return this;
}, copyVector2sArray: function(e2) {
  const t2 = this.array;
  let n2 = 0;
  for (let i2 = 0, a2 = e2.length; i2 < a2; i2++) {
    let a3 = e2[i2];
    void 0 === a3 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2), a3 = new r()), t2[n2++] = a3.x, t2[n2++] = a3.y;
  }
  return this;
}, copyVector3sArray: function(e2) {
  const t2 = this.array;
  let n2 = 0;
  for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) {
    let r3 = e2[i2];
    void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2), r3 = new f()), t2[n2++] = r3.x, t2[n2++] = r3.y, t2[n2++] = r3.z;
  }
  return this;
}, copyVector4sArray: function(e2) {
  const t2 = this.array;
  let n2 = 0;
  for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) {
    let r3 = e2[i2];
    void 0 === r3 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2), r3 = new u()), t2[n2++] = r3.x, t2[n2++] = r3.y, t2[n2++] = r3.z, t2[n2++] = r3.w;
  }
  return this;
}, applyMatrix3: function(e2) {
  if (2 === this.itemSize) for (let t2 = 0, n2 = this.count; t2 < n2; t2++) Ve.fromBufferAttribute(this, t2), Ve.applyMatrix3(e2), this.setXY(t2, Ve.x, Ve.y);
  else if (3 === this.itemSize) for (let t2 = 0, n2 = this.count; t2 < n2; t2++) ke.fromBufferAttribute(this, t2), ke.applyMatrix3(e2), this.setXYZ(t2, ke.x, ke.y, ke.z);
  return this;
}, applyMatrix4: function(e2) {
  for (let t2 = 0, n2 = this.count; t2 < n2; t2++) ke.x = this.getX(t2), ke.y = this.getY(t2), ke.z = this.getZ(t2), ke.applyMatrix4(e2), this.setXYZ(t2, ke.x, ke.y, ke.z);
  return this;
}, applyNormalMatrix: function(e2) {
  for (let t2 = 0, n2 = this.count; t2 < n2; t2++) ke.x = this.getX(t2), ke.y = this.getY(t2), ke.z = this.getZ(t2), ke.applyNormalMatrix(e2), this.setXYZ(t2, ke.x, ke.y, ke.z);
  return this;
}, transformDirection: function(e2) {
  for (let t2 = 0, n2 = this.count; t2 < n2; t2++) ke.x = this.getX(t2), ke.y = this.getY(t2), ke.z = this.getZ(t2), ke.transformDirection(e2), this.setXYZ(t2, ke.x, ke.y, ke.z);
  return this;
}, set: function(e2, t2 = 0) {
  return this.array.set(e2, t2), this;
}, getX: function(e2) {
  return this.array[e2 * this.itemSize];
}, setX: function(e2, t2) {
  return this.array[e2 * this.itemSize] = t2, this;
}, getY: function(e2) {
  return this.array[e2 * this.itemSize + 1];
}, setY: function(e2, t2) {
  return this.array[e2 * this.itemSize + 1] = t2, this;
}, getZ: function(e2) {
  return this.array[e2 * this.itemSize + 2];
}, setZ: function(e2, t2) {
  return this.array[e2 * this.itemSize + 2] = t2, this;
}, getW: function(e2) {
  return this.array[e2 * this.itemSize + 3];
}, setW: function(e2, t2) {
  return this.array[e2 * this.itemSize + 3] = t2, this;
}, setXY: function(e2, t2, n2) {
  return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = n2, this;
}, setXYZ: function(e2, t2, n2, i2) {
  return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = n2, this.array[e2 + 2] = i2, this;
}, setXYZW: function(e2, t2, n2, i2, r2) {
  return e2 *= this.itemSize, this.array[e2 + 0] = t2, this.array[e2 + 1] = n2, this.array[e2 + 2] = i2, this.array[e2 + 3] = r2, this;
}, onUpload: function(e2) {
  return this.onUploadCallback = e2, this;
}, clone: function() {
  return new this.constructor(this.array, this.itemSize).copy(this);
}, toJSON: function() {
  const e2 = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
  return "" !== this.name && (e2.name = this.name), 35044 !== this.usage && (e2.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e2.updateRange = this.updateRange), e2;
} }), je.prototype = Object.create(We.prototype), je.prototype.constructor = je, qe.prototype = Object.create(We.prototype), qe.prototype.constructor = qe, Xe.prototype = Object.create(We.prototype), Xe.prototype.constructor = Xe, Ye.prototype = Object.create(We.prototype), Ye.prototype.constructor = Ye, Ze.prototype = Object.create(We.prototype), Ze.prototype.constructor = Ze, Je.prototype = Object.create(We.prototype), Je.prototype.constructor = Je, Ke.prototype = Object.create(We.prototype), Ke.prototype.constructor = Ke, Qe.prototype = Object.create(We.prototype), Qe.prototype.constructor = Qe, Qe.prototype.isFloat16BufferAttribute = true, $e.prototype = Object.create(We.prototype), $e.prototype.constructor = $e, et.prototype = Object.create(We.prototype), et.prototype.constructor = et;
var nt = 0;
var it = new j();
var rt = new ge();
var at = new f();
var ot = new v();
var st = new v();
var lt = new f();
function ct() {
  Object.defineProperty(this, "id", { value: nt++ }), this.uuid = i.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
}
ct.prototype = Object.assign(Object.create(e.prototype), { constructor: ct, isBufferGeometry: true, getIndex: function() {
  return this.index;
}, setIndex: function(e2) {
  return Array.isArray(e2) ? this.index = new (tt(e2) > 65535 ? Ke : Ze)(e2, 1) : this.index = e2, this;
}, getAttribute: function(e2) {
  return this.attributes[e2];
}, setAttribute: function(e2, t2) {
  return this.attributes[e2] = t2, this;
}, deleteAttribute: function(e2) {
  return delete this.attributes[e2], this;
}, hasAttribute: function(e2) {
  return void 0 !== this.attributes[e2];
}, addGroup: function(e2, t2, n2 = 0) {
  this.groups.push({ start: e2, count: t2, materialIndex: n2 });
}, clearGroups: function() {
  this.groups = [];
}, setDrawRange: function(e2, t2) {
  this.drawRange.start = e2, this.drawRange.count = t2;
}, applyMatrix4: function(e2) {
  const t2 = this.attributes.position;
  void 0 !== t2 && (t2.applyMatrix4(e2), t2.needsUpdate = true);
  const n2 = this.attributes.normal;
  if (void 0 !== n2) {
    const t3 = new a().getNormalMatrix(e2);
    n2.applyNormalMatrix(t3), n2.needsUpdate = true;
  }
  const i2 = this.attributes.tangent;
  return void 0 !== i2 && (i2.transformDirection(e2), i2.needsUpdate = true), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this;
}, rotateX: function(e2) {
  return it.makeRotationX(e2), this.applyMatrix4(it), this;
}, rotateY: function(e2) {
  return it.makeRotationY(e2), this.applyMatrix4(it), this;
}, rotateZ: function(e2) {
  return it.makeRotationZ(e2), this.applyMatrix4(it), this;
}, translate: function(e2, t2, n2) {
  return it.makeTranslation(e2, t2, n2), this.applyMatrix4(it), this;
}, scale: function(e2, t2, n2) {
  return it.makeScale(e2, t2, n2), this.applyMatrix4(it), this;
}, lookAt: function(e2) {
  return rt.lookAt(e2), rt.updateMatrix(), this.applyMatrix4(rt.matrix), this;
}, center: function() {
  return this.computeBoundingBox(), this.boundingBox.getCenter(at).negate(), this.translate(at.x, at.y, at.z), this;
}, setFromPoints: function(e2) {
  const t2 = [];
  for (let n2 = 0, i2 = e2.length; n2 < i2; n2++) {
    const i3 = e2[n2];
    t2.push(i3.x, i3.y, i3.z || 0);
  }
  return this.setAttribute("position", new $e(t2, 3)), this;
}, computeBoundingBox: function() {
  null === this.boundingBox && (this.boundingBox = new v());
  const e2 = this.attributes.position, t2 = this.morphAttributes.position;
  if (e2 && e2.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new f(-1 / 0, -1 / 0, -1 / 0), new f(1 / 0, 1 / 0, 1 / 0));
  if (void 0 !== e2) {
    if (this.boundingBox.setFromBufferAttribute(e2), t2) for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) {
      const e3 = t2[n2];
      ot.setFromBufferAttribute(e3), this.morphTargetsRelative ? (lt.addVectors(this.boundingBox.min, ot.min), this.boundingBox.expandByPoint(lt), lt.addVectors(this.boundingBox.max, ot.max), this.boundingBox.expandByPoint(lt)) : (this.boundingBox.expandByPoint(ot.min), this.boundingBox.expandByPoint(ot.max));
    }
  } else this.boundingBox.makeEmpty();
  (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
}, computeBoundingSphere: function() {
  null === this.boundingSphere && (this.boundingSphere = new U());
  const e2 = this.attributes.position, t2 = this.morphAttributes.position;
  if (e2 && e2.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new f(), 1 / 0);
  if (e2) {
    const n2 = this.boundingSphere.center;
    if (ot.setFromBufferAttribute(e2), t2) for (let e3 = 0, r2 = t2.length; e3 < r2; e3++) {
      const n3 = t2[e3];
      st.setFromBufferAttribute(n3), this.morphTargetsRelative ? (lt.addVectors(ot.min, st.min), ot.expandByPoint(lt), lt.addVectors(ot.max, st.max), ot.expandByPoint(lt)) : (ot.expandByPoint(st.min), ot.expandByPoint(st.max));
    }
    ot.getCenter(n2);
    let i2 = 0;
    for (let t3 = 0, r2 = e2.count; t3 < r2; t3++) lt.fromBufferAttribute(e2, t3), i2 = Math.max(i2, n2.distanceToSquared(lt));
    if (t2) for (let r2 = 0, a2 = t2.length; r2 < a2; r2++) {
      const a3 = t2[r2], o2 = this.morphTargetsRelative;
      for (let t3 = 0, r3 = a3.count; t3 < r3; t3++) lt.fromBufferAttribute(a3, t3), o2 && (at.fromBufferAttribute(e2, t3), lt.add(at)), i2 = Math.max(i2, n2.distanceToSquared(lt));
    }
    this.boundingSphere.radius = Math.sqrt(i2), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
  }
}, computeFaceNormals: function() {
}, computeTangents: function() {
  const e2 = this.index, t2 = this.attributes;
  if (null === e2 || void 0 === t2.position || void 0 === t2.normal || void 0 === t2.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
  const n2 = e2.array, i2 = t2.position.array, a2 = t2.normal.array, o2 = t2.uv.array, s2 = i2.length / 3;
  void 0 === t2.tangent && this.setAttribute("tangent", new We(new Float32Array(4 * s2), 4));
  const l2 = t2.tangent.array, c2 = [], h2 = [];
  for (let r2 = 0; r2 < s2; r2++) c2[r2] = new f(), h2[r2] = new f();
  const u2 = new f(), d2 = new f(), p2 = new f(), m2 = new r(), g2 = new r(), v2 = new r(), x2 = new f(), y2 = new f();
  function _2(e3, t3, n3) {
    u2.fromArray(i2, 3 * e3), d2.fromArray(i2, 3 * t3), p2.fromArray(i2, 3 * n3), m2.fromArray(o2, 2 * e3), g2.fromArray(o2, 2 * t3), v2.fromArray(o2, 2 * n3), d2.sub(u2), p2.sub(u2), g2.sub(m2), v2.sub(m2);
    const r2 = 1 / (g2.x * v2.y - v2.x * g2.y);
    isFinite(r2) && (x2.copy(d2).multiplyScalar(v2.y).addScaledVector(p2, -g2.y).multiplyScalar(r2), y2.copy(p2).multiplyScalar(g2.x).addScaledVector(d2, -v2.x).multiplyScalar(r2), c2[e3].add(x2), c2[t3].add(x2), c2[n3].add(x2), h2[e3].add(y2), h2[t3].add(y2), h2[n3].add(y2));
  }
  let b2 = this.groups;
  0 === b2.length && (b2 = [{ start: 0, count: n2.length }]);
  for (let r2 = 0, f2 = b2.length; r2 < f2; ++r2) {
    const e3 = b2[r2], t3 = e3.start;
    for (let i3 = t3, r3 = t3 + e3.count; i3 < r3; i3 += 3) _2(n2[i3 + 0], n2[i3 + 1], n2[i3 + 2]);
  }
  const w2 = new f(), M2 = new f(), S2 = new f(), T2 = new f();
  function E2(e3) {
    S2.fromArray(a2, 3 * e3), T2.copy(S2);
    const t3 = c2[e3];
    w2.copy(t3), w2.sub(S2.multiplyScalar(S2.dot(t3))).normalize(), M2.crossVectors(T2, t3);
    const n3 = M2.dot(h2[e3]) < 0 ? -1 : 1;
    l2[4 * e3] = w2.x, l2[4 * e3 + 1] = w2.y, l2[4 * e3 + 2] = w2.z, l2[4 * e3 + 3] = n3;
  }
  for (let r2 = 0, f2 = b2.length; r2 < f2; ++r2) {
    const e3 = b2[r2], t3 = e3.start;
    for (let i3 = t3, r3 = t3 + e3.count; i3 < r3; i3 += 3) E2(n2[i3 + 0]), E2(n2[i3 + 1]), E2(n2[i3 + 2]);
  }
}, computeVertexNormals: function() {
  const e2 = this.index, t2 = this.getAttribute("position");
  if (void 0 !== t2) {
    let n2 = this.getAttribute("normal");
    if (void 0 === n2) n2 = new We(new Float32Array(3 * t2.count), 3), this.setAttribute("normal", n2);
    else for (let e3 = 0, t3 = n2.count; e3 < t3; e3++) n2.setXYZ(e3, 0, 0, 0);
    const i2 = new f(), r2 = new f(), a2 = new f(), o2 = new f(), s2 = new f(), l2 = new f(), c2 = new f(), h2 = new f();
    if (e2) for (let u2 = 0, d2 = e2.count; u2 < d2; u2 += 3) {
      const d3 = e2.getX(u2 + 0), p2 = e2.getX(u2 + 1), f2 = e2.getX(u2 + 2);
      i2.fromBufferAttribute(t2, d3), r2.fromBufferAttribute(t2, p2), a2.fromBufferAttribute(t2, f2), c2.subVectors(a2, r2), h2.subVectors(i2, r2), c2.cross(h2), o2.fromBufferAttribute(n2, d3), s2.fromBufferAttribute(n2, p2), l2.fromBufferAttribute(n2, f2), o2.add(c2), s2.add(c2), l2.add(c2), n2.setXYZ(d3, o2.x, o2.y, o2.z), n2.setXYZ(p2, s2.x, s2.y, s2.z), n2.setXYZ(f2, l2.x, l2.y, l2.z);
    }
    else for (let e3 = 0, u2 = t2.count; e3 < u2; e3 += 3) i2.fromBufferAttribute(t2, e3 + 0), r2.fromBufferAttribute(t2, e3 + 1), a2.fromBufferAttribute(t2, e3 + 2), c2.subVectors(a2, r2), h2.subVectors(i2, r2), c2.cross(h2), n2.setXYZ(e3 + 0, c2.x, c2.y, c2.z), n2.setXYZ(e3 + 1, c2.x, c2.y, c2.z), n2.setXYZ(e3 + 2, c2.x, c2.y, c2.z);
    this.normalizeNormals(), n2.needsUpdate = true;
  }
}, merge: function(e2, t2) {
  if (!e2 || !e2.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e2);
  void 0 === t2 && (t2 = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
  const n2 = this.attributes;
  for (const i2 in n2) {
    if (void 0 === e2.attributes[i2]) continue;
    const r2 = n2[i2].array, a2 = e2.attributes[i2], o2 = a2.array, s2 = a2.itemSize * t2, l2 = Math.min(o2.length, r2.length - s2);
    for (let e3 = 0, t3 = s2; e3 < l2; e3++, t3++) r2[t3] = o2[e3];
  }
  return this;
}, normalizeNormals: function() {
  const e2 = this.attributes.normal;
  for (let t2 = 0, n2 = e2.count; t2 < n2; t2++) lt.fromBufferAttribute(e2, t2), lt.normalize(), e2.setXYZ(t2, lt.x, lt.y, lt.z);
}, toNonIndexed: function() {
  function e2(e3, t3) {
    const n3 = e3.array, i3 = e3.itemSize, r3 = e3.normalized, a3 = new n3.constructor(t3.length * i3);
    let o2 = 0, s2 = 0;
    for (let l2 = 0, c2 = t3.length; l2 < c2; l2++) {
      o2 = t3[l2] * i3;
      for (let e4 = 0; e4 < i3; e4++) a3[s2++] = n3[o2++];
    }
    return new We(a3, i3, r3);
  }
  if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
  const t2 = new ct(), n2 = this.index.array, i2 = this.attributes;
  for (const o2 in i2) {
    const r3 = e2(i2[o2], n2);
    t2.setAttribute(o2, r3);
  }
  const r2 = this.morphAttributes;
  for (const o2 in r2) {
    const i3 = [], a3 = r2[o2];
    for (let t3 = 0, r3 = a3.length; t3 < r3; t3++) {
      const r4 = e2(a3[t3], n2);
      i3.push(r4);
    }
    t2.morphAttributes[o2] = i3;
  }
  t2.morphTargetsRelative = this.morphTargetsRelative;
  const a2 = this.groups;
  for (let o2 = 0, s2 = a2.length; o2 < s2; o2++) {
    const e3 = a2[o2];
    t2.addGroup(e3.start, e3.count, e3.materialIndex);
  }
  return t2;
}, toJSON: function() {
  const e2 = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
  if (e2.uuid = this.uuid, e2.type = this.type, "" !== this.name && (e2.name = this.name), Object.keys(this.userData).length > 0 && (e2.userData = this.userData), void 0 !== this.parameters) {
    const t3 = this.parameters;
    for (const n3 in t3) void 0 !== t3[n3] && (e2[n3] = t3[n3]);
    return e2;
  }
  e2.data = { attributes: {} };
  const t2 = this.index;
  null !== t2 && (e2.data.index = { type: t2.array.constructor.name, array: Array.prototype.slice.call(t2.array) });
  const n2 = this.attributes;
  for (const s2 in n2) {
    const t3 = n2[s2];
    e2.data.attributes[s2] = t3.toJSON(e2.data);
  }
  const i2 = {};
  let r2 = false;
  for (const s2 in this.morphAttributes) {
    const t3 = this.morphAttributes[s2], n3 = [];
    for (let i3 = 0, r3 = t3.length; i3 < r3; i3++) {
      const r4 = t3[i3];
      n3.push(r4.toJSON(e2.data));
    }
    n3.length > 0 && (i2[s2] = n3, r2 = true);
  }
  r2 && (e2.data.morphAttributes = i2, e2.data.morphTargetsRelative = this.morphTargetsRelative);
  const a2 = this.groups;
  a2.length > 0 && (e2.data.groups = JSON.parse(JSON.stringify(a2)));
  const o2 = this.boundingSphere;
  return null !== o2 && (e2.data.boundingSphere = { center: o2.center.toArray(), radius: o2.radius }), e2;
}, clone: function() {
  return new ct().copy(this);
}, copy: function(e2) {
  this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
  const t2 = {};
  this.name = e2.name;
  const n2 = e2.index;
  null !== n2 && this.setIndex(n2.clone(t2));
  const i2 = e2.attributes;
  for (const l2 in i2) {
    const e3 = i2[l2];
    this.setAttribute(l2, e3.clone(t2));
  }
  const r2 = e2.morphAttributes;
  for (const l2 in r2) {
    const e3 = [], n3 = r2[l2];
    for (let i3 = 0, r3 = n3.length; i3 < r3; i3++) e3.push(n3[i3].clone(t2));
    this.morphAttributes[l2] = e3;
  }
  this.morphTargetsRelative = e2.morphTargetsRelative;
  const a2 = e2.groups;
  for (let l2 = 0, c2 = a2.length; l2 < c2; l2++) {
    const e3 = a2[l2];
    this.addGroup(e3.start, e3.count, e3.materialIndex);
  }
  const o2 = e2.boundingBox;
  null !== o2 && (this.boundingBox = o2.clone());
  const s2 = e2.boundingSphere;
  return null !== s2 && (this.boundingSphere = s2.clone()), this.drawRange.start = e2.drawRange.start, this.drawRange.count = e2.drawRange.count, this.userData = e2.userData, this;
}, dispose: function() {
  this.dispatchEvent({ type: "dispose" });
} });
var ht = new j();
var ut = new W();
var dt = new U();
var pt = new f();
var ft = new f();
var mt = new f();
var gt = new f();
var vt = new f();
var xt = new f();
var yt = new f();
var _t = new f();
var bt = new f();
var wt = new r();
var Mt = new r();
var St = new r();
var Tt = new f();
var Et = new f();
function Lt(e2 = new ct(), t2 = new Ge()) {
  ge.call(this), this.type = "Mesh", this.geometry = e2, this.material = t2, this.updateMorphTargets();
}
function Rt(e2, t2, n2, i2, a2, o2, s2, l2, c2, h2, u2, d2) {
  pt.fromBufferAttribute(a2, h2), ft.fromBufferAttribute(a2, u2), mt.fromBufferAttribute(a2, d2);
  const p2 = e2.morphTargetInfluences;
  if (t2.morphTargets && o2 && p2) {
    yt.set(0, 0, 0), _t.set(0, 0, 0), bt.set(0, 0, 0);
    for (let e3 = 0, t3 = o2.length; e3 < t3; e3++) {
      const t4 = p2[e3], n3 = o2[e3];
      0 !== t4 && (gt.fromBufferAttribute(n3, h2), vt.fromBufferAttribute(n3, u2), xt.fromBufferAttribute(n3, d2), s2 ? (yt.addScaledVector(gt, t4), _t.addScaledVector(vt, t4), bt.addScaledVector(xt, t4)) : (yt.addScaledVector(gt.sub(pt), t4), _t.addScaledVector(vt.sub(ft), t4), bt.addScaledVector(xt.sub(mt), t4)));
    }
    pt.add(yt), ft.add(_t), mt.add(bt);
  }
  e2.isSkinnedMesh && t2.skinning && (e2.boneTransform(h2, pt), e2.boneTransform(u2, ft), e2.boneTransform(d2, mt));
  const m2 = function(e3, t3, n3, i3, r2, a3, o3, s3) {
    let l3;
    if (l3 = 1 === t3.side ? i3.intersectTriangle(o3, a3, r2, true, s3) : i3.intersectTriangle(r2, a3, o3, 2 !== t3.side, s3), null === l3) return null;
    Et.copy(s3), Et.applyMatrix4(e3.matrixWorld);
    const c3 = n3.ray.origin.distanceTo(Et);
    return c3 < n3.near || c3 > n3.far ? null : { distance: c3, point: Et.clone(), object: e3 };
  }(e2, t2, n2, i2, pt, ft, mt, Tt);
  if (m2) {
    l2 && (wt.fromBufferAttribute(l2, h2), Mt.fromBufferAttribute(l2, u2), St.fromBufferAttribute(l2, d2), m2.uv = Ce.getUV(Tt, pt, ft, mt, wt, Mt, St, new r())), c2 && (wt.fromBufferAttribute(c2, h2), Mt.fromBufferAttribute(c2, u2), St.fromBufferAttribute(c2, d2), m2.uv2 = Ce.getUV(Tt, pt, ft, mt, wt, Mt, St, new r()));
    const e3 = { a: h2, b: u2, c: d2, normal: new f(), materialIndex: 0 };
    Ce.getNormal(pt, ft, mt, e3.normal), m2.face = e3;
  }
  return m2;
}
Lt.prototype = Object.assign(Object.create(ge.prototype), { constructor: Lt, isMesh: true, copy: function(e2) {
  return ge.prototype.copy.call(this, e2), void 0 !== e2.morphTargetInfluences && (this.morphTargetInfluences = e2.morphTargetInfluences.slice()), void 0 !== e2.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e2.morphTargetDictionary)), this.material = e2.material, this.geometry = e2.geometry, this;
}, updateMorphTargets: function() {
  const e2 = this.geometry;
  if (e2.isBufferGeometry) {
    const t2 = e2.morphAttributes, n2 = Object.keys(t2);
    if (n2.length > 0) {
      const e3 = t2[n2[0]];
      if (void 0 !== e3) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let t3 = 0, n3 = e3.length; t3 < n3; t3++) {
          const n4 = e3[t3].name || String(t3);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = t3;
        }
      }
    }
  } else {
    const t2 = e2.morphTargets;
    void 0 !== t2 && t2.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
}, raycast: function(e2, t2) {
  const n2 = this.geometry, i2 = this.material, r2 = this.matrixWorld;
  if (void 0 === i2) return;
  if (null === n2.boundingSphere && n2.computeBoundingSphere(), dt.copy(n2.boundingSphere), dt.applyMatrix4(r2), false === e2.ray.intersectsSphere(dt)) return;
  if (ht.copy(r2).invert(), ut.copy(e2.ray).applyMatrix4(ht), null !== n2.boundingBox && false === ut.intersectsBox(n2.boundingBox)) return;
  let a2;
  if (n2.isBufferGeometry) {
    const r3 = n2.index, o2 = n2.attributes.position, s2 = n2.morphAttributes.position, l2 = n2.morphTargetsRelative, c2 = n2.attributes.uv, h2 = n2.attributes.uv2, u2 = n2.groups, d2 = n2.drawRange;
    if (null !== r3) if (Array.isArray(i2)) for (let n3 = 0, p2 = u2.length; n3 < p2; n3++) {
      const p3 = u2[n3], f2 = i2[p3.materialIndex];
      for (let n4 = Math.max(p3.start, d2.start), i3 = Math.min(p3.start + p3.count, d2.start + d2.count); n4 < i3; n4 += 3) {
        const i4 = r3.getX(n4), u3 = r3.getX(n4 + 1), d3 = r3.getX(n4 + 2);
        a2 = Rt(this, f2, e2, ut, o2, s2, l2, c2, h2, i4, u3, d3), a2 && (a2.faceIndex = Math.floor(n4 / 3), a2.face.materialIndex = p3.materialIndex, t2.push(a2));
      }
    }
    else {
      for (let n3 = Math.max(0, d2.start), u3 = Math.min(r3.count, d2.start + d2.count); n3 < u3; n3 += 3) {
        const u4 = r3.getX(n3), d3 = r3.getX(n3 + 1), p2 = r3.getX(n3 + 2);
        a2 = Rt(this, i2, e2, ut, o2, s2, l2, c2, h2, u4, d3, p2), a2 && (a2.faceIndex = Math.floor(n3 / 3), t2.push(a2));
      }
    }
    else if (void 0 !== o2) if (Array.isArray(i2)) for (let n3 = 0, p2 = u2.length; n3 < p2; n3++) {
      const r4 = u2[n3], p3 = i2[r4.materialIndex];
      for (let n4 = Math.max(r4.start, d2.start), i3 = Math.min(r4.start + r4.count, d2.start + d2.count); n4 < i3; n4 += 3) {
        a2 = Rt(this, p3, e2, ut, o2, s2, l2, c2, h2, n4, n4 + 1, n4 + 2), a2 && (a2.faceIndex = Math.floor(n4 / 3), a2.face.materialIndex = r4.materialIndex, t2.push(a2));
      }
    }
    else {
      for (let n3 = Math.max(0, d2.start), r4 = Math.min(o2.count, d2.start + d2.count); n3 < r4; n3 += 3) {
        a2 = Rt(this, i2, e2, ut, o2, s2, l2, c2, h2, n3, n3 + 1, n3 + 2), a2 && (a2.faceIndex = Math.floor(n3 / 3), t2.push(a2));
      }
    }
  } else n2.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
} });
var At = class extends ct {
  constructor(e2 = 1, t2 = 1, n2 = 1, i2 = 1, r2 = 1, a2 = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e2, height: t2, depth: n2, widthSegments: i2, heightSegments: r2, depthSegments: a2 };
    const o2 = this;
    i2 = Math.floor(i2), r2 = Math.floor(r2), a2 = Math.floor(a2);
    const s2 = [], l2 = [], c2 = [], h2 = [];
    let u2 = 0, d2 = 0;
    function p2(e3, t3, n3, i3, r3, a3, p3, m2, g2, v2, x2) {
      const y2 = a3 / g2, _2 = p3 / v2, b2 = a3 / 2, w2 = p3 / 2, M2 = m2 / 2, S2 = g2 + 1, T2 = v2 + 1;
      let E2 = 0, L2 = 0;
      const R2 = new f();
      for (let o3 = 0; o3 < T2; o3++) {
        const a4 = o3 * _2 - w2;
        for (let s3 = 0; s3 < S2; s3++) {
          const u3 = s3 * y2 - b2;
          R2[e3] = u3 * i3, R2[t3] = a4 * r3, R2[n3] = M2, l2.push(R2.x, R2.y, R2.z), R2[e3] = 0, R2[t3] = 0, R2[n3] = m2 > 0 ? 1 : -1, c2.push(R2.x, R2.y, R2.z), h2.push(s3 / g2), h2.push(1 - o3 / v2), E2 += 1;
        }
      }
      for (let o3 = 0; o3 < v2; o3++) for (let e4 = 0; e4 < g2; e4++) {
        const t4 = u2 + e4 + S2 * o3, n4 = u2 + e4 + S2 * (o3 + 1), i4 = u2 + (e4 + 1) + S2 * (o3 + 1), r4 = u2 + (e4 + 1) + S2 * o3;
        s2.push(t4, n4, r4), s2.push(n4, i4, r4), L2 += 6;
      }
      o2.addGroup(d2, L2, x2), d2 += L2, u2 += E2;
    }
    p2("z", "y", "x", -1, -1, n2, t2, e2, a2, r2, 0), p2("z", "y", "x", 1, -1, n2, t2, -e2, a2, r2, 1), p2("x", "z", "y", 1, 1, e2, n2, t2, i2, a2, 2), p2("x", "z", "y", 1, -1, e2, n2, -t2, i2, a2, 3), p2("x", "y", "z", 1, -1, e2, t2, n2, i2, r2, 4), p2("x", "y", "z", -1, -1, e2, t2, -n2, i2, r2, 5), this.setIndex(s2), this.setAttribute("position", new $e(l2, 3)), this.setAttribute("normal", new $e(c2, 3)), this.setAttribute("uv", new $e(h2, 2));
  }
};
function Pt(e2) {
  const t2 = {};
  for (const n2 in e2) {
    t2[n2] = {};
    for (const i2 in e2[n2]) {
      const r2 = e2[n2][i2];
      r2 && (r2.isColor || r2.isMatrix3 || r2.isMatrix4 || r2.isVector2 || r2.isVector3 || r2.isVector4 || r2.isTexture || r2.isQuaternion) ? t2[n2][i2] = r2.clone() : Array.isArray(r2) ? t2[n2][i2] = r2.slice() : t2[n2][i2] = r2;
    }
  }
  return t2;
}
function Ct(e2) {
  const t2 = {};
  for (let n2 = 0; n2 < e2.length; n2++) {
    const i2 = Pt(e2[n2]);
    for (const e3 in i2) t2[e3] = i2[e3];
  }
  return t2;
}
var Dt = { clone: Pt, merge: Ct };
function It(e2) {
  Ie.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, void 0 !== e2 && (void 0 !== e2.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e2));
}
function Nt() {
  ge.call(this), this.type = "Camera", this.matrixWorldInverse = new j(), this.projectionMatrix = new j(), this.projectionMatrixInverse = new j();
}
function Ot(e2 = 50, t2 = 1, n2 = 0.1, i2 = 2e3) {
  Nt.call(this), this.type = "PerspectiveCamera", this.fov = e2, this.zoom = 1, this.near = n2, this.far = i2, this.focus = 10, this.aspect = t2, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
}
It.prototype = Object.create(Ie.prototype), It.prototype.constructor = It, It.prototype.isShaderMaterial = true, It.prototype.copy = function(e2) {
  return Ie.prototype.copy.call(this, e2), this.fragmentShader = e2.fragmentShader, this.vertexShader = e2.vertexShader, this.uniforms = Pt(e2.uniforms), this.defines = Object.assign({}, e2.defines), this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.lights = e2.lights, this.clipping = e2.clipping, this.skinning = e2.skinning, this.morphTargets = e2.morphTargets, this.morphNormals = e2.morphNormals, this.extensions = Object.assign({}, e2.extensions), this.glslVersion = e2.glslVersion, this;
}, It.prototype.toJSON = function(e2) {
  const t2 = Ie.prototype.toJSON.call(this, e2);
  t2.glslVersion = this.glslVersion, t2.uniforms = {};
  for (const i2 in this.uniforms) {
    const n3 = this.uniforms[i2].value;
    n3 && n3.isTexture ? t2.uniforms[i2] = { type: "t", value: n3.toJSON(e2).uuid } : n3 && n3.isColor ? t2.uniforms[i2] = { type: "c", value: n3.getHex() } : n3 && n3.isVector2 ? t2.uniforms[i2] = { type: "v2", value: n3.toArray() } : n3 && n3.isVector3 ? t2.uniforms[i2] = { type: "v3", value: n3.toArray() } : n3 && n3.isVector4 ? t2.uniforms[i2] = { type: "v4", value: n3.toArray() } : n3 && n3.isMatrix3 ? t2.uniforms[i2] = { type: "m3", value: n3.toArray() } : n3 && n3.isMatrix4 ? t2.uniforms[i2] = { type: "m4", value: n3.toArray() } : t2.uniforms[i2] = { value: n3 };
  }
  Object.keys(this.defines).length > 0 && (t2.defines = this.defines), t2.vertexShader = this.vertexShader, t2.fragmentShader = this.fragmentShader;
  const n2 = {};
  for (const i2 in this.extensions) true === this.extensions[i2] && (n2[i2] = true);
  return Object.keys(n2).length > 0 && (t2.extensions = n2), t2;
}, Nt.prototype = Object.assign(Object.create(ge.prototype), { constructor: Nt, isCamera: true, copy: function(e2, t2) {
  return ge.prototype.copy.call(this, e2, t2), this.matrixWorldInverse.copy(e2.matrixWorldInverse), this.projectionMatrix.copy(e2.projectionMatrix), this.projectionMatrixInverse.copy(e2.projectionMatrixInverse), this;
}, getWorldDirection: function(e2) {
  void 0 === e2 && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e2 = new f()), this.updateWorldMatrix(true, false);
  const t2 = this.matrixWorld.elements;
  return e2.set(-t2[8], -t2[9], -t2[10]).normalize();
}, updateMatrixWorld: function(e2) {
  ge.prototype.updateMatrixWorld.call(this, e2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
}, updateWorldMatrix: function(e2, t2) {
  ge.prototype.updateWorldMatrix.call(this, e2, t2), this.matrixWorldInverse.copy(this.matrixWorld).invert();
}, clone: function() {
  return new this.constructor().copy(this);
} }), Ot.prototype = Object.assign(Object.create(Nt.prototype), { constructor: Ot, isPerspectiveCamera: true, copy: function(e2, t2) {
  return Nt.prototype.copy.call(this, e2, t2), this.fov = e2.fov, this.zoom = e2.zoom, this.near = e2.near, this.far = e2.far, this.focus = e2.focus, this.aspect = e2.aspect, this.view = null === e2.view ? null : Object.assign({}, e2.view), this.filmGauge = e2.filmGauge, this.filmOffset = e2.filmOffset, this;
}, setFocalLength: function(e2) {
  const t2 = 0.5 * this.getFilmHeight() / e2;
  this.fov = 2 * i.RAD2DEG * Math.atan(t2), this.updateProjectionMatrix();
}, getFocalLength: function() {
  const e2 = Math.tan(0.5 * i.DEG2RAD * this.fov);
  return 0.5 * this.getFilmHeight() / e2;
}, getEffectiveFOV: function() {
  return 2 * i.RAD2DEG * Math.atan(Math.tan(0.5 * i.DEG2RAD * this.fov) / this.zoom);
}, getFilmWidth: function() {
  return this.filmGauge * Math.min(this.aspect, 1);
}, getFilmHeight: function() {
  return this.filmGauge / Math.max(this.aspect, 1);
}, setViewOffset: function(e2, t2, n2, i2, r2, a2) {
  this.aspect = e2 / t2, null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r2, this.view.height = a2, this.updateProjectionMatrix();
}, clearViewOffset: function() {
  null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
}, updateProjectionMatrix: function() {
  const e2 = this.near;
  let t2 = e2 * Math.tan(0.5 * i.DEG2RAD * this.fov) / this.zoom, n2 = 2 * t2, r2 = this.aspect * n2, a2 = -0.5 * r2;
  const o2 = this.view;
  if (null !== this.view && this.view.enabled) {
    const e3 = o2.fullWidth, i2 = o2.fullHeight;
    a2 += o2.offsetX * r2 / e3, t2 -= o2.offsetY * n2 / i2, r2 *= o2.width / e3, n2 *= o2.height / i2;
  }
  const s2 = this.filmOffset;
  0 !== s2 && (a2 += e2 * s2 / this.getFilmWidth()), this.projectionMatrix.makePerspective(a2, a2 + r2, t2, t2 - n2, e2, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
}, toJSON: function(e2) {
  const t2 = ge.prototype.toJSON.call(this, e2);
  return t2.object.fov = this.fov, t2.object.zoom = this.zoom, t2.object.near = this.near, t2.object.far = this.far, t2.object.focus = this.focus, t2.object.aspect = this.aspect, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2.object.filmGauge = this.filmGauge, t2.object.filmOffset = this.filmOffset, t2;
} });
var Ut = class extends ge {
  constructor(e2, t2, n2) {
    if (super(), this.type = "CubeCamera", true !== n2.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
    this.renderTarget = n2;
    const i2 = new Ot(90, 1, e2, t2);
    i2.layers = this.layers, i2.up.set(0, -1, 0), i2.lookAt(new f(1, 0, 0)), this.add(i2);
    const r2 = new Ot(90, 1, e2, t2);
    r2.layers = this.layers, r2.up.set(0, -1, 0), r2.lookAt(new f(-1, 0, 0)), this.add(r2);
    const a2 = new Ot(90, 1, e2, t2);
    a2.layers = this.layers, a2.up.set(0, 0, 1), a2.lookAt(new f(0, 1, 0)), this.add(a2);
    const o2 = new Ot(90, 1, e2, t2);
    o2.layers = this.layers, o2.up.set(0, 0, -1), o2.lookAt(new f(0, -1, 0)), this.add(o2);
    const s2 = new Ot(90, 1, e2, t2);
    s2.layers = this.layers, s2.up.set(0, -1, 0), s2.lookAt(new f(0, 0, 1)), this.add(s2);
    const l2 = new Ot(90, 1, e2, t2);
    l2.layers = this.layers, l2.up.set(0, -1, 0), l2.lookAt(new f(0, 0, -1)), this.add(l2);
  }
  update(e2, t2) {
    null === this.parent && this.updateMatrixWorld();
    const n2 = this.renderTarget, [i2, r2, a2, o2, s2, l2] = this.children, c2 = e2.xr.enabled, h2 = e2.getRenderTarget();
    e2.xr.enabled = false;
    const u2 = n2.texture.generateMipmaps;
    n2.texture.generateMipmaps = false, e2.setRenderTarget(n2, 0), e2.render(t2, i2), e2.setRenderTarget(n2, 1), e2.render(t2, r2), e2.setRenderTarget(n2, 2), e2.render(t2, a2), e2.setRenderTarget(n2, 3), e2.render(t2, o2), e2.setRenderTarget(n2, 4), e2.render(t2, s2), n2.texture.generateMipmaps = u2, e2.setRenderTarget(n2, 5), e2.render(t2, l2), e2.setRenderTarget(h2), e2.xr.enabled = c2;
  }
};
var Ft = class extends c {
  constructor(e2, t2, n2, i2, r2, a2, o2, s2, l2, c2) {
    super(e2 = void 0 !== e2 ? e2 : [], t2 = void 0 !== t2 ? t2 : 301, n2, i2, r2, a2, o2 = void 0 !== o2 ? o2 : 1022, s2, l2, c2), this._needsFlipEnvMap = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(e2) {
    this.image = e2;
  }
};
Ft.prototype.isCubeTexture = true;
var Ht = class extends d {
  constructor(e2, t2, n2) {
    Number.isInteger(t2) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), t2 = n2), super(e2, e2, t2), t2 = t2 || {}, this.texture = new Ft(void 0, t2.mapping, t2.wrapS, t2.wrapT, t2.magFilter, t2.minFilter, t2.format, t2.type, t2.anisotropy, t2.encoding), this.texture.generateMipmaps = void 0 !== t2.generateMipmaps && t2.generateMipmaps, this.texture.minFilter = void 0 !== t2.minFilter ? t2.minFilter : 1006, this.texture._needsFlipEnvMap = false;
  }
  fromEquirectangularTexture(e2, t2) {
    this.texture.type = t2.type, this.texture.format = 1023, this.texture.encoding = t2.encoding, this.texture.generateMipmaps = t2.generateMipmaps, this.texture.minFilter = t2.minFilter, this.texture.magFilter = t2.magFilter;
    const n2 = { uniforms: { tEquirect: { value: null } }, vertexShader: "\n\n				varying vec3 vWorldDirection;\n\n				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n				}\n\n				void main() {\n\n					vWorldDirection = transformDirection( position, modelMatrix );\n\n					#include <begin_vertex>\n					#include <project_vertex>\n\n				}\n			", fragmentShader: "\n\n				uniform sampler2D tEquirect;\n\n				varying vec3 vWorldDirection;\n\n				#include <common>\n\n				void main() {\n\n					vec3 direction = normalize( vWorldDirection );\n\n					vec2 sampleUV = equirectUv( direction );\n\n					gl_FragColor = texture2D( tEquirect, sampleUV );\n\n				}\n			" }, i2 = new At(5, 5, 5), r2 = new It({ name: "CubemapFromEquirect", uniforms: Pt(n2.uniforms), vertexShader: n2.vertexShader, fragmentShader: n2.fragmentShader, side: 1, blending: 0 });
    r2.uniforms.tEquirect.value = t2;
    const a2 = new Lt(i2, r2), o2 = t2.minFilter;
    1008 === t2.minFilter && (t2.minFilter = 1006);
    return new Ut(1, 10, this).update(e2, a2), t2.minFilter = o2, a2.geometry.dispose(), a2.material.dispose(), this;
  }
  clear(e2, t2, n2, i2) {
    const r2 = e2.getRenderTarget();
    for (let a2 = 0; a2 < 6; a2++) e2.setRenderTarget(this, a2), e2.clear(t2, n2, i2);
    e2.setRenderTarget(r2);
  }
};
Ht.prototype.isWebGLCubeRenderTarget = true;
var zt = class extends c {
  constructor(e2, t2, n2, i2, r2, a2, o2, s2, l2, c2, h2, u2) {
    super(null, a2, o2, s2, l2, c2, i2, r2, h2, u2), this.image = { data: e2 || null, width: t2 || 1, height: n2 || 1 }, this.magFilter = void 0 !== l2 ? l2 : 1003, this.minFilter = void 0 !== c2 ? c2 : 1003, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
  }
};
zt.prototype.isDataTexture = true;
var Bt = new U();
var Gt = new f();
var kt = class {
  constructor(e2 = new _e(), t2 = new _e(), n2 = new _e(), i2 = new _e(), r2 = new _e(), a2 = new _e()) {
    this.planes = [e2, t2, n2, i2, r2, a2];
  }
  set(e2, t2, n2, i2, r2, a2) {
    const o2 = this.planes;
    return o2[0].copy(e2), o2[1].copy(t2), o2[2].copy(n2), o2[3].copy(i2), o2[4].copy(r2), o2[5].copy(a2), this;
  }
  copy(e2) {
    const t2 = this.planes;
    for (let n2 = 0; n2 < 6; n2++) t2[n2].copy(e2.planes[n2]);
    return this;
  }
  setFromProjectionMatrix(e2) {
    const t2 = this.planes, n2 = e2.elements, i2 = n2[0], r2 = n2[1], a2 = n2[2], o2 = n2[3], s2 = n2[4], l2 = n2[5], c2 = n2[6], h2 = n2[7], u2 = n2[8], d2 = n2[9], p2 = n2[10], f2 = n2[11], m2 = n2[12], g2 = n2[13], v2 = n2[14], x2 = n2[15];
    return t2[0].setComponents(o2 - i2, h2 - s2, f2 - u2, x2 - m2).normalize(), t2[1].setComponents(o2 + i2, h2 + s2, f2 + u2, x2 + m2).normalize(), t2[2].setComponents(o2 + r2, h2 + l2, f2 + d2, x2 + g2).normalize(), t2[3].setComponents(o2 - r2, h2 - l2, f2 - d2, x2 - g2).normalize(), t2[4].setComponents(o2 - a2, h2 - c2, f2 - p2, x2 - v2).normalize(), t2[5].setComponents(o2 + a2, h2 + c2, f2 + p2, x2 + v2).normalize(), this;
  }
  intersectsObject(e2) {
    const t2 = e2.geometry;
    return null === t2.boundingSphere && t2.computeBoundingSphere(), Bt.copy(t2.boundingSphere).applyMatrix4(e2.matrixWorld), this.intersectsSphere(Bt);
  }
  intersectsSprite(e2) {
    return Bt.center.set(0, 0, 0), Bt.radius = 0.7071067811865476, Bt.applyMatrix4(e2.matrixWorld), this.intersectsSphere(Bt);
  }
  intersectsSphere(e2) {
    const t2 = this.planes, n2 = e2.center, i2 = -e2.radius;
    for (let r2 = 0; r2 < 6; r2++) {
      if (t2[r2].distanceToPoint(n2) < i2) return false;
    }
    return true;
  }
  intersectsBox(e2) {
    const t2 = this.planes;
    for (let n2 = 0; n2 < 6; n2++) {
      const i2 = t2[n2];
      if (Gt.x = i2.normal.x > 0 ? e2.max.x : e2.min.x, Gt.y = i2.normal.y > 0 ? e2.max.y : e2.min.y, Gt.z = i2.normal.z > 0 ? e2.max.z : e2.min.z, i2.distanceToPoint(Gt) < 0) return false;
    }
    return true;
  }
  containsPoint(e2) {
    const t2 = this.planes;
    for (let n2 = 0; n2 < 6; n2++) if (t2[n2].distanceToPoint(e2) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function Vt() {
  let e2 = null, t2 = false, n2 = null, i2 = null;
  function r2(t3, a2) {
    n2(t3, a2), i2 = e2.requestAnimationFrame(r2);
  }
  return { start: function() {
    true !== t2 && null !== n2 && (i2 = e2.requestAnimationFrame(r2), t2 = true);
  }, stop: function() {
    e2.cancelAnimationFrame(i2), t2 = false;
  }, setAnimationLoop: function(e3) {
    n2 = e3;
  }, setContext: function(t3) {
    e2 = t3;
  } };
}
function Wt(e2, t2) {
  const n2 = t2.isWebGL2, i2 = /* @__PURE__ */ new WeakMap();
  return { get: function(e3) {
    return e3.isInterleavedBufferAttribute && (e3 = e3.data), i2.get(e3);
  }, remove: function(t3) {
    t3.isInterleavedBufferAttribute && (t3 = t3.data);
    const n3 = i2.get(t3);
    n3 && (e2.deleteBuffer(n3.buffer), i2.delete(t3));
  }, update: function(t3, r2) {
    if (t3.isGLBufferAttribute) {
      const e3 = i2.get(t3);
      return void ((!e3 || e3.version < t3.version) && i2.set(t3, { buffer: t3.buffer, type: t3.type, bytesPerElement: t3.elementSize, version: t3.version }));
    }
    t3.isInterleavedBufferAttribute && (t3 = t3.data);
    const a2 = i2.get(t3);
    void 0 === a2 ? i2.set(t3, function(t4, i3) {
      const r3 = t4.array, a3 = t4.usage, o2 = e2.createBuffer();
      e2.bindBuffer(i3, o2), e2.bufferData(i3, r3, a3), t4.onUploadCallback();
      let s2 = 5126;
      return r3 instanceof Float32Array ? s2 = 5126 : r3 instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r3 instanceof Uint16Array ? t4.isFloat16BufferAttribute ? n2 ? s2 = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : s2 = 5123 : r3 instanceof Int16Array ? s2 = 5122 : r3 instanceof Uint32Array ? s2 = 5125 : r3 instanceof Int32Array ? s2 = 5124 : r3 instanceof Int8Array ? s2 = 5120 : r3 instanceof Uint8Array && (s2 = 5121), { buffer: o2, type: s2, bytesPerElement: r3.BYTES_PER_ELEMENT, version: t4.version };
    }(t3, r2)) : a2.version < t3.version && (!function(t4, i3, r3) {
      const a3 = i3.array, o2 = i3.updateRange;
      e2.bindBuffer(r3, t4), -1 === o2.count ? e2.bufferSubData(r3, 0, a3) : (n2 ? e2.bufferSubData(r3, o2.offset * a3.BYTES_PER_ELEMENT, a3, o2.offset, o2.count) : e2.bufferSubData(r3, o2.offset * a3.BYTES_PER_ELEMENT, a3.subarray(o2.offset, o2.offset + o2.count)), o2.count = -1);
    }(a2.buffer, t3, r2), a2.version = t3.version);
  } };
}
var jt = class extends ct {
  constructor(e2 = 1, t2 = 1, n2 = 1, i2 = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e2, height: t2, widthSegments: n2, heightSegments: i2 };
    const r2 = e2 / 2, a2 = t2 / 2, o2 = Math.floor(n2), s2 = Math.floor(i2), l2 = o2 + 1, c2 = s2 + 1, h2 = e2 / o2, u2 = t2 / s2, d2 = [], p2 = [], f2 = [], m2 = [];
    for (let g2 = 0; g2 < c2; g2++) {
      const e3 = g2 * u2 - a2;
      for (let t3 = 0; t3 < l2; t3++) {
        const n3 = t3 * h2 - r2;
        p2.push(n3, -e3, 0), f2.push(0, 0, 1), m2.push(t3 / o2), m2.push(1 - g2 / s2);
      }
    }
    for (let g2 = 0; g2 < s2; g2++) for (let e3 = 0; e3 < o2; e3++) {
      const t3 = e3 + l2 * g2, n3 = e3 + l2 * (g2 + 1), i3 = e3 + 1 + l2 * (g2 + 1), r3 = e3 + 1 + l2 * g2;
      d2.push(t3, n3, r3), d2.push(n3, i3, r3);
    }
    this.setIndex(d2), this.setAttribute("position", new $e(p2, 3)), this.setAttribute("normal", new $e(f2, 3)), this.setAttribute("uv", new $e(m2, 2));
  }
};
var qt = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n	return Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + viewDir );\n	float dotNL = saturate( dot( normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n	float invAlpha = 1.0 / roughness;\n	float cos2h = NoH * NoH;\n	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n	vec3 N = geometry.normal;\n	vec3 V = geometry.viewDir;\n	vec3 H = normalize( V + L );\n	float dotNH = saturate( dot( N, H ) );\n	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif", color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif", color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif", color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif", common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		envColor = envMapTexelToLinear( envColor );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif", envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif", envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float sigma = PI * roughness * roughness / ( 1.0 + roughness );\n		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n		#else\n			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n	fogDepth = - mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n	varying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}", lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif", lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif", lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;", lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheen;\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float specularRoughness;\n	vec3 specularColor;\n#ifdef CLEARCOAT\n	float clearcoat;\n	float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	vec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifdef CLEARCOAT\n		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = ccDotNL * directLight.color;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			ccIrradiance *= PI;\n		#endif\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n			material.specularRoughness,\n			directLight.direction,\n			geometry,\n			material.sheenColor\n		);\n	#else\n		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n	#endif\n	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef CLEARCOAT\n		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n		float ccDotNL = ccDotNV;\n		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n	#else\n		float clearcoatDHR = 0.0;\n	#endif\n	float clearcoatInv = 1.0 - clearcoatDHR;\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n	#ifdef CLEARCOAT\n		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n	#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif", map_fragment: "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif", map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif", map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifndef USE_MORPHNORMALS\n		uniform float morphTargetInfluences[ 8 ];\n	#else\n		uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n	transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n	transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n	transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n		transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n		transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n		transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n		transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n	#endif\n#endif", normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;", normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif", clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif", clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif", clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }", transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n	totalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif", transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n	uniform sampler2D transmissionMap;\n#endif", uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif", uv_pars_vertex: "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif", uv_vertex: "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n	\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}", meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define REFLECTIVITY\n	#define CLEARCOAT\n	#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n	uniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n	uniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#ifdef TRANSMISSION\n		float totalTransmission = transmission;\n	#endif\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <transmissionmap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#ifdef TRANSMISSION\n		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n	#endif\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}", meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}" };
var Xt = { common: { diffuse: { value: new Be(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new a() }, uv2Transform: { value: new a() }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new r(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Be(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Be(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new a() } }, sprite: { diffuse: { value: new Be(15658734) }, opacity: { value: 1 }, center: { value: new r(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, uvTransform: { value: new a() } } };
var Yt = { basic: { uniforms: Ct([Xt.common, Xt.specularmap, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.fog]), vertexShader: qt.meshbasic_vert, fragmentShader: qt.meshbasic_frag }, lambert: { uniforms: Ct([Xt.common, Xt.specularmap, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.fog, Xt.lights, { emissive: { value: new Be(0) } }]), vertexShader: qt.meshlambert_vert, fragmentShader: qt.meshlambert_frag }, phong: { uniforms: Ct([Xt.common, Xt.specularmap, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.fog, Xt.lights, { emissive: { value: new Be(0) }, specular: { value: new Be(1118481) }, shininess: { value: 30 } }]), vertexShader: qt.meshphong_vert, fragmentShader: qt.meshphong_frag }, standard: { uniforms: Ct([Xt.common, Xt.envmap, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.roughnessmap, Xt.metalnessmap, Xt.fog, Xt.lights, { emissive: { value: new Be(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: qt.meshphysical_vert, fragmentShader: qt.meshphysical_frag }, toon: { uniforms: Ct([Xt.common, Xt.aomap, Xt.lightmap, Xt.emissivemap, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.gradientmap, Xt.fog, Xt.lights, { emissive: { value: new Be(0) } }]), vertexShader: qt.meshtoon_vert, fragmentShader: qt.meshtoon_frag }, matcap: { uniforms: Ct([Xt.common, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, Xt.fog, { matcap: { value: null } }]), vertexShader: qt.meshmatcap_vert, fragmentShader: qt.meshmatcap_frag }, points: { uniforms: Ct([Xt.points, Xt.fog]), vertexShader: qt.points_vert, fragmentShader: qt.points_frag }, dashed: { uniforms: Ct([Xt.common, Xt.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: qt.linedashed_vert, fragmentShader: qt.linedashed_frag }, depth: { uniforms: Ct([Xt.common, Xt.displacementmap]), vertexShader: qt.depth_vert, fragmentShader: qt.depth_frag }, normal: { uniforms: Ct([Xt.common, Xt.bumpmap, Xt.normalmap, Xt.displacementmap, { opacity: { value: 1 } }]), vertexShader: qt.normal_vert, fragmentShader: qt.normal_frag }, sprite: { uniforms: Ct([Xt.sprite, Xt.fog]), vertexShader: qt.sprite_vert, fragmentShader: qt.sprite_frag }, background: { uniforms: { uvTransform: { value: new a() }, t2D: { value: null } }, vertexShader: qt.background_vert, fragmentShader: qt.background_frag }, cube: { uniforms: Ct([Xt.envmap, { opacity: { value: 1 } }]), vertexShader: qt.cube_vert, fragmentShader: qt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: qt.equirect_vert, fragmentShader: qt.equirect_frag }, distanceRGBA: { uniforms: Ct([Xt.common, Xt.displacementmap, { referencePosition: { value: new f() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: qt.distanceRGBA_vert, fragmentShader: qt.distanceRGBA_frag }, shadow: { uniforms: Ct([Xt.lights, Xt.fog, { color: { value: new Be(0) }, opacity: { value: 1 } }]), vertexShader: qt.shadow_vert, fragmentShader: qt.shadow_frag } };
function Zt(e2, t2, n2, i2, r2) {
  const a2 = new Be(0);
  let o2, s2, l2 = 0, c2 = null, h2 = 0, u2 = null;
  function d2(e3, t3) {
    n2.buffers.color.setClear(e3.r, e3.g, e3.b, t3, r2);
  }
  return { getClearColor: function() {
    return a2;
  }, setClearColor: function(e3, t3 = 1) {
    a2.set(e3), l2 = t3, d2(a2, l2);
  }, getClearAlpha: function() {
    return l2;
  }, setClearAlpha: function(e3) {
    l2 = e3, d2(a2, l2);
  }, render: function(n3, r3, p2, f2) {
    let m2 = true === r3.isScene ? r3.background : null;
    m2 && m2.isTexture && (m2 = t2.get(m2));
    const g2 = e2.xr, v2 = g2.getSession && g2.getSession();
    v2 && "additive" === v2.environmentBlendMode && (m2 = null), null === m2 ? d2(a2, l2) : m2 && m2.isColor && (d2(m2, 1), f2 = true), (e2.autoClear || f2) && e2.clear(e2.autoClearColor, e2.autoClearDepth, e2.autoClearStencil), m2 && (m2.isCubeTexture || 306 === m2.mapping) ? (void 0 === s2 && (s2 = new Lt(new At(1, 1, 1), new It({ name: "BackgroundCubeMaterial", uniforms: Pt(Yt.cube.uniforms), vertexShader: Yt.cube.vertexShader, fragmentShader: Yt.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), s2.geometry.deleteAttribute("normal"), s2.geometry.deleteAttribute("uv"), s2.onBeforeRender = function(e3, t3, n4) {
      this.matrixWorld.copyPosition(n4.matrixWorld);
    }, Object.defineProperty(s2.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), i2.update(s2)), s2.material.uniforms.envMap.value = m2, s2.material.uniforms.flipEnvMap.value = m2.isCubeTexture && m2._needsFlipEnvMap ? -1 : 1, c2 === m2 && h2 === m2.version && u2 === e2.toneMapping || (s2.material.needsUpdate = true, c2 = m2, h2 = m2.version, u2 = e2.toneMapping), n3.unshift(s2, s2.geometry, s2.material, 0, 0, null)) : m2 && m2.isTexture && (void 0 === o2 && (o2 = new Lt(new jt(2, 2), new It({ name: "BackgroundMaterial", uniforms: Pt(Yt.background.uniforms), vertexShader: Yt.background.vertexShader, fragmentShader: Yt.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), o2.geometry.deleteAttribute("normal"), Object.defineProperty(o2.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), i2.update(o2)), o2.material.uniforms.t2D.value = m2, true === m2.matrixAutoUpdate && m2.updateMatrix(), o2.material.uniforms.uvTransform.value.copy(m2.matrix), c2 === m2 && h2 === m2.version && u2 === e2.toneMapping || (o2.material.needsUpdate = true, c2 = m2, h2 = m2.version, u2 = e2.toneMapping), n3.unshift(o2, o2.geometry, o2.material, 0, 0, null));
  } };
}
function Jt(e2, t2, n2, i2) {
  const r2 = e2.getParameter(34921), a2 = i2.isWebGL2 ? null : t2.get("OES_vertex_array_object"), o2 = i2.isWebGL2 || null !== a2, s2 = {}, l2 = d2(null);
  let c2 = l2;
  function h2(t3) {
    return i2.isWebGL2 ? e2.bindVertexArray(t3) : a2.bindVertexArrayOES(t3);
  }
  function u2(t3) {
    return i2.isWebGL2 ? e2.deleteVertexArray(t3) : a2.deleteVertexArrayOES(t3);
  }
  function d2(e3) {
    const t3 = [], n3 = [], i3 = [];
    for (let a3 = 0; a3 < r2; a3++) t3[a3] = 0, n3[a3] = 0, i3[a3] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: t3, enabledAttributes: n3, attributeDivisors: i3, object: e3, attributes: {}, index: null };
  }
  function p2() {
    const e3 = c2.newAttributes;
    for (let t3 = 0, n3 = e3.length; t3 < n3; t3++) e3[t3] = 0;
  }
  function f2(e3) {
    m2(e3, 0);
  }
  function m2(n3, r3) {
    const a3 = c2.newAttributes, o3 = c2.enabledAttributes, s3 = c2.attributeDivisors;
    if (a3[n3] = 1, 0 === o3[n3] && (e2.enableVertexAttribArray(n3), o3[n3] = 1), s3[n3] !== r3) {
      (i2.isWebGL2 ? e2 : t2.get("ANGLE_instanced_arrays"))[i2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n3, r3), s3[n3] = r3;
    }
  }
  function g2() {
    const t3 = c2.newAttributes, n3 = c2.enabledAttributes;
    for (let i3 = 0, r3 = n3.length; i3 < r3; i3++) n3[i3] !== t3[i3] && (e2.disableVertexAttribArray(i3), n3[i3] = 0);
  }
  function v2(t3, n3, r3, a3, o3, s3) {
    true !== i2.isWebGL2 || 5124 !== r3 && 5125 !== r3 ? e2.vertexAttribPointer(t3, n3, r3, a3, o3, s3) : e2.vertexAttribIPointer(t3, n3, r3, o3, s3);
  }
  function x2() {
    y2(), c2 !== l2 && (c2 = l2, h2(c2.object));
  }
  function y2() {
    l2.geometry = null, l2.program = null, l2.wireframe = false;
  }
  return { setup: function(r3, l3, u3, x3, y3) {
    let _2 = false;
    if (o2) {
      const t3 = function(t4, n3, r4) {
        const o3 = true === r4.wireframe;
        let l4 = s2[t4.id];
        void 0 === l4 && (l4 = {}, s2[t4.id] = l4);
        let c3 = l4[n3.id];
        void 0 === c3 && (c3 = {}, l4[n3.id] = c3);
        let h3 = c3[o3];
        void 0 === h3 && (h3 = d2(i2.isWebGL2 ? e2.createVertexArray() : a2.createVertexArrayOES()), c3[o3] = h3);
        return h3;
      }(x3, u3, l3);
      c2 !== t3 && (c2 = t3, h2(c2.object)), _2 = function(e3, t4) {
        const n3 = c2.attributes, i3 = e3.attributes;
        let r4 = 0;
        for (const a3 in i3) {
          const e4 = n3[a3], t5 = i3[a3];
          if (void 0 === e4) return true;
          if (e4.attribute !== t5) return true;
          if (e4.data !== t5.data) return true;
          r4++;
        }
        return c2.attributesNum !== r4 || c2.index !== t4;
      }(x3, y3), _2 && function(e3, t4) {
        const n3 = {}, i3 = e3.attributes;
        let r4 = 0;
        for (const a3 in i3) {
          const e4 = i3[a3], t5 = {};
          t5.attribute = e4, e4.data && (t5.data = e4.data), n3[a3] = t5, r4++;
        }
        c2.attributes = n3, c2.attributesNum = r4, c2.index = t4;
      }(x3, y3);
    } else {
      const e3 = true === l3.wireframe;
      c2.geometry === x3.id && c2.program === u3.id && c2.wireframe === e3 || (c2.geometry = x3.id, c2.program = u3.id, c2.wireframe = e3, _2 = true);
    }
    true === r3.isInstancedMesh && (_2 = true), null !== y3 && n2.update(y3, 34963), _2 && (!function(r4, a3, o3, s3) {
      if (false === i2.isWebGL2 && (r4.isInstancedMesh || s3.isInstancedBufferGeometry) && null === t2.get("ANGLE_instanced_arrays")) return;
      p2();
      const l4 = s3.attributes, c3 = o3.getAttributes(), h3 = a3.defaultAttributeValues;
      for (const t3 in c3) {
        const i3 = c3[t3];
        if (i3 >= 0) {
          const a4 = l4[t3];
          if (void 0 !== a4) {
            const t4 = a4.normalized, r5 = a4.itemSize, o4 = n2.get(a4);
            if (void 0 === o4) continue;
            const l5 = o4.buffer, c4 = o4.type, h4 = o4.bytesPerElement;
            if (a4.isInterleavedBufferAttribute) {
              const n3 = a4.data, o5 = n3.stride, u4 = a4.offset;
              n3 && n3.isInstancedInterleavedBuffer ? (m2(i3, n3.meshPerAttribute), void 0 === s3._maxInstanceCount && (s3._maxInstanceCount = n3.meshPerAttribute * n3.count)) : f2(i3), e2.bindBuffer(34962, l5), v2(i3, r5, c4, t4, o5 * h4, u4 * h4);
            } else a4.isInstancedBufferAttribute ? (m2(i3, a4.meshPerAttribute), void 0 === s3._maxInstanceCount && (s3._maxInstanceCount = a4.meshPerAttribute * a4.count)) : f2(i3), e2.bindBuffer(34962, l5), v2(i3, r5, c4, t4, 0, 0);
          } else if ("instanceMatrix" === t3) {
            const t4 = n2.get(r4.instanceMatrix);
            if (void 0 === t4) continue;
            const a5 = t4.buffer, o4 = t4.type;
            m2(i3 + 0, 1), m2(i3 + 1, 1), m2(i3 + 2, 1), m2(i3 + 3, 1), e2.bindBuffer(34962, a5), e2.vertexAttribPointer(i3 + 0, 4, o4, false, 64, 0), e2.vertexAttribPointer(i3 + 1, 4, o4, false, 64, 16), e2.vertexAttribPointer(i3 + 2, 4, o4, false, 64, 32), e2.vertexAttribPointer(i3 + 3, 4, o4, false, 64, 48);
          } else if ("instanceColor" === t3) {
            const t4 = n2.get(r4.instanceColor);
            if (void 0 === t4) continue;
            const a5 = t4.buffer, o4 = t4.type;
            m2(i3, 1), e2.bindBuffer(34962, a5), e2.vertexAttribPointer(i3, 3, o4, false, 12, 0);
          } else if (void 0 !== h3) {
            const n3 = h3[t3];
            if (void 0 !== n3) switch (n3.length) {
              case 2:
                e2.vertexAttrib2fv(i3, n3);
                break;
              case 3:
                e2.vertexAttrib3fv(i3, n3);
                break;
              case 4:
                e2.vertexAttrib4fv(i3, n3);
                break;
              default:
                e2.vertexAttrib1fv(i3, n3);
            }
          }
        }
      }
      g2();
    }(r3, l3, u3, x3), null !== y3 && e2.bindBuffer(34963, n2.get(y3).buffer));
  }, reset: x2, resetDefaultState: y2, dispose: function() {
    x2();
    for (const e3 in s2) {
      const t3 = s2[e3];
      for (const e4 in t3) {
        const n3 = t3[e4];
        for (const e5 in n3) u2(n3[e5].object), delete n3[e5];
        delete t3[e4];
      }
      delete s2[e3];
    }
  }, releaseStatesOfGeometry: function(e3) {
    if (void 0 === s2[e3.id]) return;
    const t3 = s2[e3.id];
    for (const n3 in t3) {
      const e4 = t3[n3];
      for (const t4 in e4) u2(e4[t4].object), delete e4[t4];
      delete t3[n3];
    }
    delete s2[e3.id];
  }, releaseStatesOfProgram: function(e3) {
    for (const t3 in s2) {
      const n3 = s2[t3];
      if (void 0 === n3[e3.id]) continue;
      const i3 = n3[e3.id];
      for (const e4 in i3) u2(i3[e4].object), delete i3[e4];
      delete n3[e3.id];
    }
  }, initAttributes: p2, enableAttribute: f2, disableUnusedAttributes: g2 };
}
function Kt(e2, t2, n2, i2) {
  const r2 = i2.isWebGL2;
  let a2;
  this.setMode = function(e3) {
    a2 = e3;
  }, this.render = function(t3, i3) {
    e2.drawArrays(a2, t3, i3), n2.update(i3, a2, 1);
  }, this.renderInstances = function(i3, o2, s2) {
    if (0 === s2) return;
    let l2, c2;
    if (r2) l2 = e2, c2 = "drawArraysInstanced";
    else if (l2 = t2.get("ANGLE_instanced_arrays"), c2 = "drawArraysInstancedANGLE", null === l2) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    l2[c2](a2, i3, o2, s2), n2.update(o2, a2, s2);
  };
}
function Qt(e2, t2, n2) {
  let i2;
  function r2(t3) {
    if ("highp" === t3) {
      if (e2.getShaderPrecisionFormat(35633, 36338).precision > 0 && e2.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
      t3 = "mediump";
    }
    return "mediump" === t3 && e2.getShaderPrecisionFormat(35633, 36337).precision > 0 && e2.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const a2 = "undefined" != typeof WebGL2RenderingContext && e2 instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e2 instanceof WebGL2ComputeRenderingContext;
  let o2 = void 0 !== n2.precision ? n2.precision : "highp";
  const s2 = r2(o2);
  s2 !== o2 && (console.warn("THREE.WebGLRenderer:", o2, "not supported, using", s2, "instead."), o2 = s2);
  const l2 = true === n2.logarithmicDepthBuffer, c2 = e2.getParameter(34930), h2 = e2.getParameter(35660), u2 = e2.getParameter(3379), d2 = e2.getParameter(34076), p2 = e2.getParameter(34921), f2 = e2.getParameter(36347), m2 = e2.getParameter(36348), g2 = e2.getParameter(36349), v2 = h2 > 0, x2 = a2 || t2.has("OES_texture_float");
  return { isWebGL2: a2, getMaxAnisotropy: function() {
    if (void 0 !== i2) return i2;
    if (true === t2.has("EXT_texture_filter_anisotropic")) {
      const n3 = t2.get("EXT_texture_filter_anisotropic");
      i2 = e2.getParameter(n3.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i2 = 0;
    return i2;
  }, getMaxPrecision: r2, precision: o2, logarithmicDepthBuffer: l2, maxTextures: c2, maxVertexTextures: h2, maxTextureSize: u2, maxCubemapSize: d2, maxAttributes: p2, maxVertexUniforms: f2, maxVaryings: m2, maxFragmentUniforms: g2, vertexTextures: v2, floatFragmentTextures: x2, floatVertexTextures: v2 && x2, maxSamples: a2 ? e2.getParameter(36183) : 0 };
}
function $t(e2) {
  const t2 = this;
  let n2 = null, i2 = 0, r2 = false, o2 = false;
  const s2 = new _e(), l2 = new a(), c2 = { value: null, needsUpdate: false };
  function h2() {
    c2.value !== n2 && (c2.value = n2, c2.needsUpdate = i2 > 0), t2.numPlanes = i2, t2.numIntersection = 0;
  }
  function u2(e3, n3, i3, r3) {
    const a2 = null !== e3 ? e3.length : 0;
    let o3 = null;
    if (0 !== a2) {
      if (o3 = c2.value, true !== r3 || null === o3) {
        const t3 = i3 + 4 * a2, r4 = n3.matrixWorldInverse;
        l2.getNormalMatrix(r4), (null === o3 || o3.length < t3) && (o3 = new Float32Array(t3));
        for (let n4 = 0, c3 = i3; n4 !== a2; ++n4, c3 += 4) s2.copy(e3[n4]).applyMatrix4(r4, l2), s2.normal.toArray(o3, c3), o3[c3 + 3] = s2.constant;
      }
      c2.value = o3, c2.needsUpdate = true;
    }
    return t2.numPlanes = a2, t2.numIntersection = 0, o3;
  }
  this.uniform = c2, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e3, t3, a2) {
    const o3 = 0 !== e3.length || t3 || 0 !== i2 || r2;
    return r2 = t3, n2 = u2(e3, a2, 0), i2 = e3.length, o3;
  }, this.beginShadows = function() {
    o2 = true, u2(null);
  }, this.endShadows = function() {
    o2 = false, h2();
  }, this.setState = function(t3, a2, s3) {
    const l3 = t3.clippingPlanes, d2 = t3.clipIntersection, p2 = t3.clipShadows, f2 = e2.get(t3);
    if (!r2 || null === l3 || 0 === l3.length || o2 && !p2) o2 ? u2(null) : h2();
    else {
      const e3 = o2 ? 0 : i2, t4 = 4 * e3;
      let r3 = f2.clippingState || null;
      c2.value = r3, r3 = u2(l3, a2, t4, s3);
      for (let i3 = 0; i3 !== t4; ++i3) r3[i3] = n2[i3];
      f2.clippingState = r3, this.numIntersection = d2 ? this.numPlanes : 0, this.numPlanes += e3;
    }
  };
}
function en(e2) {
  let t2 = /* @__PURE__ */ new WeakMap();
  function n2(e3, t3) {
    return 303 === t3 ? e3.mapping = 301 : 304 === t3 && (e3.mapping = 302), e3;
  }
  function i2(e3) {
    const n3 = e3.target;
    n3.removeEventListener("dispose", i2);
    const r2 = t2.get(n3);
    void 0 !== r2 && (t2.delete(n3), r2.dispose());
  }
  return { get: function(r2) {
    if (r2 && r2.isTexture) {
      const a2 = r2.mapping;
      if (303 === a2 || 304 === a2) {
        if (t2.has(r2)) {
          return n2(t2.get(r2).texture, r2.mapping);
        }
        {
          const a3 = r2.image;
          if (a3 && a3.height > 0) {
            const o2 = e2.getRenderTarget(), s2 = new Ht(a3.height / 2);
            return s2.fromEquirectangularTexture(e2, r2), t2.set(r2, s2), e2.setRenderTarget(o2), r2.addEventListener("dispose", i2), n2(s2.texture, r2.mapping);
          }
          return null;
        }
      }
    }
    return r2;
  }, dispose: function() {
    t2 = /* @__PURE__ */ new WeakMap();
  } };
}
function tn(e2) {
  const t2 = {};
  function n2(n3) {
    if (void 0 !== t2[n3]) return t2[n3];
    let i2;
    switch (n3) {
      case "WEBGL_depth_texture":
        i2 = e2.getExtension("WEBGL_depth_texture") || e2.getExtension("MOZ_WEBGL_depth_texture") || e2.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i2 = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i2 = e2.getExtension("WEBGL_compressed_texture_s3tc") || e2.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i2 = e2.getExtension("WEBGL_compressed_texture_pvrtc") || e2.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i2 = e2.getExtension(n3);
    }
    return t2[n3] = i2, i2;
  }
  return { has: function(e3) {
    return null !== n2(e3);
  }, init: function(e3) {
    e3.isWebGL2 ? n2("EXT_color_buffer_float") : (n2("WEBGL_depth_texture"), n2("OES_texture_float"), n2("OES_texture_half_float"), n2("OES_texture_half_float_linear"), n2("OES_standard_derivatives"), n2("OES_element_index_uint"), n2("OES_vertex_array_object"), n2("ANGLE_instanced_arrays")), n2("OES_texture_float_linear"), n2("EXT_color_buffer_half_float");
  }, get: function(e3) {
    const t3 = n2(e3);
    return null === t3 && console.warn("THREE.WebGLRenderer: " + e3 + " extension not supported."), t3;
  } };
}
function nn(e2, t2, n2, i2) {
  const r2 = {}, a2 = /* @__PURE__ */ new WeakMap();
  function o2(e3) {
    const s3 = e3.target;
    null !== s3.index && t2.remove(s3.index);
    for (const n3 in s3.attributes) t2.remove(s3.attributes[n3]);
    s3.removeEventListener("dispose", o2), delete r2[s3.id];
    const l2 = a2.get(s3);
    l2 && (t2.remove(l2), a2.delete(s3)), i2.releaseStatesOfGeometry(s3), true === s3.isInstancedBufferGeometry && delete s3._maxInstanceCount, n2.memory.geometries--;
  }
  function s2(e3) {
    const n3 = [], i3 = e3.index, r3 = e3.attributes.position;
    let o3 = 0;
    if (null !== i3) {
      const e4 = i3.array;
      o3 = i3.version;
      for (let t3 = 0, i4 = e4.length; t3 < i4; t3 += 3) {
        const i5 = e4[t3 + 0], r4 = e4[t3 + 1], a3 = e4[t3 + 2];
        n3.push(i5, r4, r4, a3, a3, i5);
      }
    } else {
      const e4 = r3.array;
      o3 = r3.version;
      for (let t3 = 0, i4 = e4.length / 3 - 1; t3 < i4; t3 += 3) {
        const e5 = t3 + 0, i5 = t3 + 1, r4 = t3 + 2;
        n3.push(e5, i5, i5, r4, r4, e5);
      }
    }
    const s3 = new (tt(n3) > 65535 ? Ke : Ze)(n3, 1);
    s3.version = o3;
    const l2 = a2.get(e3);
    l2 && t2.remove(l2), a2.set(e3, s3);
  }
  return { get: function(e3, t3) {
    return true === r2[t3.id] || (t3.addEventListener("dispose", o2), r2[t3.id] = true, n2.memory.geometries++), t3;
  }, update: function(e3) {
    const n3 = e3.attributes;
    for (const r3 in n3) t2.update(n3[r3], 34962);
    const i3 = e3.morphAttributes;
    for (const r3 in i3) {
      const e4 = i3[r3];
      for (let n4 = 0, i4 = e4.length; n4 < i4; n4++) t2.update(e4[n4], 34962);
    }
  }, getWireframeAttribute: function(e3) {
    const t3 = a2.get(e3);
    if (t3) {
      const n3 = e3.index;
      null !== n3 && t3.version < n3.version && s2(e3);
    } else s2(e3);
    return a2.get(e3);
  } };
}
function rn(e2, t2, n2, i2) {
  const r2 = i2.isWebGL2;
  let a2, o2, s2;
  this.setMode = function(e3) {
    a2 = e3;
  }, this.setIndex = function(e3) {
    o2 = e3.type, s2 = e3.bytesPerElement;
  }, this.render = function(t3, i3) {
    e2.drawElements(a2, i3, o2, t3 * s2), n2.update(i3, a2, 1);
  }, this.renderInstances = function(i3, l2, c2) {
    if (0 === c2) return;
    let h2, u2;
    if (r2) h2 = e2, u2 = "drawElementsInstanced";
    else if (h2 = t2.get("ANGLE_instanced_arrays"), u2 = "drawElementsInstancedANGLE", null === h2) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
    h2[u2](a2, l2, o2, i3 * s2, c2), n2.update(l2, a2, c2);
  };
}
function an(e2) {
  const t2 = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return { memory: { geometries: 0, textures: 0 }, render: t2, programs: null, autoReset: true, reset: function() {
    t2.frame++, t2.calls = 0, t2.triangles = 0, t2.points = 0, t2.lines = 0;
  }, update: function(e3, n2, i2) {
    switch (t2.calls++, n2) {
      case 4:
        t2.triangles += i2 * (e3 / 3);
        break;
      case 1:
        t2.lines += i2 * (e3 / 2);
        break;
      case 3:
        t2.lines += i2 * (e3 - 1);
        break;
      case 2:
        t2.lines += i2 * e3;
        break;
      case 0:
        t2.points += i2 * e3;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", n2);
    }
  } };
}
function on(e2, t2) {
  return e2[0] - t2[0];
}
function sn(e2, t2) {
  return Math.abs(t2[1]) - Math.abs(e2[1]);
}
function ln(e2) {
  const t2 = {}, n2 = new Float32Array(8), i2 = [];
  for (let r2 = 0; r2 < 8; r2++) i2[r2] = [r2, 0];
  return { update: function(r2, a2, o2, s2) {
    const l2 = r2.morphTargetInfluences, c2 = void 0 === l2 ? 0 : l2.length;
    let h2 = t2[a2.id];
    if (void 0 === h2) {
      h2 = [];
      for (let e3 = 0; e3 < c2; e3++) h2[e3] = [e3, 0];
      t2[a2.id] = h2;
    }
    for (let e3 = 0; e3 < c2; e3++) {
      const t3 = h2[e3];
      t3[0] = e3, t3[1] = l2[e3];
    }
    h2.sort(sn);
    for (let e3 = 0; e3 < 8; e3++) e3 < c2 && h2[e3][1] ? (i2[e3][0] = h2[e3][0], i2[e3][1] = h2[e3][1]) : (i2[e3][0] = Number.MAX_SAFE_INTEGER, i2[e3][1] = 0);
    i2.sort(on);
    const u2 = o2.morphTargets && a2.morphAttributes.position, d2 = o2.morphNormals && a2.morphAttributes.normal;
    let p2 = 0;
    for (let e3 = 0; e3 < 8; e3++) {
      const t3 = i2[e3], r3 = t3[0], o3 = t3[1];
      r3 !== Number.MAX_SAFE_INTEGER && o3 ? (u2 && a2.getAttribute("morphTarget" + e3) !== u2[r3] && a2.setAttribute("morphTarget" + e3, u2[r3]), d2 && a2.getAttribute("morphNormal" + e3) !== d2[r3] && a2.setAttribute("morphNormal" + e3, d2[r3]), n2[e3] = o3, p2 += o3) : (u2 && true === a2.hasAttribute("morphTarget" + e3) && a2.deleteAttribute("morphTarget" + e3), d2 && true === a2.hasAttribute("morphNormal" + e3) && a2.deleteAttribute("morphNormal" + e3), n2[e3] = 0);
    }
    const f2 = a2.morphTargetsRelative ? 1 : 1 - p2;
    s2.getUniforms().setValue(e2, "morphTargetBaseInfluence", f2), s2.getUniforms().setValue(e2, "morphTargetInfluences", n2);
  } };
}
function cn(e2, t2, n2, i2) {
  let r2 = /* @__PURE__ */ new WeakMap();
  function a2(e3) {
    const t3 = e3.target;
    t3.removeEventListener("dispose", a2), n2.remove(t3.instanceMatrix), null !== t3.instanceColor && n2.remove(t3.instanceColor);
  }
  return { update: function(e3) {
    const o2 = i2.render.frame, s2 = e3.geometry, l2 = t2.get(e3, s2);
    return r2.get(l2) !== o2 && (t2.update(l2), r2.set(l2, o2)), e3.isInstancedMesh && (false === e3.hasEventListener("dispose", a2) && e3.addEventListener("dispose", a2), n2.update(e3.instanceMatrix, 34962), null !== e3.instanceColor && n2.update(e3.instanceColor, 34962)), l2;
  }, dispose: function() {
    r2 = /* @__PURE__ */ new WeakMap();
  } };
}
Yt.physical = { uniforms: Ct([Yt.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new r(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: new Be(0) }, transmission: { value: 0 }, transmissionMap: { value: null } }]), vertexShader: qt.meshphysical_vert, fragmentShader: qt.meshphysical_frag };
var hn = class extends c {
  constructor(e2 = null, t2 = 1, n2 = 1, i2 = 1) {
    super(null), this.image = { data: e2, width: t2, height: n2, depth: i2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.needsUpdate = true;
  }
};
hn.prototype.isDataTexture2DArray = true;
var un = class extends c {
  constructor(e2 = null, t2 = 1, n2 = 1, i2 = 1) {
    super(null), this.image = { data: e2, width: t2, height: n2, depth: i2 }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.needsUpdate = true;
  }
};
un.prototype.isDataTexture3D = true;
var dn = new c();
var pn = new hn();
var fn = new un();
var mn = new Ft();
var gn = [];
var vn = [];
var xn = new Float32Array(16);
var yn = new Float32Array(9);
var _n = new Float32Array(4);
function bn(e2, t2, n2) {
  const i2 = e2[0];
  if (i2 <= 0 || i2 > 0) return e2;
  const r2 = t2 * n2;
  let a2 = gn[r2];
  if (void 0 === a2 && (a2 = new Float32Array(r2), gn[r2] = a2), 0 !== t2) {
    i2.toArray(a2, 0);
    for (let i3 = 1, r3 = 0; i3 !== t2; ++i3) r3 += n2, e2[i3].toArray(a2, r3);
  }
  return a2;
}
function wn(e2, t2) {
  if (e2.length !== t2.length) return false;
  for (let n2 = 0, i2 = e2.length; n2 < i2; n2++) if (e2[n2] !== t2[n2]) return false;
  return true;
}
function Mn(e2, t2) {
  for (let n2 = 0, i2 = t2.length; n2 < i2; n2++) e2[n2] = t2[n2];
}
function Sn(e2, t2) {
  let n2 = vn[t2];
  void 0 === n2 && (n2 = new Int32Array(t2), vn[t2] = n2);
  for (let i2 = 0; i2 !== t2; ++i2) n2[i2] = e2.allocateTextureUnit();
  return n2;
}
function Tn(e2, t2) {
  const n2 = this.cache;
  n2[0] !== t2 && (e2.uniform1f(this.addr, t2), n2[0] = t2);
}
function En(e2, t2) {
  const n2 = this.cache;
  if (void 0 !== t2.x) n2[0] === t2.x && n2[1] === t2.y || (e2.uniform2f(this.addr, t2.x, t2.y), n2[0] = t2.x, n2[1] = t2.y);
  else {
    if (wn(n2, t2)) return;
    e2.uniform2fv(this.addr, t2), Mn(n2, t2);
  }
}
function Ln(e2, t2) {
  const n2 = this.cache;
  if (void 0 !== t2.x) n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z || (e2.uniform3f(this.addr, t2.x, t2.y, t2.z), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z);
  else if (void 0 !== t2.r) n2[0] === t2.r && n2[1] === t2.g && n2[2] === t2.b || (e2.uniform3f(this.addr, t2.r, t2.g, t2.b), n2[0] = t2.r, n2[1] = t2.g, n2[2] = t2.b);
  else {
    if (wn(n2, t2)) return;
    e2.uniform3fv(this.addr, t2), Mn(n2, t2);
  }
}
function Rn(e2, t2) {
  const n2 = this.cache;
  if (void 0 !== t2.x) n2[0] === t2.x && n2[1] === t2.y && n2[2] === t2.z && n2[3] === t2.w || (e2.uniform4f(this.addr, t2.x, t2.y, t2.z, t2.w), n2[0] = t2.x, n2[1] = t2.y, n2[2] = t2.z, n2[3] = t2.w);
  else {
    if (wn(n2, t2)) return;
    e2.uniform4fv(this.addr, t2), Mn(n2, t2);
  }
}
function An(e2, t2) {
  const n2 = this.cache, i2 = t2.elements;
  if (void 0 === i2) {
    if (wn(n2, t2)) return;
    e2.uniformMatrix2fv(this.addr, false, t2), Mn(n2, t2);
  } else {
    if (wn(n2, i2)) return;
    _n.set(i2), e2.uniformMatrix2fv(this.addr, false, _n), Mn(n2, i2);
  }
}
function Pn(e2, t2) {
  const n2 = this.cache, i2 = t2.elements;
  if (void 0 === i2) {
    if (wn(n2, t2)) return;
    e2.uniformMatrix3fv(this.addr, false, t2), Mn(n2, t2);
  } else {
    if (wn(n2, i2)) return;
    yn.set(i2), e2.uniformMatrix3fv(this.addr, false, yn), Mn(n2, i2);
  }
}
function Cn(e2, t2) {
  const n2 = this.cache, i2 = t2.elements;
  if (void 0 === i2) {
    if (wn(n2, t2)) return;
    e2.uniformMatrix4fv(this.addr, false, t2), Mn(n2, t2);
  } else {
    if (wn(n2, i2)) return;
    xn.set(i2), e2.uniformMatrix4fv(this.addr, false, xn), Mn(n2, i2);
  }
}
function Dn(e2, t2) {
  const n2 = this.cache;
  n2[0] !== t2 && (e2.uniform1i(this.addr, t2), n2[0] = t2);
}
function In(e2, t2) {
  const n2 = this.cache;
  wn(n2, t2) || (e2.uniform2iv(this.addr, t2), Mn(n2, t2));
}
function Nn(e2, t2) {
  const n2 = this.cache;
  wn(n2, t2) || (e2.uniform3iv(this.addr, t2), Mn(n2, t2));
}
function On(e2, t2) {
  const n2 = this.cache;
  wn(n2, t2) || (e2.uniform4iv(this.addr, t2), Mn(n2, t2));
}
function Un(e2, t2) {
  const n2 = this.cache;
  n2[0] !== t2 && (e2.uniform1ui(this.addr, t2), n2[0] = t2);
}
function Fn(e2, t2) {
  const n2 = this.cache;
  wn(n2, t2) || (e2.uniform2uiv(this.addr, t2), Mn(n2, t2));
}
function Hn(e2, t2) {
  const n2 = this.cache;
  wn(n2, t2) || (e2.uniform3uiv(this.addr, t2), Mn(n2, t2));
}
function zn(e2, t2) {
  const n2 = this.cache;
  wn(n2, t2) || (e2.uniform4uiv(this.addr, t2), Mn(n2, t2));
}
function Bn(e2, t2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (e2.uniform1i(this.addr, r2), i2[0] = r2), n2.safeSetTexture2D(t2 || dn, r2);
}
function Gn(e2, t2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (e2.uniform1i(this.addr, r2), i2[0] = r2), n2.setTexture3D(t2 || fn, r2);
}
function kn(e2, t2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (e2.uniform1i(this.addr, r2), i2[0] = r2), n2.safeSetTextureCube(t2 || mn, r2);
}
function Vn(e2, t2, n2) {
  const i2 = this.cache, r2 = n2.allocateTextureUnit();
  i2[0] !== r2 && (e2.uniform1i(this.addr, r2), i2[0] = r2), n2.setTexture2DArray(t2 || pn, r2);
}
function Wn(e2, t2) {
  e2.uniform1fv(this.addr, t2);
}
function jn(e2, t2) {
  const n2 = bn(t2, this.size, 2);
  e2.uniform2fv(this.addr, n2);
}
function qn(e2, t2) {
  const n2 = bn(t2, this.size, 3);
  e2.uniform3fv(this.addr, n2);
}
function Xn(e2, t2) {
  const n2 = bn(t2, this.size, 4);
  e2.uniform4fv(this.addr, n2);
}
function Yn(e2, t2) {
  const n2 = bn(t2, this.size, 4);
  e2.uniformMatrix2fv(this.addr, false, n2);
}
function Zn(e2, t2) {
  const n2 = bn(t2, this.size, 9);
  e2.uniformMatrix3fv(this.addr, false, n2);
}
function Jn(e2, t2) {
  const n2 = bn(t2, this.size, 16);
  e2.uniformMatrix4fv(this.addr, false, n2);
}
function Kn(e2, t2) {
  e2.uniform1iv(this.addr, t2);
}
function Qn(e2, t2) {
  e2.uniform2iv(this.addr, t2);
}
function $n(e2, t2) {
  e2.uniform3iv(this.addr, t2);
}
function ei(e2, t2) {
  e2.uniform4iv(this.addr, t2);
}
function ti(e2, t2) {
  e2.uniform1uiv(this.addr, t2);
}
function ni(e2, t2) {
  e2.uniform2uiv(this.addr, t2);
}
function ii(e2, t2) {
  e2.uniform3uiv(this.addr, t2);
}
function ri(e2, t2) {
  e2.uniform4uiv(this.addr, t2);
}
function ai(e2, t2, n2) {
  const i2 = t2.length, r2 = Sn(n2, i2);
  e2.uniform1iv(this.addr, r2);
  for (let a2 = 0; a2 !== i2; ++a2) n2.safeSetTexture2D(t2[a2] || dn, r2[a2]);
}
function oi(e2, t2, n2) {
  const i2 = t2.length, r2 = Sn(n2, i2);
  e2.uniform1iv(this.addr, r2);
  for (let a2 = 0; a2 !== i2; ++a2) n2.safeSetTextureCube(t2[a2] || mn, r2[a2]);
}
function si(e2, t2, n2) {
  this.id = e2, this.addr = n2, this.cache = [], this.setValue = function(e3) {
    switch (e3) {
      case 5126:
        return Tn;
      case 35664:
        return En;
      case 35665:
        return Ln;
      case 35666:
        return Rn;
      case 35674:
        return An;
      case 35675:
        return Pn;
      case 35676:
        return Cn;
      case 5124:
      case 35670:
        return Dn;
      case 35667:
      case 35671:
        return In;
      case 35668:
      case 35672:
        return Nn;
      case 35669:
      case 35673:
        return On;
      case 5125:
        return Un;
      case 36294:
        return Fn;
      case 36295:
        return Hn;
      case 36296:
        return zn;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Bn;
      case 35679:
      case 36299:
      case 36307:
        return Gn;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return kn;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return Vn;
    }
  }(t2.type);
}
function li(e2, t2, n2) {
  this.id = e2, this.addr = n2, this.cache = [], this.size = t2.size, this.setValue = function(e3) {
    switch (e3) {
      case 5126:
        return Wn;
      case 35664:
        return jn;
      case 35665:
        return qn;
      case 35666:
        return Xn;
      case 35674:
        return Yn;
      case 35675:
        return Zn;
      case 35676:
        return Jn;
      case 5124:
      case 35670:
        return Kn;
      case 35667:
      case 35671:
        return Qn;
      case 35668:
      case 35672:
        return $n;
      case 35669:
      case 35673:
        return ei;
      case 5125:
        return ti;
      case 36294:
        return ni;
      case 36295:
        return ii;
      case 36296:
        return ri;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return ai;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return oi;
    }
  }(t2.type);
}
function ci(e2) {
  this.id = e2, this.seq = [], this.map = {};
}
li.prototype.updateCache = function(e2) {
  const t2 = this.cache;
  e2 instanceof Float32Array && t2.length !== e2.length && (this.cache = new Float32Array(e2.length)), Mn(t2, e2);
}, ci.prototype.setValue = function(e2, t2, n2) {
  const i2 = this.seq;
  for (let r2 = 0, a2 = i2.length; r2 !== a2; ++r2) {
    const a3 = i2[r2];
    a3.setValue(e2, t2[a3.id], n2);
  }
};
var hi = /(\w+)(\])?(\[|\.)?/g;
function ui(e2, t2) {
  e2.seq.push(t2), e2.map[t2.id] = t2;
}
function di(e2, t2, n2) {
  const i2 = e2.name, r2 = i2.length;
  for (hi.lastIndex = 0; ; ) {
    const a2 = hi.exec(i2), o2 = hi.lastIndex;
    let s2 = a2[1];
    const l2 = "]" === a2[2], c2 = a2[3];
    if (l2 && (s2 |= 0), void 0 === c2 || "[" === c2 && o2 + 2 === r2) {
      ui(n2, void 0 === c2 ? new si(s2, e2, t2) : new li(s2, e2, t2));
      break;
    }
    {
      let e3 = n2.map[s2];
      void 0 === e3 && (e3 = new ci(s2), ui(n2, e3)), n2 = e3;
    }
  }
}
function pi(e2, t2) {
  this.seq = [], this.map = {};
  const n2 = e2.getProgramParameter(t2, 35718);
  for (let i2 = 0; i2 < n2; ++i2) {
    const n3 = e2.getActiveUniform(t2, i2);
    di(n3, e2.getUniformLocation(t2, n3.name), this);
  }
}
function fi(e2, t2, n2) {
  const i2 = e2.createShader(t2);
  return e2.shaderSource(i2, n2), e2.compileShader(i2), i2;
}
pi.prototype.setValue = function(e2, t2, n2, i2) {
  const r2 = this.map[t2];
  void 0 !== r2 && r2.setValue(e2, n2, i2);
}, pi.prototype.setOptional = function(e2, t2, n2) {
  const i2 = t2[n2];
  void 0 !== i2 && this.setValue(e2, n2, i2);
}, pi.upload = function(e2, t2, n2, i2) {
  for (let r2 = 0, a2 = t2.length; r2 !== a2; ++r2) {
    const a3 = t2[r2], o2 = n2[a3.id];
    false !== o2.needsUpdate && a3.setValue(e2, o2.value, i2);
  }
}, pi.seqWithValue = function(e2, t2) {
  const n2 = [];
  for (let i2 = 0, r2 = e2.length; i2 !== r2; ++i2) {
    const r3 = e2[i2];
    r3.id in t2 && n2.push(r3);
  }
  return n2;
};
var mi = 0;
function gi(e2) {
  switch (e2) {
    case 3e3:
      return ["Linear", "( value )"];
    case 3001:
      return ["sRGB", "( value )"];
    case 3002:
      return ["RGBE", "( value )"];
    case 3004:
      return ["RGBM", "( value, 7.0 )"];
    case 3005:
      return ["RGBM", "( value, 16.0 )"];
    case 3006:
      return ["RGBD", "( value, 256.0 )"];
    case 3007:
      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
    case 3003:
      return ["LogLuv", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", e2), ["Linear", "( value )"];
  }
}
function vi(e2, t2, n2) {
  const i2 = e2.getShaderParameter(t2, 35713), r2 = e2.getShaderInfoLog(t2).trim();
  if (i2 && "" === r2) return "";
  return "THREE.WebGLShader: gl.getShaderInfoLog() " + n2 + "\n" + r2 + function(e3) {
    const t3 = e3.split("\n");
    for (let n3 = 0; n3 < t3.length; n3++) t3[n3] = n3 + 1 + ": " + t3[n3];
    return t3.join("\n");
  }(e2.getShaderSource(t2));
}
function xi(e2, t2) {
  const n2 = gi(t2);
  return "vec4 " + e2 + "( vec4 value ) { return " + n2[0] + "ToLinear" + n2[1] + "; }";
}
function yi(e2, t2) {
  const n2 = gi(t2);
  return "vec4 " + e2 + "( vec4 value ) { return LinearTo" + n2[0] + n2[1] + "; }";
}
function _i(e2, t2) {
  let n2;
  switch (t2) {
    case 1:
      n2 = "Linear";
      break;
    case 2:
      n2 = "Reinhard";
      break;
    case 3:
      n2 = "OptimizedCineon";
      break;
    case 4:
      n2 = "ACESFilmic";
      break;
    case 5:
      n2 = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t2), n2 = "Linear";
  }
  return "vec3 " + e2 + "( vec3 color ) { return " + n2 + "ToneMapping( color ); }";
}
function bi(e2) {
  return "" !== e2;
}
function wi(e2, t2) {
  return e2.replace(/NUM_DIR_LIGHTS/g, t2.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t2.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t2.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t2.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t2.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t2.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t2.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t2.numPointLightShadows);
}
function Mi(e2, t2) {
  return e2.replace(/NUM_CLIPPING_PLANES/g, t2.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t2.numClippingPlanes - t2.numClipIntersection);
}
var Si = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ti(e2) {
  return e2.replace(Si, Ei);
}
function Ei(e2, t2) {
  const n2 = qt[t2];
  if (void 0 === n2) throw new Error("Can not resolve #include <" + t2 + ">");
  return Ti(n2);
}
var Li = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
var Ri = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ai(e2) {
  return e2.replace(Ri, Ci).replace(Li, Pi);
}
function Pi(e2, t2, n2, i2) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Ci(e2, t2, n2, i2);
}
function Ci(e2, t2, n2, i2) {
  let r2 = "";
  for (let a2 = parseInt(t2); a2 < parseInt(n2); a2++) r2 += i2.replace(/\[\s*i\s*\]/g, "[ " + a2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, a2);
  return r2;
}
function Di(e2) {
  let t2 = "precision " + e2.precision + " float;\nprecision " + e2.precision + " int;";
  return "highp" === e2.precision ? t2 += "\n#define HIGH_PRECISION" : "mediump" === e2.precision ? t2 += "\n#define MEDIUM_PRECISION" : "lowp" === e2.precision && (t2 += "\n#define LOW_PRECISION"), t2;
}
function Ii(e2, t2, n2, i2) {
  const r2 = e2.getContext(), a2 = n2.defines;
  let o2 = n2.vertexShader, s2 = n2.fragmentShader;
  const l2 = function(e3) {
    let t3 = "SHADOWMAP_TYPE_BASIC";
    return 1 === e3.shadowMapType ? t3 = "SHADOWMAP_TYPE_PCF" : 2 === e3.shadowMapType ? t3 = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e3.shadowMapType && (t3 = "SHADOWMAP_TYPE_VSM"), t3;
  }(n2), c2 = function(e3) {
    let t3 = "ENVMAP_TYPE_CUBE";
    if (e3.envMap) switch (e3.envMapMode) {
      case 301:
      case 302:
        t3 = "ENVMAP_TYPE_CUBE";
        break;
      case 306:
      case 307:
        t3 = "ENVMAP_TYPE_CUBE_UV";
    }
    return t3;
  }(n2), h2 = function(e3) {
    let t3 = "ENVMAP_MODE_REFLECTION";
    if (e3.envMap) switch (e3.envMapMode) {
      case 302:
      case 307:
        t3 = "ENVMAP_MODE_REFRACTION";
    }
    return t3;
  }(n2), u2 = function(e3) {
    let t3 = "ENVMAP_BLENDING_NONE";
    if (e3.envMap) switch (e3.combine) {
      case 0:
        t3 = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case 1:
        t3 = "ENVMAP_BLENDING_MIX";
        break;
      case 2:
        t3 = "ENVMAP_BLENDING_ADD";
    }
    return t3;
  }(n2), d2 = e2.gammaFactor > 0 ? e2.gammaFactor : 1, p2 = n2.isWebGL2 ? "" : function(e3) {
    return [e3.extensionDerivatives || e3.envMapCubeUV || e3.bumpMap || e3.tangentSpaceNormalMap || e3.clearcoatNormalMap || e3.flatShading || "physical" === e3.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e3.extensionFragDepth || e3.logarithmicDepthBuffer) && e3.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e3.extensionDrawBuffers && e3.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e3.extensionShaderTextureLOD || e3.envMap) && e3.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(bi).join("\n");
  }(n2), f2 = function(e3) {
    const t3 = [];
    for (const n3 in e3) {
      const i3 = e3[n3];
      false !== i3 && t3.push("#define " + n3 + " " + i3);
    }
    return t3.join("\n");
  }(a2), m2 = r2.createProgram();
  let g2, v2, x2 = n2.glslVersion ? "#version " + n2.glslVersion + "\n" : "";
  n2.isRawShaderMaterial ? (g2 = [f2].filter(bi).join("\n"), g2.length > 0 && (g2 += "\n"), v2 = [p2, f2].filter(bi).join("\n"), v2.length > 0 && (v2 += "\n")) : (g2 = [Di(n2), "#define SHADER_NAME " + n2.shaderName, f2, n2.instancing ? "#define USE_INSTANCING" : "", n2.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n2.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d2, "#define MAX_BONES " + n2.maxBones, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + h2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.displacementMap && n2.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.skinning ? "#define USE_SKINNING" : "", n2.useVertexTexture ? "#define BONE_TEXTURE" : "", n2.morphTargets ? "#define USE_MORPHTARGETS" : "", n2.morphNormals && false === n2.flatShading ? "#define USE_MORPHNORMALS" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(bi).join("\n"), v2 = [p2, Di(n2), "#define SHADER_NAME " + n2.shaderName, f2, n2.alphaTest ? "#define ALPHATEST " + n2.alphaTest + (n2.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d2, n2.useFog && n2.fog ? "#define USE_FOG" : "", n2.useFog && n2.fogExp2 ? "#define FOG_EXP2" : "", n2.map ? "#define USE_MAP" : "", n2.matcap ? "#define USE_MATCAP" : "", n2.envMap ? "#define USE_ENVMAP" : "", n2.envMap ? "#define " + c2 : "", n2.envMap ? "#define " + h2 : "", n2.envMap ? "#define " + u2 : "", n2.lightMap ? "#define USE_LIGHTMAP" : "", n2.aoMap ? "#define USE_AOMAP" : "", n2.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n2.bumpMap ? "#define USE_BUMPMAP" : "", n2.normalMap ? "#define USE_NORMALMAP" : "", n2.normalMap && n2.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n2.normalMap && n2.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n2.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n2.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n2.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n2.specularMap ? "#define USE_SPECULARMAP" : "", n2.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n2.metalnessMap ? "#define USE_METALNESSMAP" : "", n2.alphaMap ? "#define USE_ALPHAMAP" : "", n2.sheen ? "#define USE_SHEEN" : "", n2.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n2.vertexTangents ? "#define USE_TANGENT" : "", n2.vertexColors || n2.instancingColor ? "#define USE_COLOR" : "", n2.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n2.vertexUvs ? "#define USE_UV" : "", n2.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n2.gradientMap ? "#define USE_GRADIENTMAP" : "", n2.flatShading ? "#define FLAT_SHADED" : "", n2.doubleSided ? "#define DOUBLE_SIDED" : "", n2.flipSided ? "#define FLIP_SIDED" : "", n2.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n2.shadowMapEnabled ? "#define " + l2 : "", n2.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n2.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n2.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n2.logarithmicDepthBuffer && n2.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n2.extensionShaderTextureLOD || n2.envMap) && n2.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n2.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n2.toneMapping ? qt.tonemapping_pars_fragment : "", 0 !== n2.toneMapping ? _i("toneMapping", n2.toneMapping) : "", n2.dithering ? "#define DITHERING" : "", qt.encodings_pars_fragment, n2.map ? xi("mapTexelToLinear", n2.mapEncoding) : "", n2.matcap ? xi("matcapTexelToLinear", n2.matcapEncoding) : "", n2.envMap ? xi("envMapTexelToLinear", n2.envMapEncoding) : "", n2.emissiveMap ? xi("emissiveMapTexelToLinear", n2.emissiveMapEncoding) : "", n2.lightMap ? xi("lightMapTexelToLinear", n2.lightMapEncoding) : "", yi("linearToOutputTexel", n2.outputEncoding), n2.depthPacking ? "#define DEPTH_PACKING " + n2.depthPacking : "", "\n"].filter(bi).join("\n")), o2 = Ti(o2), o2 = wi(o2, n2), o2 = Mi(o2, n2), s2 = Ti(s2), s2 = wi(s2, n2), s2 = Mi(s2, n2), o2 = Ai(o2), s2 = Ai(s2), n2.isWebGL2 && true !== n2.isRawShaderMaterial && (x2 = "#version 300 es\n", g2 = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g2, v2 = ["#define varying in", "300 es" === n2.glslVersion ? "" : "out highp vec4 pc_fragColor;", "300 es" === n2.glslVersion ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v2);
  const y2 = x2 + v2 + s2, _2 = fi(r2, 35633, x2 + g2 + o2), b2 = fi(r2, 35632, y2);
  if (r2.attachShader(m2, _2), r2.attachShader(m2, b2), void 0 !== n2.index0AttributeName ? r2.bindAttribLocation(m2, 0, n2.index0AttributeName) : true === n2.morphTargets && r2.bindAttribLocation(m2, 0, "position"), r2.linkProgram(m2), e2.debug.checkShaderErrors) {
    const e3 = r2.getProgramInfoLog(m2).trim(), t3 = r2.getShaderInfoLog(_2).trim(), n3 = r2.getShaderInfoLog(b2).trim();
    let i3 = true, a3 = true;
    if (false === r2.getProgramParameter(m2, 35714)) {
      i3 = false;
      const t4 = vi(r2, _2, "vertex"), n4 = vi(r2, b2, "fragment");
      console.error("THREE.WebGLProgram: shader error: ", r2.getError(), "35715", r2.getProgramParameter(m2, 35715), "gl.getProgramInfoLog", e3, t4, n4);
    } else "" !== e3 ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e3) : "" !== t3 && "" !== n3 || (a3 = false);
    a3 && (this.diagnostics = { runnable: i3, programLog: e3, vertexShader: { log: t3, prefix: g2 }, fragmentShader: { log: n3, prefix: v2 } });
  }
  let w2, M2;
  return r2.deleteShader(_2), r2.deleteShader(b2), this.getUniforms = function() {
    return void 0 === w2 && (w2 = new pi(r2, m2)), w2;
  }, this.getAttributes = function() {
    return void 0 === M2 && (M2 = function(e3, t3) {
      const n3 = {}, i3 = e3.getProgramParameter(t3, 35721);
      for (let r3 = 0; r3 < i3; r3++) {
        const i4 = e3.getActiveAttrib(t3, r3).name;
        n3[i4] = e3.getAttribLocation(t3, i4);
      }
      return n3;
    }(r2, m2)), M2;
  }, this.destroy = function() {
    i2.releaseStatesOfProgram(this), r2.deleteProgram(m2), this.program = void 0;
  }, this.name = n2.shaderName, this.id = mi++, this.cacheKey = t2, this.usedTimes = 1, this.program = m2, this.vertexShader = _2, this.fragmentShader = b2, this;
}
function Ni(e2, t2, n2, i2, r2, a2) {
  const o2 = [], s2 = i2.isWebGL2, l2 = i2.logarithmicDepthBuffer, c2 = i2.floatVertexTextures, h2 = i2.maxVertexUniforms, u2 = i2.vertexTextures;
  let d2 = i2.precision;
  const p2 = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, f2 = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
  function m2(e3) {
    let t3;
    return e3 && e3.isTexture ? t3 = e3.encoding : e3 && e3.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), t3 = e3.texture.encoding) : t3 = 3e3, t3;
  }
  return { getParameters: function(r3, o3, f3, g2, v2) {
    const x2 = g2.fog, y2 = r3.isMeshStandardMaterial ? g2.environment : null, _2 = t2.get(r3.envMap || y2), b2 = p2[r3.type], w2 = v2.isSkinnedMesh ? function(e3) {
      const t3 = e3.skeleton.bones;
      if (c2) return 1024;
      {
        const e4 = h2, n3 = Math.floor((e4 - 20) / 4), i3 = Math.min(n3, t3.length);
        return i3 < t3.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t3.length + " bones. This GPU supports " + i3 + "."), 0) : i3;
      }
    }(v2) : 0;
    let M2, S2;
    if (null !== r3.precision && (d2 = i2.getMaxPrecision(r3.precision), d2 !== r3.precision && console.warn("THREE.WebGLProgram.getParameters:", r3.precision, "not supported, using", d2, "instead.")), b2) {
      const e3 = Yt[b2];
      M2 = e3.vertexShader, S2 = e3.fragmentShader;
    } else M2 = r3.vertexShader, S2 = r3.fragmentShader;
    const T2 = e2.getRenderTarget();
    return { isWebGL2: s2, shaderID: b2, shaderName: r3.type, vertexShader: M2, fragmentShader: S2, defines: r3.defines, isRawShaderMaterial: true === r3.isRawShaderMaterial, glslVersion: r3.glslVersion, precision: d2, instancing: true === v2.isInstancedMesh, instancingColor: true === v2.isInstancedMesh && null !== v2.instanceColor, supportsVertexTextures: u2, outputEncoding: null !== T2 ? m2(T2.texture) : e2.outputEncoding, map: !!r3.map, mapEncoding: m2(r3.map), matcap: !!r3.matcap, matcapEncoding: m2(r3.matcap), envMap: !!_2, envMapMode: _2 && _2.mapping, envMapEncoding: m2(_2), envMapCubeUV: !!_2 && (306 === _2.mapping || 307 === _2.mapping), lightMap: !!r3.lightMap, lightMapEncoding: m2(r3.lightMap), aoMap: !!r3.aoMap, emissiveMap: !!r3.emissiveMap, emissiveMapEncoding: m2(r3.emissiveMap), bumpMap: !!r3.bumpMap, normalMap: !!r3.normalMap, objectSpaceNormalMap: 1 === r3.normalMapType, tangentSpaceNormalMap: 0 === r3.normalMapType, clearcoatMap: !!r3.clearcoatMap, clearcoatRoughnessMap: !!r3.clearcoatRoughnessMap, clearcoatNormalMap: !!r3.clearcoatNormalMap, displacementMap: !!r3.displacementMap, roughnessMap: !!r3.roughnessMap, metalnessMap: !!r3.metalnessMap, specularMap: !!r3.specularMap, alphaMap: !!r3.alphaMap, gradientMap: !!r3.gradientMap, sheen: !!r3.sheen, transmissionMap: !!r3.transmissionMap, combine: r3.combine, vertexTangents: r3.normalMap && r3.vertexTangents, vertexColors: r3.vertexColors, vertexAlphas: true === r3.vertexColors && v2.geometry.attributes.color && 4 === v2.geometry.attributes.color.itemSize, vertexUvs: !!(r3.map || r3.bumpMap || r3.normalMap || r3.specularMap || r3.alphaMap || r3.emissiveMap || r3.roughnessMap || r3.metalnessMap || r3.clearcoatMap || r3.clearcoatRoughnessMap || r3.clearcoatNormalMap || r3.displacementMap || r3.transmissionMap), uvsVertexOnly: !(r3.map || r3.bumpMap || r3.normalMap || r3.specularMap || r3.alphaMap || r3.emissiveMap || r3.roughnessMap || r3.metalnessMap || r3.clearcoatNormalMap || r3.transmissionMap || !r3.displacementMap), fog: !!x2, useFog: r3.fog, fogExp2: x2 && x2.isFogExp2, flatShading: !!r3.flatShading, sizeAttenuation: r3.sizeAttenuation, logarithmicDepthBuffer: l2, skinning: r3.skinning && w2 > 0, maxBones: w2, useVertexTexture: c2, morphTargets: r3.morphTargets, morphNormals: r3.morphNormals, numDirLights: o3.directional.length, numPointLights: o3.point.length, numSpotLights: o3.spot.length, numRectAreaLights: o3.rectArea.length, numHemiLights: o3.hemi.length, numDirLightShadows: o3.directionalShadowMap.length, numPointLightShadows: o3.pointShadowMap.length, numSpotLightShadows: o3.spotShadowMap.length, numClippingPlanes: a2.numPlanes, numClipIntersection: a2.numIntersection, dithering: r3.dithering, shadowMapEnabled: e2.shadowMap.enabled && f3.length > 0, shadowMapType: e2.shadowMap.type, toneMapping: r3.toneMapped ? e2.toneMapping : 0, physicallyCorrectLights: e2.physicallyCorrectLights, premultipliedAlpha: r3.premultipliedAlpha, alphaTest: r3.alphaTest, doubleSided: 2 === r3.side, flipSided: 1 === r3.side, depthPacking: void 0 !== r3.depthPacking && r3.depthPacking, index0AttributeName: r3.index0AttributeName, extensionDerivatives: r3.extensions && r3.extensions.derivatives, extensionFragDepth: r3.extensions && r3.extensions.fragDepth, extensionDrawBuffers: r3.extensions && r3.extensions.drawBuffers, extensionShaderTextureLOD: r3.extensions && r3.extensions.shaderTextureLOD, rendererExtensionFragDepth: s2 || n2.has("EXT_frag_depth"), rendererExtensionDrawBuffers: s2 || n2.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: s2 || n2.has("EXT_shader_texture_lod"), customProgramCacheKey: r3.customProgramCacheKey() };
  }, getProgramCacheKey: function(t3) {
    const n3 = [];
    if (t3.shaderID ? n3.push(t3.shaderID) : (n3.push(t3.fragmentShader), n3.push(t3.vertexShader)), void 0 !== t3.defines) for (const e3 in t3.defines) n3.push(e3), n3.push(t3.defines[e3]);
    if (false === t3.isRawShaderMaterial) {
      for (let e3 = 0; e3 < f2.length; e3++) n3.push(t3[f2[e3]]);
      n3.push(e2.outputEncoding), n3.push(e2.gammaFactor);
    }
    return n3.push(t3.customProgramCacheKey), n3.join();
  }, getUniforms: function(e3) {
    const t3 = p2[e3.type];
    let n3;
    if (t3) {
      const e4 = Yt[t3];
      n3 = Dt.clone(e4.uniforms);
    } else n3 = e3.uniforms;
    return n3;
  }, acquireProgram: function(t3, n3) {
    let i3;
    for (let e3 = 0, r3 = o2.length; e3 < r3; e3++) {
      const t4 = o2[e3];
      if (t4.cacheKey === n3) {
        i3 = t4, ++i3.usedTimes;
        break;
      }
    }
    return void 0 === i3 && (i3 = new Ii(e2, n3, t3, r2), o2.push(i3)), i3;
  }, releaseProgram: function(e3) {
    if (0 == --e3.usedTimes) {
      const t3 = o2.indexOf(e3);
      o2[t3] = o2[o2.length - 1], o2.pop(), e3.destroy();
    }
  }, programs: o2 };
}
function Oi() {
  let e2 = /* @__PURE__ */ new WeakMap();
  return { get: function(t2) {
    let n2 = e2.get(t2);
    return void 0 === n2 && (n2 = {}, e2.set(t2, n2)), n2;
  }, remove: function(t2) {
    e2.delete(t2);
  }, update: function(t2, n2, i2) {
    e2.get(t2)[n2] = i2;
  }, dispose: function() {
    e2 = /* @__PURE__ */ new WeakMap();
  } };
}
function Ui(e2, t2) {
  return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.program !== t2.program ? e2.program.id - t2.program.id : e2.material.id !== t2.material.id ? e2.material.id - t2.material.id : e2.z !== t2.z ? e2.z - t2.z : e2.id - t2.id;
}
function Fi(e2, t2) {
  return e2.groupOrder !== t2.groupOrder ? e2.groupOrder - t2.groupOrder : e2.renderOrder !== t2.renderOrder ? e2.renderOrder - t2.renderOrder : e2.z !== t2.z ? t2.z - e2.z : e2.id - t2.id;
}
function Hi(e2) {
  const t2 = [];
  let n2 = 0;
  const i2 = [], r2 = [], a2 = { id: -1 };
  function o2(i3, r3, o3, s2, l2, c2) {
    let h2 = t2[n2];
    const u2 = e2.get(o3);
    return void 0 === h2 ? (h2 = { id: i3.id, object: i3, geometry: r3, material: o3, program: u2.program || a2, groupOrder: s2, renderOrder: i3.renderOrder, z: l2, group: c2 }, t2[n2] = h2) : (h2.id = i3.id, h2.object = i3, h2.geometry = r3, h2.material = o3, h2.program = u2.program || a2, h2.groupOrder = s2, h2.renderOrder = i3.renderOrder, h2.z = l2, h2.group = c2), n2++, h2;
  }
  return { opaque: i2, transparent: r2, init: function() {
    n2 = 0, i2.length = 0, r2.length = 0;
  }, push: function(e3, t3, n3, a3, s2, l2) {
    const c2 = o2(e3, t3, n3, a3, s2, l2);
    (true === n3.transparent ? r2 : i2).push(c2);
  }, unshift: function(e3, t3, n3, a3, s2, l2) {
    const c2 = o2(e3, t3, n3, a3, s2, l2);
    (true === n3.transparent ? r2 : i2).unshift(c2);
  }, finish: function() {
    for (let e3 = n2, i3 = t2.length; e3 < i3; e3++) {
      const n3 = t2[e3];
      if (null === n3.id) break;
      n3.id = null, n3.object = null, n3.geometry = null, n3.material = null, n3.program = null, n3.group = null;
    }
  }, sort: function(e3, t3) {
    i2.length > 1 && i2.sort(e3 || Ui), r2.length > 1 && r2.sort(t3 || Fi);
  } };
}
function zi(e2) {
  let t2 = /* @__PURE__ */ new WeakMap();
  return { get: function(n2, i2) {
    let r2;
    return false === t2.has(n2) ? (r2 = new Hi(e2), t2.set(n2, [r2])) : i2 >= t2.get(n2).length ? (r2 = new Hi(e2), t2.get(n2).push(r2)) : r2 = t2.get(n2)[i2], r2;
  }, dispose: function() {
    t2 = /* @__PURE__ */ new WeakMap();
  } };
}
function Bi() {
  const e2 = {};
  return { get: function(t2) {
    if (void 0 !== e2[t2.id]) return e2[t2.id];
    let n2;
    switch (t2.type) {
      case "DirectionalLight":
        n2 = { direction: new f(), color: new Be() };
        break;
      case "SpotLight":
        n2 = { position: new f(), direction: new f(), color: new Be(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        n2 = { position: new f(), color: new Be(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        n2 = { direction: new f(), skyColor: new Be(), groundColor: new Be() };
        break;
      case "RectAreaLight":
        n2 = { color: new Be(), position: new f(), halfWidth: new f(), halfHeight: new f() };
    }
    return e2[t2.id] = n2, n2;
  } };
}
var Gi = 0;
function ki(e2, t2) {
  return (t2.castShadow ? 1 : 0) - (e2.castShadow ? 1 : 0);
}
function Vi(e2, t2) {
  const n2 = new Bi(), i2 = /* @__PURE__ */ function() {
    const e3 = {};
    return { get: function(t3) {
      if (void 0 !== e3[t3.id]) return e3[t3.id];
      let n3;
      switch (t3.type) {
        case "DirectionalLight":
        case "SpotLight":
          n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new r() };
          break;
        case "PointLight":
          n3 = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new r(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
      }
      return e3[t3.id] = n3, n3;
    } };
  }(), a2 = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
  for (let r2 = 0; r2 < 9; r2++) a2.probe.push(new f());
  const o2 = new f(), s2 = new j(), l2 = new j();
  return { setup: function(r2) {
    let o3 = 0, s3 = 0, l3 = 0;
    for (let e3 = 0; e3 < 9; e3++) a2.probe[e3].set(0, 0, 0);
    let c2 = 0, h2 = 0, u2 = 0, d2 = 0, p2 = 0, f2 = 0, m2 = 0, g2 = 0;
    r2.sort(ki);
    for (let e3 = 0, t3 = r2.length; e3 < t3; e3++) {
      const t4 = r2[e3], v3 = t4.color, x2 = t4.intensity, y2 = t4.distance, _2 = t4.shadow && t4.shadow.map ? t4.shadow.map.texture : null;
      if (t4.isAmbientLight) o3 += v3.r * x2, s3 += v3.g * x2, l3 += v3.b * x2;
      else if (t4.isLightProbe) for (let e4 = 0; e4 < 9; e4++) a2.probe[e4].addScaledVector(t4.sh.coefficients[e4], x2);
      else if (t4.isDirectionalLight) {
        const e4 = n2.get(t4);
        if (e4.color.copy(t4.color).multiplyScalar(t4.intensity), t4.castShadow) {
          const e5 = t4.shadow, n3 = i2.get(t4);
          n3.shadowBias = e5.bias, n3.shadowNormalBias = e5.normalBias, n3.shadowRadius = e5.radius, n3.shadowMapSize = e5.mapSize, a2.directionalShadow[c2] = n3, a2.directionalShadowMap[c2] = _2, a2.directionalShadowMatrix[c2] = t4.shadow.matrix, f2++;
        }
        a2.directional[c2] = e4, c2++;
      } else if (t4.isSpotLight) {
        const e4 = n2.get(t4);
        if (e4.position.setFromMatrixPosition(t4.matrixWorld), e4.color.copy(v3).multiplyScalar(x2), e4.distance = y2, e4.coneCos = Math.cos(t4.angle), e4.penumbraCos = Math.cos(t4.angle * (1 - t4.penumbra)), e4.decay = t4.decay, t4.castShadow) {
          const e5 = t4.shadow, n3 = i2.get(t4);
          n3.shadowBias = e5.bias, n3.shadowNormalBias = e5.normalBias, n3.shadowRadius = e5.radius, n3.shadowMapSize = e5.mapSize, a2.spotShadow[u2] = n3, a2.spotShadowMap[u2] = _2, a2.spotShadowMatrix[u2] = t4.shadow.matrix, g2++;
        }
        a2.spot[u2] = e4, u2++;
      } else if (t4.isRectAreaLight) {
        const e4 = n2.get(t4);
        e4.color.copy(v3).multiplyScalar(x2), e4.halfWidth.set(0.5 * t4.width, 0, 0), e4.halfHeight.set(0, 0.5 * t4.height, 0), a2.rectArea[d2] = e4, d2++;
      } else if (t4.isPointLight) {
        const e4 = n2.get(t4);
        if (e4.color.copy(t4.color).multiplyScalar(t4.intensity), e4.distance = t4.distance, e4.decay = t4.decay, t4.castShadow) {
          const e5 = t4.shadow, n3 = i2.get(t4);
          n3.shadowBias = e5.bias, n3.shadowNormalBias = e5.normalBias, n3.shadowRadius = e5.radius, n3.shadowMapSize = e5.mapSize, n3.shadowCameraNear = e5.camera.near, n3.shadowCameraFar = e5.camera.far, a2.pointShadow[h2] = n3, a2.pointShadowMap[h2] = _2, a2.pointShadowMatrix[h2] = t4.shadow.matrix, m2++;
        }
        a2.point[h2] = e4, h2++;
      } else if (t4.isHemisphereLight) {
        const e4 = n2.get(t4);
        e4.skyColor.copy(t4.color).multiplyScalar(x2), e4.groundColor.copy(t4.groundColor).multiplyScalar(x2), a2.hemi[p2] = e4, p2++;
      }
    }
    d2 > 0 && (t2.isWebGL2 || true === e2.has("OES_texture_float_linear") ? (a2.rectAreaLTC1 = Xt.LTC_FLOAT_1, a2.rectAreaLTC2 = Xt.LTC_FLOAT_2) : true === e2.has("OES_texture_half_float_linear") ? (a2.rectAreaLTC1 = Xt.LTC_HALF_1, a2.rectAreaLTC2 = Xt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), a2.ambient[0] = o3, a2.ambient[1] = s3, a2.ambient[2] = l3;
    const v2 = a2.hash;
    v2.directionalLength === c2 && v2.pointLength === h2 && v2.spotLength === u2 && v2.rectAreaLength === d2 && v2.hemiLength === p2 && v2.numDirectionalShadows === f2 && v2.numPointShadows === m2 && v2.numSpotShadows === g2 || (a2.directional.length = c2, a2.spot.length = u2, a2.rectArea.length = d2, a2.point.length = h2, a2.hemi.length = p2, a2.directionalShadow.length = f2, a2.directionalShadowMap.length = f2, a2.pointShadow.length = m2, a2.pointShadowMap.length = m2, a2.spotShadow.length = g2, a2.spotShadowMap.length = g2, a2.directionalShadowMatrix.length = f2, a2.pointShadowMatrix.length = m2, a2.spotShadowMatrix.length = g2, v2.directionalLength = c2, v2.pointLength = h2, v2.spotLength = u2, v2.rectAreaLength = d2, v2.hemiLength = p2, v2.numDirectionalShadows = f2, v2.numPointShadows = m2, v2.numSpotShadows = g2, a2.version = Gi++);
  }, setupView: function(e3, t3) {
    let n3 = 0, i3 = 0, r2 = 0, c2 = 0, h2 = 0;
    const u2 = t3.matrixWorldInverse;
    for (let d2 = 0, p2 = e3.length; d2 < p2; d2++) {
      const t4 = e3[d2];
      if (t4.isDirectionalLight) {
        const e4 = a2.directional[n3];
        e4.direction.setFromMatrixPosition(t4.matrixWorld), o2.setFromMatrixPosition(t4.target.matrixWorld), e4.direction.sub(o2), e4.direction.transformDirection(u2), n3++;
      } else if (t4.isSpotLight) {
        const e4 = a2.spot[r2];
        e4.position.setFromMatrixPosition(t4.matrixWorld), e4.position.applyMatrix4(u2), e4.direction.setFromMatrixPosition(t4.matrixWorld), o2.setFromMatrixPosition(t4.target.matrixWorld), e4.direction.sub(o2), e4.direction.transformDirection(u2), r2++;
      } else if (t4.isRectAreaLight) {
        const e4 = a2.rectArea[c2];
        e4.position.setFromMatrixPosition(t4.matrixWorld), e4.position.applyMatrix4(u2), l2.identity(), s2.copy(t4.matrixWorld), s2.premultiply(u2), l2.extractRotation(s2), e4.halfWidth.set(0.5 * t4.width, 0, 0), e4.halfHeight.set(0, 0.5 * t4.height, 0), e4.halfWidth.applyMatrix4(l2), e4.halfHeight.applyMatrix4(l2), c2++;
      } else if (t4.isPointLight) {
        const e4 = a2.point[i3];
        e4.position.setFromMatrixPosition(t4.matrixWorld), e4.position.applyMatrix4(u2), i3++;
      } else if (t4.isHemisphereLight) {
        const e4 = a2.hemi[h2];
        e4.direction.setFromMatrixPosition(t4.matrixWorld), e4.direction.transformDirection(u2), e4.direction.normalize(), h2++;
      }
    }
  }, state: a2 };
}
function Wi(e2, t2) {
  const n2 = new Vi(e2, t2), i2 = [], r2 = [];
  return { init: function() {
    i2.length = 0, r2.length = 0;
  }, state: { lightsArray: i2, shadowsArray: r2, lights: n2 }, setupLights: function() {
    n2.setup(i2);
  }, setupLightsView: function(e3) {
    n2.setupView(i2, e3);
  }, pushLight: function(e3) {
    i2.push(e3);
  }, pushShadow: function(e3) {
    r2.push(e3);
  } };
}
function ji(e2, t2) {
  let n2 = /* @__PURE__ */ new WeakMap();
  return { get: function(i2, r2 = 0) {
    let a2;
    return false === n2.has(i2) ? (a2 = new Wi(e2, t2), n2.set(i2, [a2])) : r2 >= n2.get(i2).length ? (a2 = new Wi(e2, t2), n2.get(i2).push(a2)) : a2 = n2.get(i2)[r2], a2;
  }, dispose: function() {
    n2 = /* @__PURE__ */ new WeakMap();
  } };
}
var qi = class extends Ie {
  constructor(e2) {
    super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(e2);
  }
  copy(e2) {
    return super.copy(e2), this.depthPacking = e2.depthPacking, this.skinning = e2.skinning, this.morphTargets = e2.morphTargets, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this;
  }
};
qi.prototype.isMeshDepthMaterial = true;
var Xi = class extends Ie {
  constructor(e2) {
    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new f(), this.nearDistance = 1, this.farDistance = 1e3, this.skinning = false, this.morphTargets = false, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(e2);
  }
  copy(e2) {
    return super.copy(e2), this.referencePosition.copy(e2.referencePosition), this.nearDistance = e2.nearDistance, this.farDistance = e2.farDistance, this.skinning = e2.skinning, this.morphTargets = e2.morphTargets, this.map = e2.map, this.alphaMap = e2.alphaMap, this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this;
  }
};
Xi.prototype.isMeshDistanceMaterial = true;
function Yi(e2, t2, n2) {
  let i2 = new kt();
  const a2 = new r(), o2 = new r(), s2 = new u(), l2 = [], c2 = [], h2 = {}, p2 = n2.maxTextureSize, f2 = { 0: 1, 1: 0, 2: 2 }, m2 = new It({ defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new r() }, radius: { value: 4 } }, vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}", fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean * HALF_SAMPLE_RATE;\n	squared_mean = squared_mean * HALF_SAMPLE_RATE;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}" }), g2 = m2.clone();
  g2.defines.HORIZONTAL_PASS = 1;
  const v2 = new ct();
  v2.setAttribute("position", new We(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const x2 = new Lt(v2, m2), y2 = this;
  function _2(n3, i3) {
    const r2 = t2.update(x2);
    m2.uniforms.shadow_pass.value = n3.map.texture, m2.uniforms.resolution.value = n3.mapSize, m2.uniforms.radius.value = n3.radius, e2.setRenderTarget(n3.mapPass), e2.clear(), e2.renderBufferDirect(i3, null, r2, m2, x2, null), g2.uniforms.shadow_pass.value = n3.mapPass.texture, g2.uniforms.resolution.value = n3.mapSize, g2.uniforms.radius.value = n3.radius, e2.setRenderTarget(n3.map), e2.clear(), e2.renderBufferDirect(i3, null, r2, g2, x2, null);
  }
  function b2(e3, t3, n3) {
    const i3 = e3 << 0 | t3 << 1 | n3 << 2;
    let r2 = l2[i3];
    return void 0 === r2 && (r2 = new qi({ depthPacking: 3201, morphTargets: e3, skinning: t3 }), l2[i3] = r2), r2;
  }
  function w2(e3, t3, n3) {
    const i3 = e3 << 0 | t3 << 1 | n3 << 2;
    let r2 = c2[i3];
    return void 0 === r2 && (r2 = new Xi({ morphTargets: e3, skinning: t3 }), c2[i3] = r2), r2;
  }
  function M2(t3, n3, i3, r2, a3, o3, s3) {
    let l3 = null, c3 = b2, u2 = t3.customDepthMaterial;
    if (true === r2.isPointLight && (c3 = w2, u2 = t3.customDistanceMaterial), void 0 === u2) {
      let e3 = false;
      true === i3.morphTargets && (e3 = n3.morphAttributes && n3.morphAttributes.position && n3.morphAttributes.position.length > 0);
      let r3 = false;
      true === t3.isSkinnedMesh && (true === i3.skinning ? r3 = true : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t3));
      l3 = c3(e3, r3, true === t3.isInstancedMesh);
    } else l3 = u2;
    if (e2.localClippingEnabled && true === i3.clipShadows && 0 !== i3.clippingPlanes.length) {
      const e3 = l3.uuid, t4 = i3.uuid;
      let n4 = h2[e3];
      void 0 === n4 && (n4 = {}, h2[e3] = n4);
      let r3 = n4[t4];
      void 0 === r3 && (r3 = l3.clone(), n4[t4] = r3), l3 = r3;
    }
    return l3.visible = i3.visible, l3.wireframe = i3.wireframe, l3.side = 3 === s3 ? null !== i3.shadowSide ? i3.shadowSide : i3.side : null !== i3.shadowSide ? i3.shadowSide : f2[i3.side], l3.clipShadows = i3.clipShadows, l3.clippingPlanes = i3.clippingPlanes, l3.clipIntersection = i3.clipIntersection, l3.wireframeLinewidth = i3.wireframeLinewidth, l3.linewidth = i3.linewidth, true === r2.isPointLight && true === l3.isMeshDistanceMaterial && (l3.referencePosition.setFromMatrixPosition(r2.matrixWorld), l3.nearDistance = a3, l3.farDistance = o3), l3;
  }
  function S2(n3, r2, a3, o3, s3) {
    if (false === n3.visible) return;
    if (n3.layers.test(r2.layers) && (n3.isMesh || n3.isLine || n3.isPoints) && (n3.castShadow || n3.receiveShadow && 3 === s3) && (!n3.frustumCulled || i2.intersectsObject(n3))) {
      n3.modelViewMatrix.multiplyMatrices(a3.matrixWorldInverse, n3.matrixWorld);
      const i3 = t2.update(n3), r3 = n3.material;
      if (Array.isArray(r3)) {
        const t3 = i3.groups;
        for (let l4 = 0, c3 = t3.length; l4 < c3; l4++) {
          const c4 = t3[l4], h3 = r3[c4.materialIndex];
          if (h3 && h3.visible) {
            const t4 = M2(n3, i3, h3, o3, a3.near, a3.far, s3);
            e2.renderBufferDirect(a3, null, i3, t4, n3, c4);
          }
        }
      } else if (r3.visible) {
        const t3 = M2(n3, i3, r3, o3, a3.near, a3.far, s3);
        e2.renderBufferDirect(a3, null, i3, t3, n3, null);
      }
    }
    const l3 = n3.children;
    for (let e3 = 0, t3 = l3.length; e3 < t3; e3++) S2(l3[e3], r2, a3, o3, s3);
  }
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(t3, n3, r2) {
    if (false === y2.enabled) return;
    if (false === y2.autoUpdate && false === y2.needsUpdate) return;
    if (0 === t3.length) return;
    const l3 = e2.getRenderTarget(), c3 = e2.getActiveCubeFace(), h3 = e2.getActiveMipmapLevel(), u2 = e2.state;
    u2.setBlending(0), u2.buffers.color.setClear(1, 1, 1, 1), u2.buffers.depth.setTest(true), u2.setScissorTest(false);
    for (let f3 = 0, m3 = t3.length; f3 < m3; f3++) {
      const l4 = t3[f3], c4 = l4.shadow;
      if (void 0 === c4) {
        console.warn("THREE.WebGLShadowMap:", l4, "has no shadow.");
        continue;
      }
      if (false === c4.autoUpdate && false === c4.needsUpdate) continue;
      a2.copy(c4.mapSize);
      const h4 = c4.getFrameExtents();
      if (a2.multiply(h4), o2.copy(c4.mapSize), (a2.x > p2 || a2.y > p2) && (a2.x > p2 && (o2.x = Math.floor(p2 / h4.x), a2.x = o2.x * h4.x, c4.mapSize.x = o2.x), a2.y > p2 && (o2.y = Math.floor(p2 / h4.y), a2.y = o2.y * h4.y, c4.mapSize.y = o2.y)), null === c4.map && !c4.isPointLightShadow && 3 === this.type) {
        const e3 = { minFilter: 1006, magFilter: 1006, format: 1023 };
        c4.map = new d(a2.x, a2.y, e3), c4.map.texture.name = l4.name + ".shadowMap", c4.mapPass = new d(a2.x, a2.y, e3), c4.camera.updateProjectionMatrix();
      }
      if (null === c4.map) {
        const e3 = { minFilter: 1003, magFilter: 1003, format: 1023 };
        c4.map = new d(a2.x, a2.y, e3), c4.map.texture.name = l4.name + ".shadowMap", c4.camera.updateProjectionMatrix();
      }
      e2.setRenderTarget(c4.map), e2.clear();
      const m4 = c4.getViewportCount();
      for (let e3 = 0; e3 < m4; e3++) {
        const t4 = c4.getViewport(e3);
        s2.set(o2.x * t4.x, o2.y * t4.y, o2.x * t4.z, o2.y * t4.w), u2.viewport(s2), c4.updateMatrices(l4, e3), i2 = c4.getFrustum(), S2(n3, r2, c4.camera, l4, this.type);
      }
      c4.isPointLightShadow || 3 !== this.type || _2(c4, r2), c4.needsUpdate = false;
    }
    y2.needsUpdate = false, e2.setRenderTarget(l3, c3, h3);
  };
}
function Zi(e2, t2, n2) {
  const i2 = n2.isWebGL2;
  const r2 = new function() {
    let t3 = false;
    const n3 = new u();
    let i3 = null;
    const r3 = new u(0, 0, 0, 0);
    return { setMask: function(n4) {
      i3 === n4 || t3 || (e2.colorMask(n4, n4, n4, n4), i3 = n4);
    }, setLocked: function(e3) {
      t3 = e3;
    }, setClear: function(t4, i4, a3, o3, s3) {
      true === s3 && (t4 *= o3, i4 *= o3, a3 *= o3), n3.set(t4, i4, a3, o3), false === r3.equals(n3) && (e2.clearColor(t4, i4, a3, o3), r3.copy(n3));
    }, reset: function() {
      t3 = false, i3 = null, r3.set(-1, 0, 0, 0);
    } };
  }(), a2 = new function() {
    let t3 = false, n3 = null, i3 = null, r3 = null;
    return { setTest: function(e3) {
      e3 ? U2(2929) : F2(2929);
    }, setMask: function(i4) {
      n3 === i4 || t3 || (e2.depthMask(i4), n3 = i4);
    }, setFunc: function(t4) {
      if (i3 !== t4) {
        if (t4) switch (t4) {
          case 0:
            e2.depthFunc(512);
            break;
          case 1:
            e2.depthFunc(519);
            break;
          case 2:
            e2.depthFunc(513);
            break;
          case 3:
            e2.depthFunc(515);
            break;
          case 4:
            e2.depthFunc(514);
            break;
          case 5:
            e2.depthFunc(518);
            break;
          case 6:
            e2.depthFunc(516);
            break;
          case 7:
            e2.depthFunc(517);
            break;
          default:
            e2.depthFunc(515);
        }
        else e2.depthFunc(515);
        i3 = t4;
      }
    }, setLocked: function(e3) {
      t3 = e3;
    }, setClear: function(t4) {
      r3 !== t4 && (e2.clearDepth(t4), r3 = t4);
    }, reset: function() {
      t3 = false, n3 = null, i3 = null, r3 = null;
    } };
  }(), o2 = new function() {
    let t3 = false, n3 = null, i3 = null, r3 = null, a3 = null, o3 = null, s3 = null, l3 = null, c3 = null;
    return { setTest: function(e3) {
      t3 || (e3 ? U2(2960) : F2(2960));
    }, setMask: function(i4) {
      n3 === i4 || t3 || (e2.stencilMask(i4), n3 = i4);
    }, setFunc: function(t4, n4, o4) {
      i3 === t4 && r3 === n4 && a3 === o4 || (e2.stencilFunc(t4, n4, o4), i3 = t4, r3 = n4, a3 = o4);
    }, setOp: function(t4, n4, i4) {
      o3 === t4 && s3 === n4 && l3 === i4 || (e2.stencilOp(t4, n4, i4), o3 = t4, s3 = n4, l3 = i4);
    }, setLocked: function(e3) {
      t3 = e3;
    }, setClear: function(t4) {
      c3 !== t4 && (e2.clearStencil(t4), c3 = t4);
    }, reset: function() {
      t3 = false, n3 = null, i3 = null, r3 = null, a3 = null, o3 = null, s3 = null, l3 = null, c3 = null;
    } };
  }();
  let s2 = {}, l2 = null, c2 = {}, h2 = null, d2 = false, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, x2 = null, y2 = null, _2 = false, b2 = null, w2 = null, M2 = null, S2 = null, T2 = null;
  const E2 = e2.getParameter(35661);
  let L2 = false, R2 = 0;
  const A2 = e2.getParameter(7938);
  -1 !== A2.indexOf("WebGL") ? (R2 = parseFloat(/^WebGL (\d)/.exec(A2)[1]), L2 = R2 >= 1) : -1 !== A2.indexOf("OpenGL ES") && (R2 = parseFloat(/^OpenGL ES (\d)/.exec(A2)[1]), L2 = R2 >= 2);
  let P2 = null, C2 = {};
  const D2 = new u(0, 0, e2.canvas.width, e2.canvas.height), I2 = new u(0, 0, e2.canvas.width, e2.canvas.height);
  function N2(t3, n3, i3) {
    const r3 = new Uint8Array(4), a3 = e2.createTexture();
    e2.bindTexture(t3, a3), e2.texParameteri(t3, 10241, 9728), e2.texParameteri(t3, 10240, 9728);
    for (let o3 = 0; o3 < i3; o3++) e2.texImage2D(n3 + o3, 0, 6408, 1, 1, 0, 6408, 5121, r3);
    return a3;
  }
  const O2 = {};
  function U2(t3) {
    true !== s2[t3] && (e2.enable(t3), s2[t3] = true);
  }
  function F2(t3) {
    false !== s2[t3] && (e2.disable(t3), s2[t3] = false);
  }
  O2[3553] = N2(3553, 3553, 1), O2[34067] = N2(34067, 34069, 6), r2.setClear(0, 0, 0, 1), a2.setClear(1), o2.setClear(0), U2(2929), a2.setFunc(3), G2(false), k2(1), U2(2884), B2(0);
  const H2 = { 100: 32774, 101: 32778, 102: 32779 };
  if (i2) H2[103] = 32775, H2[104] = 32776;
  else {
    const e3 = t2.get("EXT_blend_minmax");
    null !== e3 && (H2[103] = e3.MIN_EXT, H2[104] = e3.MAX_EXT);
  }
  const z2 = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
  function B2(t3, n3, i3, r3, a3, o3, s3, l3) {
    if (0 !== t3) {
      if (false === d2 && (U2(3042), d2 = true), 5 === t3) a3 = a3 || n3, o3 = o3 || i3, s3 = s3 || r3, n3 === f2 && a3 === v2 || (e2.blendEquationSeparate(H2[n3], H2[a3]), f2 = n3, v2 = a3), i3 === m2 && r3 === g2 && o3 === x2 && s3 === y2 || (e2.blendFuncSeparate(z2[i3], z2[r3], z2[o3], z2[s3]), m2 = i3, g2 = r3, x2 = o3, y2 = s3), p2 = t3, _2 = null;
      else if (t3 !== p2 || l3 !== _2) {
        if (100 === f2 && 100 === v2 || (e2.blendEquation(32774), f2 = 100, v2 = 100), l3) switch (t3) {
          case 1:
            e2.blendFuncSeparate(1, 771, 1, 771);
            break;
          case 2:
            e2.blendFunc(1, 1);
            break;
          case 3:
            e2.blendFuncSeparate(0, 0, 769, 771);
            break;
          case 4:
            e2.blendFuncSeparate(0, 768, 0, 770);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", t3);
        }
        else switch (t3) {
          case 1:
            e2.blendFuncSeparate(770, 771, 1, 771);
            break;
          case 2:
            e2.blendFunc(770, 1);
            break;
          case 3:
            e2.blendFunc(0, 769);
            break;
          case 4:
            e2.blendFunc(0, 768);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", t3);
        }
        m2 = null, g2 = null, x2 = null, y2 = null, p2 = t3, _2 = l3;
      }
    } else true === d2 && (F2(3042), d2 = false);
  }
  function G2(t3) {
    b2 !== t3 && (t3 ? e2.frontFace(2304) : e2.frontFace(2305), b2 = t3);
  }
  function k2(t3) {
    0 !== t3 ? (U2(2884), t3 !== w2 && (1 === t3 ? e2.cullFace(1029) : 2 === t3 ? e2.cullFace(1028) : e2.cullFace(1032))) : F2(2884), w2 = t3;
  }
  function V2(t3, n3, i3) {
    t3 ? (U2(32823), S2 === n3 && T2 === i3 || (e2.polygonOffset(n3, i3), S2 = n3, T2 = i3)) : F2(32823);
  }
  function W2(t3) {
    void 0 === t3 && (t3 = 33984 + E2 - 1), P2 !== t3 && (e2.activeTexture(t3), P2 = t3);
  }
  return { buffers: { color: r2, depth: a2, stencil: o2 }, enable: U2, disable: F2, bindFramebuffer: function(t3, n3) {
    null === n3 && null !== l2 && (n3 = l2), c2[t3] !== n3 && (e2.bindFramebuffer(t3, n3), c2[t3] = n3);
  }, bindXRFramebuffer: function(t3) {
    t3 !== l2 && (e2.bindFramebuffer(36160, t3), l2 = t3);
  }, useProgram: function(t3) {
    return h2 !== t3 && (e2.useProgram(t3), h2 = t3, true);
  }, setBlending: B2, setMaterial: function(e3, t3) {
    2 === e3.side ? F2(2884) : U2(2884);
    let n3 = 1 === e3.side;
    t3 && (n3 = !n3), G2(n3), 1 === e3.blending && false === e3.transparent ? B2(0) : B2(e3.blending, e3.blendEquation, e3.blendSrc, e3.blendDst, e3.blendEquationAlpha, e3.blendSrcAlpha, e3.blendDstAlpha, e3.premultipliedAlpha), a2.setFunc(e3.depthFunc), a2.setTest(e3.depthTest), a2.setMask(e3.depthWrite), r2.setMask(e3.colorWrite);
    const i3 = e3.stencilWrite;
    o2.setTest(i3), i3 && (o2.setMask(e3.stencilWriteMask), o2.setFunc(e3.stencilFunc, e3.stencilRef, e3.stencilFuncMask), o2.setOp(e3.stencilFail, e3.stencilZFail, e3.stencilZPass)), V2(e3.polygonOffset, e3.polygonOffsetFactor, e3.polygonOffsetUnits), true === e3.alphaToCoverage ? U2(32926) : F2(32926);
  }, setFlipSided: G2, setCullFace: k2, setLineWidth: function(t3) {
    t3 !== M2 && (L2 && e2.lineWidth(t3), M2 = t3);
  }, setPolygonOffset: V2, setScissorTest: function(e3) {
    e3 ? U2(3089) : F2(3089);
  }, activeTexture: W2, bindTexture: function(t3, n3) {
    null === P2 && W2();
    let i3 = C2[P2];
    void 0 === i3 && (i3 = { type: void 0, texture: void 0 }, C2[P2] = i3), i3.type === t3 && i3.texture === n3 || (e2.bindTexture(t3, n3 || O2[t3]), i3.type = t3, i3.texture = n3);
  }, unbindTexture: function() {
    const t3 = C2[P2];
    void 0 !== t3 && void 0 !== t3.type && (e2.bindTexture(t3.type, null), t3.type = void 0, t3.texture = void 0);
  }, compressedTexImage2D: function() {
    try {
      e2.compressedTexImage2D.apply(e2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texImage2D: function() {
    try {
      e2.texImage2D.apply(e2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, texImage3D: function() {
    try {
      e2.texImage3D.apply(e2, arguments);
    } catch (t3) {
      console.error("THREE.WebGLState:", t3);
    }
  }, scissor: function(t3) {
    false === D2.equals(t3) && (e2.scissor(t3.x, t3.y, t3.z, t3.w), D2.copy(t3));
  }, viewport: function(t3) {
    false === I2.equals(t3) && (e2.viewport(t3.x, t3.y, t3.z, t3.w), I2.copy(t3));
  }, reset: function() {
    e2.disable(3042), e2.disable(2884), e2.disable(2929), e2.disable(32823), e2.disable(3089), e2.disable(2960), e2.disable(32926), e2.blendEquation(32774), e2.blendFunc(1, 0), e2.blendFuncSeparate(1, 0, 1, 0), e2.colorMask(true, true, true, true), e2.clearColor(0, 0, 0, 0), e2.depthMask(true), e2.depthFunc(513), e2.clearDepth(1), e2.stencilMask(4294967295), e2.stencilFunc(519, 0, 4294967295), e2.stencilOp(7680, 7680, 7680), e2.clearStencil(0), e2.cullFace(1029), e2.frontFace(2305), e2.polygonOffset(0, 0), e2.activeTexture(33984), e2.bindFramebuffer(36160, null), true === i2 && (e2.bindFramebuffer(36009, null), e2.bindFramebuffer(36008, null)), e2.useProgram(null), e2.lineWidth(1), e2.scissor(0, 0, e2.canvas.width, e2.canvas.height), e2.viewport(0, 0, e2.canvas.width, e2.canvas.height), s2 = {}, P2 = null, C2 = {}, l2 = null, c2 = {}, h2 = null, d2 = false, p2 = null, f2 = null, m2 = null, g2 = null, v2 = null, x2 = null, y2 = null, _2 = false, b2 = null, w2 = null, M2 = null, S2 = null, T2 = null, D2.set(0, 0, e2.canvas.width, e2.canvas.height), I2.set(0, 0, e2.canvas.width, e2.canvas.height), r2.reset(), a2.reset(), o2.reset();
  } };
}
function Ji(e2, t2, n2, r2, a2, o2, s2) {
  const l2 = a2.isWebGL2, c2 = a2.maxTextures, h2 = a2.maxCubemapSize, u2 = a2.maxTextureSize, d2 = a2.maxSamples, p2 = /* @__PURE__ */ new WeakMap();
  let f2, m2 = false;
  try {
    m2 = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (z2) {
  }
  function g2(e3, t3) {
    return m2 ? new OffscreenCanvas(e3, t3) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
  }
  function v2(e3, t3, n3, r3) {
    let a3 = 1;
    if ((e3.width > r3 || e3.height > r3) && (a3 = r3 / Math.max(e3.width, e3.height)), a3 < 1 || true === t3) {
      if ("undefined" != typeof HTMLImageElement && e3 instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e3 instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e3 instanceof ImageBitmap) {
        const r4 = t3 ? i.floorPowerOfTwo : Math.floor, o3 = r4(a3 * e3.width), s3 = r4(a3 * e3.height);
        void 0 === f2 && (f2 = g2(o3, s3));
        const l3 = n3 ? g2(o3, s3) : f2;
        l3.width = o3, l3.height = s3;
        return l3.getContext("2d").drawImage(e3, 0, 0, o3, s3), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e3.width + "x" + e3.height + ") to (" + o3 + "x" + s3 + ")."), l3;
      }
      return "data" in e3 && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e3.width + "x" + e3.height + ")."), e3;
    }
    return e3;
  }
  function x2(e3) {
    return i.isPowerOfTwo(e3.width) && i.isPowerOfTwo(e3.height);
  }
  function y2(e3, t3) {
    return e3.generateMipmaps && t3 && 1003 !== e3.minFilter && 1006 !== e3.minFilter;
  }
  function _2(t3, n3, i2, a3) {
    e2.generateMipmap(t3);
    r2.get(n3).__maxMipLevel = Math.log2(Math.max(i2, a3));
  }
  function b2(n3, i2, r3) {
    if (false === l2) return i2;
    if (null !== n3) {
      if (void 0 !== e2[n3]) return e2[n3];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n3 + "'");
    }
    let a3 = i2;
    return 6403 === i2 && (5126 === r3 && (a3 = 33326), 5131 === r3 && (a3 = 33325), 5121 === r3 && (a3 = 33321)), 6407 === i2 && (5126 === r3 && (a3 = 34837), 5131 === r3 && (a3 = 34843), 5121 === r3 && (a3 = 32849)), 6408 === i2 && (5126 === r3 && (a3 = 34836), 5131 === r3 && (a3 = 34842), 5121 === r3 && (a3 = 32856)), 33325 !== a3 && 33326 !== a3 && 34842 !== a3 && 34836 !== a3 || t2.get("EXT_color_buffer_float"), a3;
  }
  function w2(e3) {
    return 1003 === e3 || 1004 === e3 || 1005 === e3 ? 9728 : 9729;
  }
  function M2(t3) {
    const n3 = t3.target;
    n3.removeEventListener("dispose", M2), function(t4) {
      const n4 = r2.get(t4);
      if (void 0 === n4.__webglInit) return;
      e2.deleteTexture(n4.__webglTexture), r2.remove(t4);
    }(n3), n3.isVideoTexture && p2.delete(n3), s2.memory.textures--;
  }
  function S2(t3) {
    const n3 = t3.target;
    n3.removeEventListener("dispose", S2), function(t4) {
      const n4 = t4.texture, i2 = r2.get(t4), a3 = r2.get(n4);
      if (!t4) return;
      void 0 !== a3.__webglTexture && e2.deleteTexture(a3.__webglTexture);
      t4.depthTexture && t4.depthTexture.dispose();
      if (t4.isWebGLCubeRenderTarget) for (let r3 = 0; r3 < 6; r3++) e2.deleteFramebuffer(i2.__webglFramebuffer[r3]), i2.__webglDepthbuffer && e2.deleteRenderbuffer(i2.__webglDepthbuffer[r3]);
      else e2.deleteFramebuffer(i2.__webglFramebuffer), i2.__webglDepthbuffer && e2.deleteRenderbuffer(i2.__webglDepthbuffer), i2.__webglMultisampledFramebuffer && e2.deleteFramebuffer(i2.__webglMultisampledFramebuffer), i2.__webglColorRenderbuffer && e2.deleteRenderbuffer(i2.__webglColorRenderbuffer), i2.__webglDepthRenderbuffer && e2.deleteRenderbuffer(i2.__webglDepthRenderbuffer);
      r2.remove(n4), r2.remove(t4);
    }(n3), s2.memory.textures--;
  }
  let T2 = 0;
  function E2(e3, t3) {
    const i2 = r2.get(e3);
    if (e3.isVideoTexture && function(e4) {
      const t4 = s2.render.frame;
      p2.get(e4) !== t4 && (p2.set(e4, t4), e4.update());
    }(e3), e3.version > 0 && i2.__version !== e3.version) {
      const n3 = e3.image;
      if (void 0 === n3) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
      else {
        if (false !== n3.complete) return void D2(i2, e3, t3);
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      }
    }
    n2.activeTexture(33984 + t3), n2.bindTexture(3553, i2.__webglTexture);
  }
  function L2(t3, i2) {
    const a3 = r2.get(t3);
    t3.version > 0 && a3.__version !== t3.version ? function(t4, i3, r3) {
      if (6 !== i3.image.length) return;
      C2(t4, i3), n2.activeTexture(33984 + r3), n2.bindTexture(34067, t4.__webglTexture), e2.pixelStorei(37440, i3.flipY), e2.pixelStorei(37441, i3.premultiplyAlpha), e2.pixelStorei(3317, i3.unpackAlignment), e2.pixelStorei(37443, 0);
      const a4 = i3 && (i3.isCompressedTexture || i3.image[0].isCompressedTexture), s3 = i3.image[0] && i3.image[0].isDataTexture, c3 = [];
      for (let e3 = 0; e3 < 6; e3++) c3[e3] = a4 || s3 ? s3 ? i3.image[e3].image : i3.image[e3] : v2(i3.image[e3], false, true, h2);
      const u3 = c3[0], d3 = x2(u3) || l2, p3 = o2.convert(i3.format), f3 = o2.convert(i3.type), m3 = b2(i3.internalFormat, p3, f3);
      let g3;
      if (P2(34067, i3, d3), a4) {
        for (let e3 = 0; e3 < 6; e3++) {
          g3 = c3[e3].mipmaps;
          for (let t5 = 0; t5 < g3.length; t5++) {
            const r4 = g3[t5];
            1023 !== i3.format && 1022 !== i3.format ? null !== p3 ? n2.compressedTexImage2D(34069 + e3, t5, m3, r4.width, r4.height, 0, r4.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n2.texImage2D(34069 + e3, t5, m3, r4.width, r4.height, 0, p3, f3, r4.data);
          }
        }
        t4.__maxMipLevel = g3.length - 1;
      } else {
        g3 = i3.mipmaps;
        for (let e3 = 0; e3 < 6; e3++) if (s3) {
          n2.texImage2D(34069 + e3, 0, m3, c3[e3].width, c3[e3].height, 0, p3, f3, c3[e3].data);
          for (let t5 = 0; t5 < g3.length; t5++) {
            const i4 = g3[t5].image[e3].image;
            n2.texImage2D(34069 + e3, t5 + 1, m3, i4.width, i4.height, 0, p3, f3, i4.data);
          }
        } else {
          n2.texImage2D(34069 + e3, 0, m3, p3, f3, c3[e3]);
          for (let t5 = 0; t5 < g3.length; t5++) {
            const i4 = g3[t5];
            n2.texImage2D(34069 + e3, t5 + 1, m3, p3, f3, i4.image[e3]);
          }
        }
        t4.__maxMipLevel = g3.length;
      }
      y2(i3, d3) && _2(34067, i3, u3.width, u3.height);
      t4.__version = i3.version, i3.onUpdate && i3.onUpdate(i3);
    }(a3, t3, i2) : (n2.activeTexture(33984 + i2), n2.bindTexture(34067, a3.__webglTexture));
  }
  const R2 = { 1e3: 10497, 1001: 33071, 1002: 33648 }, A2 = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
  function P2(n3, i2, o3) {
    if (o3 ? (e2.texParameteri(n3, 10242, R2[i2.wrapS]), e2.texParameteri(n3, 10243, R2[i2.wrapT]), 32879 !== n3 && 35866 !== n3 || e2.texParameteri(n3, 32882, R2[i2.wrapR]), e2.texParameteri(n3, 10240, A2[i2.magFilter]), e2.texParameteri(n3, 10241, A2[i2.minFilter])) : (e2.texParameteri(n3, 10242, 33071), e2.texParameteri(n3, 10243, 33071), 32879 !== n3 && 35866 !== n3 || e2.texParameteri(n3, 32882, 33071), 1001 === i2.wrapS && 1001 === i2.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e2.texParameteri(n3, 10240, w2(i2.magFilter)), e2.texParameteri(n3, 10241, w2(i2.minFilter)), 1003 !== i2.minFilter && 1006 !== i2.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), true === t2.has("EXT_texture_filter_anisotropic")) {
      const o4 = t2.get("EXT_texture_filter_anisotropic");
      if (1015 === i2.type && false === t2.has("OES_texture_float_linear")) return;
      if (false === l2 && 1016 === i2.type && false === t2.has("OES_texture_half_float_linear")) return;
      (i2.anisotropy > 1 || r2.get(i2).__currentAnisotropy) && (e2.texParameterf(n3, o4.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i2.anisotropy, a2.getMaxAnisotropy())), r2.get(i2).__currentAnisotropy = i2.anisotropy);
    }
  }
  function C2(t3, n3) {
    void 0 === t3.__webglInit && (t3.__webglInit = true, n3.addEventListener("dispose", M2), t3.__webglTexture = e2.createTexture(), s2.memory.textures++);
  }
  function D2(t3, i2, r3) {
    let a3 = 3553;
    i2.isDataTexture2DArray && (a3 = 35866), i2.isDataTexture3D && (a3 = 32879), C2(t3, i2), n2.activeTexture(33984 + r3), n2.bindTexture(a3, t3.__webglTexture), e2.pixelStorei(37440, i2.flipY), e2.pixelStorei(37441, i2.premultiplyAlpha), e2.pixelStorei(3317, i2.unpackAlignment), e2.pixelStorei(37443, 0);
    const s3 = function(e3) {
      return !l2 && (1001 !== e3.wrapS || 1001 !== e3.wrapT || 1003 !== e3.minFilter && 1006 !== e3.minFilter);
    }(i2) && false === x2(i2.image), c3 = v2(i2.image, s3, false, u2), h3 = x2(c3) || l2, d3 = o2.convert(i2.format);
    let p3, f3 = o2.convert(i2.type), m3 = b2(i2.internalFormat, d3, f3);
    P2(a3, i2, h3);
    const g3 = i2.mipmaps;
    if (i2.isDepthTexture) m3 = 6402, l2 ? m3 = 1015 === i2.type ? 36012 : 1014 === i2.type ? 33190 : 1020 === i2.type ? 35056 : 33189 : 1015 === i2.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === i2.format && 6402 === m3 && 1012 !== i2.type && 1014 !== i2.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i2.type = 1012, f3 = o2.convert(i2.type)), 1027 === i2.format && 6402 === m3 && (m3 = 34041, 1020 !== i2.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i2.type = 1020, f3 = o2.convert(i2.type))), n2.texImage2D(3553, 0, m3, c3.width, c3.height, 0, d3, f3, null);
    else if (i2.isDataTexture) if (g3.length > 0 && h3) {
      for (let e3 = 0, t4 = g3.length; e3 < t4; e3++) p3 = g3[e3], n2.texImage2D(3553, e3, m3, p3.width, p3.height, 0, d3, f3, p3.data);
      i2.generateMipmaps = false, t3.__maxMipLevel = g3.length - 1;
    } else n2.texImage2D(3553, 0, m3, c3.width, c3.height, 0, d3, f3, c3.data), t3.__maxMipLevel = 0;
    else if (i2.isCompressedTexture) {
      for (let e3 = 0, t4 = g3.length; e3 < t4; e3++) p3 = g3[e3], 1023 !== i2.format && 1022 !== i2.format ? null !== d3 ? n2.compressedTexImage2D(3553, e3, m3, p3.width, p3.height, 0, p3.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n2.texImage2D(3553, e3, m3, p3.width, p3.height, 0, d3, f3, p3.data);
      t3.__maxMipLevel = g3.length - 1;
    } else if (i2.isDataTexture2DArray) n2.texImage3D(35866, 0, m3, c3.width, c3.height, c3.depth, 0, d3, f3, c3.data), t3.__maxMipLevel = 0;
    else if (i2.isDataTexture3D) n2.texImage3D(32879, 0, m3, c3.width, c3.height, c3.depth, 0, d3, f3, c3.data), t3.__maxMipLevel = 0;
    else if (g3.length > 0 && h3) {
      for (let e3 = 0, t4 = g3.length; e3 < t4; e3++) p3 = g3[e3], n2.texImage2D(3553, e3, m3, d3, f3, p3);
      i2.generateMipmaps = false, t3.__maxMipLevel = g3.length - 1;
    } else n2.texImage2D(3553, 0, m3, d3, f3, c3), t3.__maxMipLevel = 0;
    y2(i2, h3) && _2(a3, i2, c3.width, c3.height), t3.__version = i2.version, i2.onUpdate && i2.onUpdate(i2);
  }
  function I2(t3, i2, a3, s3) {
    const l3 = i2.texture, c3 = o2.convert(l3.format), h3 = o2.convert(l3.type), u3 = b2(l3.internalFormat, c3, h3);
    32879 === s3 || 35866 === s3 ? n2.texImage3D(s3, 0, u3, i2.width, i2.height, i2.depth, 0, c3, h3, null) : n2.texImage2D(s3, 0, u3, i2.width, i2.height, 0, c3, h3, null), n2.bindFramebuffer(36160, t3), e2.framebufferTexture2D(36160, a3, s3, r2.get(l3).__webglTexture, 0), n2.bindFramebuffer(36160, null);
  }
  function N2(t3, n3, i2) {
    if (e2.bindRenderbuffer(36161, t3), n3.depthBuffer && !n3.stencilBuffer) {
      let r3 = 33189;
      if (i2) {
        const t4 = n3.depthTexture;
        t4 && t4.isDepthTexture && (1015 === t4.type ? r3 = 36012 : 1014 === t4.type && (r3 = 33190));
        const i3 = U2(n3);
        e2.renderbufferStorageMultisample(36161, i3, r3, n3.width, n3.height);
      } else e2.renderbufferStorage(36161, r3, n3.width, n3.height);
      e2.framebufferRenderbuffer(36160, 36096, 36161, t3);
    } else if (n3.depthBuffer && n3.stencilBuffer) {
      if (i2) {
        const t4 = U2(n3);
        e2.renderbufferStorageMultisample(36161, t4, 35056, n3.width, n3.height);
      } else e2.renderbufferStorage(36161, 34041, n3.width, n3.height);
      e2.framebufferRenderbuffer(36160, 33306, 36161, t3);
    } else {
      const t4 = n3.texture, r3 = o2.convert(t4.format), a3 = o2.convert(t4.type), s3 = b2(t4.internalFormat, r3, a3);
      if (i2) {
        const t5 = U2(n3);
        e2.renderbufferStorageMultisample(36161, t5, s3, n3.width, n3.height);
      } else e2.renderbufferStorage(36161, s3, n3.width, n3.height);
    }
    e2.bindRenderbuffer(36161, null);
  }
  function O2(t3) {
    const i2 = r2.get(t3), a3 = true === t3.isWebGLCubeRenderTarget;
    if (t3.depthTexture) {
      if (a3) throw new Error("target.depthTexture not supported in Cube render targets");
      !function(t4, i3) {
        if (i3 && i3.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (n2.bindFramebuffer(36160, t4), !i3.depthTexture || !i3.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        r2.get(i3.depthTexture).__webglTexture && i3.depthTexture.image.width === i3.width && i3.depthTexture.image.height === i3.height || (i3.depthTexture.image.width = i3.width, i3.depthTexture.image.height = i3.height, i3.depthTexture.needsUpdate = true), E2(i3.depthTexture, 0);
        const a4 = r2.get(i3.depthTexture).__webglTexture;
        if (1026 === i3.depthTexture.format) e2.framebufferTexture2D(36160, 36096, 3553, a4, 0);
        else {
          if (1027 !== i3.depthTexture.format) throw new Error("Unknown depthTexture format");
          e2.framebufferTexture2D(36160, 33306, 3553, a4, 0);
        }
      }(i2.__webglFramebuffer, t3);
    } else if (a3) {
      i2.__webglDepthbuffer = [];
      for (let r3 = 0; r3 < 6; r3++) n2.bindFramebuffer(36160, i2.__webglFramebuffer[r3]), i2.__webglDepthbuffer[r3] = e2.createRenderbuffer(), N2(i2.__webglDepthbuffer[r3], t3, false);
    } else n2.bindFramebuffer(36160, i2.__webglFramebuffer), i2.__webglDepthbuffer = e2.createRenderbuffer(), N2(i2.__webglDepthbuffer, t3, false);
    n2.bindFramebuffer(36160, null);
  }
  function U2(e3) {
    return l2 && e3.isWebGLMultisampleRenderTarget ? Math.min(d2, e3.samples) : 0;
  }
  let F2 = false, H2 = false;
  this.allocateTextureUnit = function() {
    const e3 = T2;
    return e3 >= c2 && console.warn("THREE.WebGLTextures: Trying to use " + e3 + " texture units while this GPU supports only " + c2), T2 += 1, e3;
  }, this.resetTextureUnits = function() {
    T2 = 0;
  }, this.setTexture2D = E2, this.setTexture2DArray = function(e3, t3) {
    const i2 = r2.get(e3);
    e3.version > 0 && i2.__version !== e3.version ? D2(i2, e3, t3) : (n2.activeTexture(33984 + t3), n2.bindTexture(35866, i2.__webglTexture));
  }, this.setTexture3D = function(e3, t3) {
    const i2 = r2.get(e3);
    e3.version > 0 && i2.__version !== e3.version ? D2(i2, e3, t3) : (n2.activeTexture(33984 + t3), n2.bindTexture(32879, i2.__webglTexture));
  }, this.setTextureCube = L2, this.setupRenderTarget = function(t3) {
    const i2 = t3.texture, a3 = r2.get(t3), c3 = r2.get(i2);
    t3.addEventListener("dispose", S2), c3.__webglTexture = e2.createTexture(), c3.__version = i2.version, s2.memory.textures++;
    const h3 = true === t3.isWebGLCubeRenderTarget, u3 = true === t3.isWebGLMultisampleRenderTarget, d3 = i2.isDataTexture3D || i2.isDataTexture2DArray, p3 = x2(t3) || l2;
    if (!l2 || 1022 !== i2.format || 1015 !== i2.type && 1016 !== i2.type || (i2.format = 1023, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h3) {
      a3.__webglFramebuffer = [];
      for (let t4 = 0; t4 < 6; t4++) a3.__webglFramebuffer[t4] = e2.createFramebuffer();
    } else if (a3.__webglFramebuffer = e2.createFramebuffer(), u3) if (l2) {
      a3.__webglMultisampledFramebuffer = e2.createFramebuffer(), a3.__webglColorRenderbuffer = e2.createRenderbuffer(), e2.bindRenderbuffer(36161, a3.__webglColorRenderbuffer);
      const r3 = o2.convert(i2.format), s3 = o2.convert(i2.type), l3 = b2(i2.internalFormat, r3, s3), c4 = U2(t3);
      e2.renderbufferStorageMultisample(36161, c4, l3, t3.width, t3.height), n2.bindFramebuffer(36160, a3.__webglMultisampledFramebuffer), e2.framebufferRenderbuffer(36160, 36064, 36161, a3.__webglColorRenderbuffer), e2.bindRenderbuffer(36161, null), t3.depthBuffer && (a3.__webglDepthRenderbuffer = e2.createRenderbuffer(), N2(a3.__webglDepthRenderbuffer, t3, true)), n2.bindFramebuffer(36160, null);
    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    if (h3) {
      n2.bindTexture(34067, c3.__webglTexture), P2(34067, i2, p3);
      for (let e3 = 0; e3 < 6; e3++) I2(a3.__webglFramebuffer[e3], t3, 36064, 34069 + e3);
      y2(i2, p3) && _2(34067, i2, t3.width, t3.height), n2.bindTexture(34067, null);
    } else {
      let e3 = 3553;
      if (d3) if (l2) {
        e3 = i2.isDataTexture3D ? 32879 : 35866;
      } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
      n2.bindTexture(e3, c3.__webglTexture), P2(e3, i2, p3), I2(a3.__webglFramebuffer, t3, 36064, e3), y2(i2, p3) && _2(3553, i2, t3.width, t3.height), n2.bindTexture(3553, null);
    }
    t3.depthBuffer && O2(t3);
  }, this.updateRenderTargetMipmap = function(e3) {
    const t3 = e3.texture;
    if (y2(t3, x2(e3) || l2)) {
      const i2 = e3.isWebGLCubeRenderTarget ? 34067 : 3553, a3 = r2.get(t3).__webglTexture;
      n2.bindTexture(i2, a3), _2(i2, t3, e3.width, e3.height), n2.bindTexture(i2, null);
    }
  }, this.updateMultisampleRenderTarget = function(t3) {
    if (t3.isWebGLMultisampleRenderTarget) if (l2) {
      const i2 = r2.get(t3);
      n2.bindFramebuffer(36008, i2.__webglMultisampledFramebuffer), n2.bindFramebuffer(36009, i2.__webglFramebuffer);
      const a3 = t3.width, o3 = t3.height;
      let s3 = 16384;
      t3.depthBuffer && (s3 |= 256), t3.stencilBuffer && (s3 |= 1024), e2.blitFramebuffer(0, 0, a3, o3, 0, 0, a3, o3, s3, 9728), n2.bindFramebuffer(36160, i2.__webglMultisampledFramebuffer);
    } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
  }, this.safeSetTexture2D = function(e3, t3) {
    e3 && e3.isWebGLRenderTarget && (false === F2 && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F2 = true), e3 = e3.texture), E2(e3, t3);
  }, this.safeSetTextureCube = function(e3, t3) {
    e3 && e3.isWebGLCubeRenderTarget && (false === H2 && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), H2 = true), e3 = e3.texture), L2(e3, t3);
  };
}
function Ki(e2, t2, n2) {
  const i2 = n2.isWebGL2;
  return { convert: function(e3) {
    let n3;
    if (1009 === e3) return 5121;
    if (1017 === e3) return 32819;
    if (1018 === e3) return 32820;
    if (1019 === e3) return 33635;
    if (1010 === e3) return 5120;
    if (1011 === e3) return 5122;
    if (1012 === e3) return 5123;
    if (1013 === e3) return 5124;
    if (1014 === e3) return 5125;
    if (1015 === e3) return 5126;
    if (1016 === e3) return i2 ? 5131 : (n3 = t2.get("OES_texture_half_float"), null !== n3 ? n3.HALF_FLOAT_OES : null);
    if (1021 === e3) return 6406;
    if (1022 === e3) return 6407;
    if (1023 === e3) return 6408;
    if (1024 === e3) return 6409;
    if (1025 === e3) return 6410;
    if (1026 === e3) return 6402;
    if (1027 === e3) return 34041;
    if (1028 === e3) return 6403;
    if (1029 === e3) return 36244;
    if (1030 === e3) return 33319;
    if (1031 === e3) return 33320;
    if (1032 === e3) return 36248;
    if (1033 === e3) return 36249;
    if (33776 === e3 || 33777 === e3 || 33778 === e3 || 33779 === e3) {
      if (n3 = t2.get("WEBGL_compressed_texture_s3tc"), null === n3) return null;
      if (33776 === e3) return n3.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (33777 === e3) return n3.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (33778 === e3) return n3.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (33779 === e3) return n3.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    }
    if (35840 === e3 || 35841 === e3 || 35842 === e3 || 35843 === e3) {
      if (n3 = t2.get("WEBGL_compressed_texture_pvrtc"), null === n3) return null;
      if (35840 === e3) return n3.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (35841 === e3) return n3.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (35842 === e3) return n3.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (35843 === e3) return n3.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    }
    if (36196 === e3) return n3 = t2.get("WEBGL_compressed_texture_etc1"), null !== n3 ? n3.COMPRESSED_RGB_ETC1_WEBGL : null;
    if ((37492 === e3 || 37496 === e3) && (n3 = t2.get("WEBGL_compressed_texture_etc"), null !== n3)) {
      if (37492 === e3) return n3.COMPRESSED_RGB8_ETC2;
      if (37496 === e3) return n3.COMPRESSED_RGBA8_ETC2_EAC;
    }
    return 37808 === e3 || 37809 === e3 || 37810 === e3 || 37811 === e3 || 37812 === e3 || 37813 === e3 || 37814 === e3 || 37815 === e3 || 37816 === e3 || 37817 === e3 || 37818 === e3 || 37819 === e3 || 37820 === e3 || 37821 === e3 || 37840 === e3 || 37841 === e3 || 37842 === e3 || 37843 === e3 || 37844 === e3 || 37845 === e3 || 37846 === e3 || 37847 === e3 || 37848 === e3 || 37849 === e3 || 37850 === e3 || 37851 === e3 || 37852 === e3 || 37853 === e3 ? (n3 = t2.get("WEBGL_compressed_texture_astc"), null !== n3 ? e3 : null) : 36492 === e3 ? (n3 = t2.get("EXT_texture_compression_bptc"), null !== n3 ? e3 : null) : 1020 === e3 ? i2 ? 34042 : (n3 = t2.get("WEBGL_depth_texture"), null !== n3 ? n3.UNSIGNED_INT_24_8_WEBGL : null) : void 0;
  } };
}
var Qi = class extends Ot {
  constructor(e2 = []) {
    super(), this.cameras = e2;
  }
};
Qi.prototype.isArrayCamera = true;
var $i = class extends ge {
  constructor() {
    super(), this.type = "Group";
  }
};
function er() {
  this._targetRay = null, this._grip = null, this._hand = null;
}
function tr(e2, t2) {
  const n2 = this, i2 = e2.state;
  let r2 = null, a2 = 1, o2 = null, s2 = "local-floor", l2 = null;
  const c2 = [], h2 = /* @__PURE__ */ new Map(), d2 = new Ot();
  d2.layers.enable(1), d2.viewport = new u();
  const p2 = new Ot();
  p2.layers.enable(2), p2.viewport = new u();
  const m2 = [d2, p2], g2 = new Qi();
  g2.layers.enable(1), g2.layers.enable(2);
  let v2 = null, x2 = null;
  function y2(e3) {
    const t3 = h2.get(e3.inputSource);
    t3 && t3.dispatchEvent({ type: e3.type, data: e3.inputSource });
  }
  function _2() {
    h2.forEach(function(e3, t3) {
      e3.disconnect(t3);
    }), h2.clear(), v2 = null, x2 = null, i2.bindXRFramebuffer(null), e2.setRenderTarget(e2.getRenderTarget()), E2.stop(), n2.isPresenting = false, n2.dispatchEvent({ type: "sessionend" });
  }
  function b2(e3) {
    const t3 = r2.inputSources;
    for (let n3 = 0; n3 < c2.length; n3++) h2.set(t3[n3], c2[n3]);
    for (let n3 = 0; n3 < e3.removed.length; n3++) {
      const t4 = e3.removed[n3], i3 = h2.get(t4);
      i3 && (i3.dispatchEvent({ type: "disconnected", data: t4 }), h2.delete(t4));
    }
    for (let n3 = 0; n3 < e3.added.length; n3++) {
      const t4 = e3.added[n3], i3 = h2.get(t4);
      i3 && i3.dispatchEvent({ type: "connected", data: t4 });
    }
  }
  this.enabled = false, this.isPresenting = false, this.getController = function(e3) {
    let t3 = c2[e3];
    return void 0 === t3 && (t3 = new er(), c2[e3] = t3), t3.getTargetRaySpace();
  }, this.getControllerGrip = function(e3) {
    let t3 = c2[e3];
    return void 0 === t3 && (t3 = new er(), c2[e3] = t3), t3.getGripSpace();
  }, this.getHand = function(e3) {
    let t3 = c2[e3];
    return void 0 === t3 && (t3 = new er(), c2[e3] = t3), t3.getHandSpace();
  }, this.setFramebufferScaleFactor = function(e3) {
    a2 = e3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
  }, this.setReferenceSpaceType = function(e3) {
    s2 = e3, true === n2.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
  }, this.getReferenceSpace = function() {
    return o2;
  }, this.getSession = function() {
    return r2;
  }, this.setSession = async function(e3) {
    if (r2 = e3, null !== r2) {
      r2.addEventListener("select", y2), r2.addEventListener("selectstart", y2), r2.addEventListener("selectend", y2), r2.addEventListener("squeeze", y2), r2.addEventListener("squeezestart", y2), r2.addEventListener("squeezeend", y2), r2.addEventListener("end", _2), r2.addEventListener("inputsourceschange", b2);
      const e4 = t2.getContextAttributes();
      true !== e4.xrCompatible && await t2.makeXRCompatible();
      const i3 = { antialias: e4.antialias, alpha: e4.alpha, depth: e4.depth, stencil: e4.stencil, framebufferScaleFactor: a2 }, l3 = new XRWebGLLayer(r2, t2, i3);
      r2.updateRenderState({ baseLayer: l3 }), o2 = await r2.requestReferenceSpace(s2), E2.setContext(r2), E2.start(), n2.isPresenting = true, n2.dispatchEvent({ type: "sessionstart" });
    }
  };
  const w2 = new f(), M2 = new f();
  function S2(e3, t3) {
    null === t3 ? e3.matrixWorld.copy(e3.matrix) : e3.matrixWorld.multiplyMatrices(t3.matrixWorld, e3.matrix), e3.matrixWorldInverse.copy(e3.matrixWorld).invert();
  }
  this.getCamera = function(e3) {
    g2.near = p2.near = d2.near = e3.near, g2.far = p2.far = d2.far = e3.far, v2 === g2.near && x2 === g2.far || (r2.updateRenderState({ depthNear: g2.near, depthFar: g2.far }), v2 = g2.near, x2 = g2.far);
    const t3 = e3.parent, n3 = g2.cameras;
    S2(g2, t3);
    for (let r3 = 0; r3 < n3.length; r3++) S2(n3[r3], t3);
    e3.matrixWorld.copy(g2.matrixWorld), e3.matrix.copy(g2.matrix), e3.matrix.decompose(e3.position, e3.quaternion, e3.scale);
    const i3 = e3.children;
    for (let r3 = 0, a3 = i3.length; r3 < a3; r3++) i3[r3].updateMatrixWorld(true);
    return 2 === n3.length ? function(e4, t4, n4) {
      w2.setFromMatrixPosition(t4.matrixWorld), M2.setFromMatrixPosition(n4.matrixWorld);
      const i4 = w2.distanceTo(M2), r3 = t4.projectionMatrix.elements, a3 = n4.projectionMatrix.elements, o3 = r3[14] / (r3[10] - 1), s3 = r3[14] / (r3[10] + 1), l3 = (r3[9] + 1) / r3[5], c3 = (r3[9] - 1) / r3[5], h3 = (r3[8] - 1) / r3[0], u2 = (a3[8] + 1) / a3[0], d3 = o3 * h3, p3 = o3 * u2, f2 = i4 / (-h3 + u2), m3 = f2 * -h3;
      t4.matrixWorld.decompose(e4.position, e4.quaternion, e4.scale), e4.translateX(m3), e4.translateZ(f2), e4.matrixWorld.compose(e4.position, e4.quaternion, e4.scale), e4.matrixWorldInverse.copy(e4.matrixWorld).invert();
      const g3 = o3 + f2, v3 = s3 + f2, x3 = d3 - m3, y3 = p3 + (i4 - m3), _3 = l3 * s3 / v3 * g3, b3 = c3 * s3 / v3 * g3;
      e4.projectionMatrix.makePerspective(x3, y3, _3, b3, g3, v3);
    }(g2, d2, p2) : g2.projectionMatrix.copy(d2.projectionMatrix), g2;
  };
  let T2 = null;
  const E2 = new Vt();
  E2.setAnimationLoop(function(e3, t3) {
    if (l2 = t3.getViewerPose(o2), null !== l2) {
      const e4 = l2.views, t4 = r2.renderState.baseLayer;
      i2.bindXRFramebuffer(t4.framebuffer);
      let n4 = false;
      e4.length !== g2.cameras.length && (g2.cameras.length = 0, n4 = true);
      for (let i3 = 0; i3 < e4.length; i3++) {
        const r3 = e4[i3], a3 = t4.getViewport(r3), o3 = m2[i3];
        o3.matrix.fromArray(r3.transform.matrix), o3.projectionMatrix.fromArray(r3.projectionMatrix), o3.viewport.set(a3.x, a3.y, a3.width, a3.height), 0 === i3 && g2.matrix.copy(o3.matrix), true === n4 && g2.cameras.push(o3);
      }
    }
    const n3 = r2.inputSources;
    for (let i3 = 0; i3 < c2.length; i3++) {
      const e4 = c2[i3], r3 = n3[i3];
      e4.update(r3, t3, o2);
    }
    T2 && T2(e3, t3);
  }), this.setAnimationLoop = function(e3) {
    T2 = e3;
  }, this.dispose = function() {
  };
}
function nr(e2) {
  function t2(t3, n3) {
    t3.opacity.value = n3.opacity, n3.color && t3.diffuse.value.copy(n3.color), n3.emissive && t3.emissive.value.copy(n3.emissive).multiplyScalar(n3.emissiveIntensity), n3.map && (t3.map.value = n3.map), n3.alphaMap && (t3.alphaMap.value = n3.alphaMap), n3.specularMap && (t3.specularMap.value = n3.specularMap);
    const i2 = e2.get(n3).envMap;
    if (i2) {
      t3.envMap.value = i2, t3.flipEnvMap.value = i2.isCubeTexture && i2._needsFlipEnvMap ? -1 : 1, t3.reflectivity.value = n3.reflectivity, t3.refractionRatio.value = n3.refractionRatio;
      const r3 = e2.get(i2).__maxMipLevel;
      void 0 !== r3 && (t3.maxMipLevel.value = r3);
    }
    let r2, a2;
    n3.lightMap && (t3.lightMap.value = n3.lightMap, t3.lightMapIntensity.value = n3.lightMapIntensity), n3.aoMap && (t3.aoMap.value = n3.aoMap, t3.aoMapIntensity.value = n3.aoMapIntensity), n3.map ? r2 = n3.map : n3.specularMap ? r2 = n3.specularMap : n3.displacementMap ? r2 = n3.displacementMap : n3.normalMap ? r2 = n3.normalMap : n3.bumpMap ? r2 = n3.bumpMap : n3.roughnessMap ? r2 = n3.roughnessMap : n3.metalnessMap ? r2 = n3.metalnessMap : n3.alphaMap ? r2 = n3.alphaMap : n3.emissiveMap ? r2 = n3.emissiveMap : n3.clearcoatMap ? r2 = n3.clearcoatMap : n3.clearcoatNormalMap ? r2 = n3.clearcoatNormalMap : n3.clearcoatRoughnessMap && (r2 = n3.clearcoatRoughnessMap), void 0 !== r2 && (r2.isWebGLRenderTarget && (r2 = r2.texture), true === r2.matrixAutoUpdate && r2.updateMatrix(), t3.uvTransform.value.copy(r2.matrix)), n3.aoMap ? a2 = n3.aoMap : n3.lightMap && (a2 = n3.lightMap), void 0 !== a2 && (a2.isWebGLRenderTarget && (a2 = a2.texture), true === a2.matrixAutoUpdate && a2.updateMatrix(), t3.uv2Transform.value.copy(a2.matrix));
  }
  function n2(t3, n3) {
    t3.roughness.value = n3.roughness, t3.metalness.value = n3.metalness, n3.roughnessMap && (t3.roughnessMap.value = n3.roughnessMap), n3.metalnessMap && (t3.metalnessMap.value = n3.metalnessMap), n3.emissiveMap && (t3.emissiveMap.value = n3.emissiveMap), n3.bumpMap && (t3.bumpMap.value = n3.bumpMap, t3.bumpScale.value = n3.bumpScale, 1 === n3.side && (t3.bumpScale.value *= -1)), n3.normalMap && (t3.normalMap.value = n3.normalMap, t3.normalScale.value.copy(n3.normalScale), 1 === n3.side && t3.normalScale.value.negate()), n3.displacementMap && (t3.displacementMap.value = n3.displacementMap, t3.displacementScale.value = n3.displacementScale, t3.displacementBias.value = n3.displacementBias);
    e2.get(n3).envMap && (t3.envMapIntensity.value = n3.envMapIntensity);
  }
  return { refreshFogUniforms: function(e3, t3) {
    e3.fogColor.value.copy(t3.color), t3.isFog ? (e3.fogNear.value = t3.near, e3.fogFar.value = t3.far) : t3.isFogExp2 && (e3.fogDensity.value = t3.density);
  }, refreshMaterialUniforms: function(e3, i2, r2, a2) {
    i2.isMeshBasicMaterial ? t2(e3, i2) : i2.isMeshLambertMaterial ? (t2(e3, i2), function(e4, t3) {
      t3.emissiveMap && (e4.emissiveMap.value = t3.emissiveMap);
    }(e3, i2)) : i2.isMeshToonMaterial ? (t2(e3, i2), function(e4, t3) {
      t3.gradientMap && (e4.gradientMap.value = t3.gradientMap);
      t3.emissiveMap && (e4.emissiveMap.value = t3.emissiveMap);
      t3.bumpMap && (e4.bumpMap.value = t3.bumpMap, e4.bumpScale.value = t3.bumpScale, 1 === t3.side && (e4.bumpScale.value *= -1));
      t3.normalMap && (e4.normalMap.value = t3.normalMap, e4.normalScale.value.copy(t3.normalScale), 1 === t3.side && e4.normalScale.value.negate());
      t3.displacementMap && (e4.displacementMap.value = t3.displacementMap, e4.displacementScale.value = t3.displacementScale, e4.displacementBias.value = t3.displacementBias);
    }(e3, i2)) : i2.isMeshPhongMaterial ? (t2(e3, i2), function(e4, t3) {
      e4.specular.value.copy(t3.specular), e4.shininess.value = Math.max(t3.shininess, 1e-4), t3.emissiveMap && (e4.emissiveMap.value = t3.emissiveMap);
      t3.bumpMap && (e4.bumpMap.value = t3.bumpMap, e4.bumpScale.value = t3.bumpScale, 1 === t3.side && (e4.bumpScale.value *= -1));
      t3.normalMap && (e4.normalMap.value = t3.normalMap, e4.normalScale.value.copy(t3.normalScale), 1 === t3.side && e4.normalScale.value.negate());
      t3.displacementMap && (e4.displacementMap.value = t3.displacementMap, e4.displacementScale.value = t3.displacementScale, e4.displacementBias.value = t3.displacementBias);
    }(e3, i2)) : i2.isMeshStandardMaterial ? (t2(e3, i2), i2.isMeshPhysicalMaterial ? function(e4, t3) {
      n2(e4, t3), e4.reflectivity.value = t3.reflectivity, e4.clearcoat.value = t3.clearcoat, e4.clearcoatRoughness.value = t3.clearcoatRoughness, t3.sheen && e4.sheen.value.copy(t3.sheen);
      t3.clearcoatMap && (e4.clearcoatMap.value = t3.clearcoatMap);
      t3.clearcoatRoughnessMap && (e4.clearcoatRoughnessMap.value = t3.clearcoatRoughnessMap);
      t3.clearcoatNormalMap && (e4.clearcoatNormalScale.value.copy(t3.clearcoatNormalScale), e4.clearcoatNormalMap.value = t3.clearcoatNormalMap, 1 === t3.side && e4.clearcoatNormalScale.value.negate());
      e4.transmission.value = t3.transmission, t3.transmissionMap && (e4.transmissionMap.value = t3.transmissionMap);
    }(e3, i2) : n2(e3, i2)) : i2.isMeshMatcapMaterial ? (t2(e3, i2), function(e4, t3) {
      t3.matcap && (e4.matcap.value = t3.matcap);
      t3.bumpMap && (e4.bumpMap.value = t3.bumpMap, e4.bumpScale.value = t3.bumpScale, 1 === t3.side && (e4.bumpScale.value *= -1));
      t3.normalMap && (e4.normalMap.value = t3.normalMap, e4.normalScale.value.copy(t3.normalScale), 1 === t3.side && e4.normalScale.value.negate());
      t3.displacementMap && (e4.displacementMap.value = t3.displacementMap, e4.displacementScale.value = t3.displacementScale, e4.displacementBias.value = t3.displacementBias);
    }(e3, i2)) : i2.isMeshDepthMaterial ? (t2(e3, i2), function(e4, t3) {
      t3.displacementMap && (e4.displacementMap.value = t3.displacementMap, e4.displacementScale.value = t3.displacementScale, e4.displacementBias.value = t3.displacementBias);
    }(e3, i2)) : i2.isMeshDistanceMaterial ? (t2(e3, i2), function(e4, t3) {
      t3.displacementMap && (e4.displacementMap.value = t3.displacementMap, e4.displacementScale.value = t3.displacementScale, e4.displacementBias.value = t3.displacementBias);
      e4.referencePosition.value.copy(t3.referencePosition), e4.nearDistance.value = t3.nearDistance, e4.farDistance.value = t3.farDistance;
    }(e3, i2)) : i2.isMeshNormalMaterial ? (t2(e3, i2), function(e4, t3) {
      t3.bumpMap && (e4.bumpMap.value = t3.bumpMap, e4.bumpScale.value = t3.bumpScale, 1 === t3.side && (e4.bumpScale.value *= -1));
      t3.normalMap && (e4.normalMap.value = t3.normalMap, e4.normalScale.value.copy(t3.normalScale), 1 === t3.side && e4.normalScale.value.negate());
      t3.displacementMap && (e4.displacementMap.value = t3.displacementMap, e4.displacementScale.value = t3.displacementScale, e4.displacementBias.value = t3.displacementBias);
    }(e3, i2)) : i2.isLineBasicMaterial ? (function(e4, t3) {
      e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity;
    }(e3, i2), i2.isLineDashedMaterial && function(e4, t3) {
      e4.dashSize.value = t3.dashSize, e4.totalSize.value = t3.dashSize + t3.gapSize, e4.scale.value = t3.scale;
    }(e3, i2)) : i2.isPointsMaterial ? function(e4, t3, n3, i3) {
      e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.size.value = t3.size * n3, e4.scale.value = 0.5 * i3, t3.map && (e4.map.value = t3.map);
      t3.alphaMap && (e4.alphaMap.value = t3.alphaMap);
      let r3;
      t3.map ? r3 = t3.map : t3.alphaMap && (r3 = t3.alphaMap);
      void 0 !== r3 && (true === r3.matrixAutoUpdate && r3.updateMatrix(), e4.uvTransform.value.copy(r3.matrix));
    }(e3, i2, r2, a2) : i2.isSpriteMaterial ? function(e4, t3) {
      e4.diffuse.value.copy(t3.color), e4.opacity.value = t3.opacity, e4.rotation.value = t3.rotation, t3.map && (e4.map.value = t3.map);
      t3.alphaMap && (e4.alphaMap.value = t3.alphaMap);
      let n3;
      t3.map ? n3 = t3.map : t3.alphaMap && (n3 = t3.alphaMap);
      void 0 !== n3 && (true === n3.matrixAutoUpdate && n3.updateMatrix(), e4.uvTransform.value.copy(n3.matrix));
    }(e3, i2) : i2.isShadowMaterial ? (e3.color.value.copy(i2.color), e3.opacity.value = i2.opacity) : i2.isShaderMaterial && (i2.uniformsNeedUpdate = false);
  } };
}
function ir(e2) {
  const t2 = void 0 !== (e2 = e2 || {}).canvas ? e2.canvas : function() {
    const e3 = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    return e3.style.display = "block", e3;
  }(), n2 = void 0 !== e2.context ? e2.context : null, a2 = void 0 !== e2.alpha && e2.alpha, o2 = void 0 === e2.depth || e2.depth, s2 = void 0 === e2.stencil || e2.stencil, l2 = void 0 !== e2.antialias && e2.antialias, c2 = void 0 === e2.premultipliedAlpha || e2.premultipliedAlpha, h2 = void 0 !== e2.preserveDrawingBuffer && e2.preserveDrawingBuffer, d2 = void 0 !== e2.powerPreference ? e2.powerPreference : "default", p2 = void 0 !== e2.failIfMajorPerformanceCaveat && e2.failIfMajorPerformanceCaveat;
  let m2 = null, g2 = null;
  const v2 = [], x2 = [];
  this.domElement = t2, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = 3e3, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1;
  const y2 = this;
  let _2 = false, b2 = 0, w2 = 0, M2 = null, S2 = -1, T2 = null;
  const E2 = new u(), L2 = new u();
  let R2 = null, A2 = t2.width, P2 = t2.height, C2 = 1, D2 = null, I2 = null;
  const N2 = new u(0, 0, A2, P2), O2 = new u(0, 0, A2, P2);
  let U2 = false;
  const F2 = new kt();
  let H2 = false, z2 = false;
  const B2 = new j(), G2 = new f(), k2 = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function V2() {
    return null === M2 ? C2 : 1;
  }
  let W2, q2, X2, Y2, Z2, J2, K2, Q2, $2, ee2, te2, ne2, ie2, re2, ae2, oe2, se2, le2, ce2, he2, ue2, de2, pe2 = n2;
  function fe2(e3, n3) {
    for (let i2 = 0; i2 < e3.length; i2++) {
      const r2 = e3[i2], a3 = t2.getContext(r2, n3);
      if (null !== a3) return a3;
    }
    return null;
  }
  try {
    const e3 = { alpha: a2, depth: o2, stencil: s2, antialias: l2, premultipliedAlpha: c2, preserveDrawingBuffer: h2, powerPreference: d2, failIfMajorPerformanceCaveat: p2 };
    if (t2.addEventListener("webglcontextlost", ve2, false), t2.addEventListener("webglcontextrestored", xe2, false), null === pe2) {
      const t3 = ["webgl2", "webgl", "experimental-webgl"];
      if (true === y2.isWebGL1Renderer && t3.shift(), pe2 = fe2(t3, e3), null === pe2) throw fe2(t3) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    void 0 === pe2.getShaderPrecisionFormat && (pe2.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (Pe2) {
    throw console.error("THREE.WebGLRenderer: " + Pe2.message), Pe2;
  }
  function me2() {
    W2 = new tn(pe2), q2 = new Qt(pe2, W2, e2), W2.init(q2), ue2 = new Ki(pe2, W2, q2), X2 = new Zi(pe2, W2, q2), Y2 = new an(pe2), Z2 = new Oi(), J2 = new Ji(pe2, W2, X2, Z2, q2, ue2, Y2), K2 = new en(y2), Q2 = new Wt(pe2, q2), de2 = new Jt(pe2, W2, Q2, q2), $2 = new nn(pe2, Q2, Y2, de2), ee2 = new cn(pe2, $2, Q2, Y2), le2 = new ln(pe2), ae2 = new $t(Z2), te2 = new Ni(y2, K2, W2, q2, de2, ae2), ne2 = new nr(Z2), ie2 = new zi(Z2), re2 = new ji(W2, q2), se2 = new Zt(y2, K2, X2, ee2, c2), oe2 = new Yi(y2, ee2, q2), ce2 = new Kt(pe2, W2, Y2, q2), he2 = new rn(pe2, W2, Y2, q2), Y2.programs = te2.programs, y2.capabilities = q2, y2.extensions = W2, y2.properties = Z2, y2.renderLists = ie2, y2.shadowMap = oe2, y2.state = X2, y2.info = Y2;
  }
  me2();
  const ge2 = new tr(y2, pe2);
  function ve2(e3) {
    e3.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _2 = true;
  }
  function xe2() {
    console.log("THREE.WebGLRenderer: Context Restored."), _2 = false;
    const e3 = Y2.autoReset, t3 = oe2.enabled, n3 = oe2.autoUpdate, i2 = oe2.needsUpdate, r2 = oe2.type;
    me2(), Y2.autoReset = e3, oe2.enabled = t3, oe2.autoUpdate = n3, oe2.needsUpdate = i2, oe2.type = r2;
  }
  function ye2(e3) {
    const t3 = e3.target;
    t3.removeEventListener("dispose", ye2), function(e4) {
      (function(e5) {
        const t4 = Z2.get(e5).programs;
        void 0 !== t4 && t4.forEach(function(e6) {
          te2.releaseProgram(e6);
        });
      })(e4), Z2.remove(e4);
    }(t3);
  }
  this.xr = ge2, this.getContext = function() {
    return pe2;
  }, this.getContextAttributes = function() {
    return pe2.getContextAttributes();
  }, this.forceContextLoss = function() {
    const e3 = W2.get("WEBGL_lose_context");
    e3 && e3.loseContext();
  }, this.forceContextRestore = function() {
    const e3 = W2.get("WEBGL_lose_context");
    e3 && e3.restoreContext();
  }, this.getPixelRatio = function() {
    return C2;
  }, this.setPixelRatio = function(e3) {
    void 0 !== e3 && (C2 = e3, this.setSize(A2, P2, false));
  }, this.getSize = function(e3) {
    return void 0 === e3 && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e3 = new r()), e3.set(A2, P2);
  }, this.setSize = function(e3, n3, i2) {
    ge2.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (A2 = e3, P2 = n3, t2.width = Math.floor(e3 * C2), t2.height = Math.floor(n3 * C2), false !== i2 && (t2.style.width = e3 + "px", t2.style.height = n3 + "px"), this.setViewport(0, 0, e3, n3));
  }, this.getDrawingBufferSize = function(e3) {
    return void 0 === e3 && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e3 = new r()), e3.set(A2 * C2, P2 * C2).floor();
  }, this.setDrawingBufferSize = function(e3, n3, i2) {
    A2 = e3, P2 = n3, C2 = i2, t2.width = Math.floor(e3 * i2), t2.height = Math.floor(n3 * i2), this.setViewport(0, 0, e3, n3);
  }, this.getCurrentViewport = function(e3) {
    return void 0 === e3 && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e3 = new u()), e3.copy(E2);
  }, this.getViewport = function(e3) {
    return e3.copy(N2);
  }, this.setViewport = function(e3, t3, n3, i2) {
    e3.isVector4 ? N2.set(e3.x, e3.y, e3.z, e3.w) : N2.set(e3, t3, n3, i2), X2.viewport(E2.copy(N2).multiplyScalar(C2).floor());
  }, this.getScissor = function(e3) {
    return e3.copy(O2);
  }, this.setScissor = function(e3, t3, n3, i2) {
    e3.isVector4 ? O2.set(e3.x, e3.y, e3.z, e3.w) : O2.set(e3, t3, n3, i2), X2.scissor(L2.copy(O2).multiplyScalar(C2).floor());
  }, this.getScissorTest = function() {
    return U2;
  }, this.setScissorTest = function(e3) {
    X2.setScissorTest(U2 = e3);
  }, this.setOpaqueSort = function(e3) {
    D2 = e3;
  }, this.setTransparentSort = function(e3) {
    I2 = e3;
  }, this.getClearColor = function(e3) {
    return void 0 === e3 && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), e3 = new Be()), e3.copy(se2.getClearColor());
  }, this.setClearColor = function() {
    se2.setClearColor.apply(se2, arguments);
  }, this.getClearAlpha = function() {
    return se2.getClearAlpha();
  }, this.setClearAlpha = function() {
    se2.setClearAlpha.apply(se2, arguments);
  }, this.clear = function(e3, t3, n3) {
    let i2 = 0;
    (void 0 === e3 || e3) && (i2 |= 16384), (void 0 === t3 || t3) && (i2 |= 256), (void 0 === n3 || n3) && (i2 |= 1024), pe2.clear(i2);
  }, this.clearColor = function() {
    this.clear(true, false, false);
  }, this.clearDepth = function() {
    this.clear(false, true, false);
  }, this.clearStencil = function() {
    this.clear(false, false, true);
  }, this.dispose = function() {
    t2.removeEventListener("webglcontextlost", ve2, false), t2.removeEventListener("webglcontextrestored", xe2, false), ie2.dispose(), re2.dispose(), Z2.dispose(), K2.dispose(), ee2.dispose(), de2.dispose(), ge2.dispose(), ge2.removeEventListener("sessionstart", be2), ge2.removeEventListener("sessionend", we2), Me2.stop();
  }, this.renderBufferImmediate = function(e3, t3) {
    de2.initAttributes();
    const n3 = Z2.get(e3);
    e3.hasPositions && !n3.position && (n3.position = pe2.createBuffer()), e3.hasNormals && !n3.normal && (n3.normal = pe2.createBuffer()), e3.hasUvs && !n3.uv && (n3.uv = pe2.createBuffer()), e3.hasColors && !n3.color && (n3.color = pe2.createBuffer());
    const i2 = t3.getAttributes();
    e3.hasPositions && (pe2.bindBuffer(34962, n3.position), pe2.bufferData(34962, e3.positionArray, 35048), de2.enableAttribute(i2.position), pe2.vertexAttribPointer(i2.position, 3, 5126, false, 0, 0)), e3.hasNormals && (pe2.bindBuffer(34962, n3.normal), pe2.bufferData(34962, e3.normalArray, 35048), de2.enableAttribute(i2.normal), pe2.vertexAttribPointer(i2.normal, 3, 5126, false, 0, 0)), e3.hasUvs && (pe2.bindBuffer(34962, n3.uv), pe2.bufferData(34962, e3.uvArray, 35048), de2.enableAttribute(i2.uv), pe2.vertexAttribPointer(i2.uv, 2, 5126, false, 0, 0)), e3.hasColors && (pe2.bindBuffer(34962, n3.color), pe2.bufferData(34962, e3.colorArray, 35048), de2.enableAttribute(i2.color), pe2.vertexAttribPointer(i2.color, 3, 5126, false, 0, 0)), de2.disableUnusedAttributes(), pe2.drawArrays(4, 0, e3.count), e3.count = 0;
  }, this.renderBufferDirect = function(e3, t3, n3, i2, r2, a3) {
    null === t3 && (t3 = k2);
    const o3 = r2.isMesh && r2.matrixWorld.determinant() < 0, s3 = Ae2(e3, t3, i2, r2);
    X2.setMaterial(i2, o3);
    let l3 = n3.index;
    const c3 = n3.attributes.position;
    if (null === l3) {
      if (void 0 === c3 || 0 === c3.count) return;
    } else if (0 === l3.count) return;
    let h3, u2 = 1;
    true === i2.wireframe && (l3 = $2.getWireframeAttribute(n3), u2 = 2), (i2.morphTargets || i2.morphNormals) && le2.update(r2, n3, i2, s3), de2.setup(r2, i2, s3, n3, l3);
    let d3 = ce2;
    null !== l3 && (h3 = Q2.get(l3), d3 = he2, d3.setIndex(h3));
    const p3 = null !== l3 ? l3.count : c3.count, f2 = n3.drawRange.start * u2, m3 = n3.drawRange.count * u2, g3 = null !== a3 ? a3.start * u2 : 0, v3 = null !== a3 ? a3.count * u2 : 1 / 0, x3 = Math.max(f2, g3), y3 = Math.min(p3, f2 + m3, g3 + v3) - 1, _3 = Math.max(0, y3 - x3 + 1);
    if (0 !== _3) {
      if (r2.isMesh) true === i2.wireframe ? (X2.setLineWidth(i2.wireframeLinewidth * V2()), d3.setMode(1)) : d3.setMode(4);
      else if (r2.isLine) {
        let e4 = i2.linewidth;
        void 0 === e4 && (e4 = 1), X2.setLineWidth(e4 * V2()), r2.isLineSegments ? d3.setMode(1) : r2.isLineLoop ? d3.setMode(2) : d3.setMode(3);
      } else r2.isPoints ? d3.setMode(0) : r2.isSprite && d3.setMode(4);
      if (r2.isInstancedMesh) d3.renderInstances(x3, _3, r2.count);
      else if (n3.isInstancedBufferGeometry) {
        const e4 = Math.min(n3.instanceCount, n3._maxInstanceCount);
        d3.renderInstances(x3, _3, e4);
      } else d3.render(x3, _3);
    }
  }, this.compile = function(e3, t3) {
    g2 = re2.get(e3), g2.init(), e3.traverseVisible(function(e4) {
      e4.isLight && e4.layers.test(t3.layers) && (g2.pushLight(e4), e4.castShadow && g2.pushShadow(e4));
    }), g2.setupLights(), e3.traverse(function(t4) {
      const n3 = t4.material;
      if (n3) if (Array.isArray(n3)) for (let i2 = 0; i2 < n3.length; i2++) {
        Le2(n3[i2], e3, t4);
      }
      else Le2(n3, e3, t4);
    });
  };
  let _e2 = null;
  function be2() {
    Me2.stop();
  }
  function we2() {
    Me2.start();
  }
  const Me2 = new Vt();
  function Se2(e3, t3, n3, i2) {
    if (false === e3.visible) return;
    if (e3.layers.test(t3.layers)) {
      if (e3.isGroup) n3 = e3.renderOrder;
      else if (e3.isLOD) true === e3.autoUpdate && e3.update(t3);
      else if (e3.isLight) g2.pushLight(e3), e3.castShadow && g2.pushShadow(e3);
      else if (e3.isSprite) {
        if (!e3.frustumCulled || F2.intersectsSprite(e3)) {
          i2 && G2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(B2);
          const t4 = ee2.update(e3), r3 = e3.material;
          r3.visible && m2.push(e3, t4, r3, n3, G2.z, null);
        }
      } else if (e3.isImmediateRenderObject) i2 && G2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(B2), m2.push(e3, null, e3.material, n3, G2.z, null);
      else if ((e3.isMesh || e3.isLine || e3.isPoints) && (e3.isSkinnedMesh && e3.skeleton.frame !== Y2.render.frame && (e3.skeleton.update(), e3.skeleton.frame = Y2.render.frame), !e3.frustumCulled || F2.intersectsObject(e3))) {
        i2 && G2.setFromMatrixPosition(e3.matrixWorld).applyMatrix4(B2);
        const t4 = ee2.update(e3), r3 = e3.material;
        if (Array.isArray(r3)) {
          const i3 = t4.groups;
          for (let a3 = 0, o3 = i3.length; a3 < o3; a3++) {
            const o4 = i3[a3], s3 = r3[o4.materialIndex];
            s3 && s3.visible && m2.push(e3, t4, s3, n3, G2.z, o4);
          }
        } else r3.visible && m2.push(e3, t4, r3, n3, G2.z, null);
      }
    }
    const r2 = e3.children;
    for (let a3 = 0, o3 = r2.length; a3 < o3; a3++) Se2(r2[a3], t3, n3, i2);
  }
  function Te2(e3, t3, n3) {
    const i2 = true === t3.isScene ? t3.overrideMaterial : null;
    for (let r2 = 0, a3 = e3.length; r2 < a3; r2++) {
      const a4 = e3[r2], o3 = a4.object, s3 = a4.geometry, l3 = null === i2 ? a4.material : i2, c3 = a4.group;
      if (n3.isArrayCamera) {
        const e4 = n3.cameras;
        for (let n4 = 0, i3 = e4.length; n4 < i3; n4++) {
          const i4 = e4[n4];
          o3.layers.test(i4.layers) && (X2.viewport(E2.copy(i4.viewport)), g2.setupLightsView(i4), Ee2(o3, t3, i4, s3, l3, c3));
        }
      } else Ee2(o3, t3, n3, s3, l3, c3);
    }
  }
  function Ee2(e3, t3, n3, i2, r2, a3) {
    if (e3.onBeforeRender(y2, t3, n3, i2, r2, a3), e3.modelViewMatrix.multiplyMatrices(n3.matrixWorldInverse, e3.matrixWorld), e3.normalMatrix.getNormalMatrix(e3.modelViewMatrix), e3.isImmediateRenderObject) {
      const i3 = Ae2(n3, t3, r2, e3);
      X2.setMaterial(r2), de2.reset(), function(e4, t4) {
        e4.render(function(e5) {
          y2.renderBufferImmediate(e5, t4);
        });
      }(e3, i3);
    } else y2.renderBufferDirect(n3, t3, i2, r2, e3, a3);
    e3.onAfterRender(y2, t3, n3, i2, r2, a3);
  }
  function Le2(e3, t3, n3) {
    true !== t3.isScene && (t3 = k2);
    const i2 = Z2.get(e3), r2 = g2.state.lights, a3 = g2.state.shadowsArray, o3 = r2.state.version, s3 = te2.getParameters(e3, r2.state, a3, t3, n3), l3 = te2.getProgramCacheKey(s3);
    let c3 = i2.programs;
    i2.environment = e3.isMeshStandardMaterial ? t3.environment : null, i2.fog = t3.fog, i2.envMap = K2.get(e3.envMap || i2.environment), void 0 === c3 && (e3.addEventListener("dispose", ye2), c3 = /* @__PURE__ */ new Map(), i2.programs = c3);
    let h3 = c3.get(l3);
    if (void 0 !== h3) {
      if (i2.currentProgram === h3 && i2.lightsStateVersion === o3) return Re2(e3, s3), h3;
    } else s3.uniforms = te2.getUniforms(e3), e3.onBeforeCompile(s3, y2), h3 = te2.acquireProgram(s3, l3), c3.set(l3, h3), i2.uniforms = s3.uniforms;
    const u2 = i2.uniforms;
    (e3.isShaderMaterial || e3.isRawShaderMaterial) && true !== e3.clipping || (u2.clippingPlanes = ae2.uniform), Re2(e3, s3), i2.needsLights = function(e4) {
      return e4.isMeshLambertMaterial || e4.isMeshToonMaterial || e4.isMeshPhongMaterial || e4.isMeshStandardMaterial || e4.isShadowMaterial || e4.isShaderMaterial && true === e4.lights;
    }(e3), i2.lightsStateVersion = o3, i2.needsLights && (u2.ambientLightColor.value = r2.state.ambient, u2.lightProbe.value = r2.state.probe, u2.directionalLights.value = r2.state.directional, u2.directionalLightShadows.value = r2.state.directionalShadow, u2.spotLights.value = r2.state.spot, u2.spotLightShadows.value = r2.state.spotShadow, u2.rectAreaLights.value = r2.state.rectArea, u2.ltc_1.value = r2.state.rectAreaLTC1, u2.ltc_2.value = r2.state.rectAreaLTC2, u2.pointLights.value = r2.state.point, u2.pointLightShadows.value = r2.state.pointShadow, u2.hemisphereLights.value = r2.state.hemi, u2.directionalShadowMap.value = r2.state.directionalShadowMap, u2.directionalShadowMatrix.value = r2.state.directionalShadowMatrix, u2.spotShadowMap.value = r2.state.spotShadowMap, u2.spotShadowMatrix.value = r2.state.spotShadowMatrix, u2.pointShadowMap.value = r2.state.pointShadowMap, u2.pointShadowMatrix.value = r2.state.pointShadowMatrix);
    const d3 = h3.getUniforms(), p3 = pi.seqWithValue(d3.seq, u2);
    return i2.currentProgram = h3, i2.uniformsList = p3, h3;
  }
  function Re2(e3, t3) {
    const n3 = Z2.get(e3);
    n3.outputEncoding = t3.outputEncoding, n3.instancing = t3.instancing, n3.numClippingPlanes = t3.numClippingPlanes, n3.numIntersection = t3.numClipIntersection, n3.vertexAlphas = t3.vertexAlphas;
  }
  function Ae2(e3, t3, n3, r2) {
    true !== t3.isScene && (t3 = k2), J2.resetTextureUnits();
    const a3 = t3.fog, o3 = n3.isMeshStandardMaterial ? t3.environment : null, s3 = null === M2 ? y2.outputEncoding : M2.texture.encoding, l3 = K2.get(n3.envMap || o3), c3 = true === n3.vertexColors && r2.geometry.attributes.color && 4 === r2.geometry.attributes.color.itemSize, h3 = Z2.get(n3), u2 = g2.state.lights;
    if (true === H2 && (true === z2 || e3 !== T2)) {
      const t4 = e3 === T2 && n3.id === S2;
      ae2.setState(n3, e3, t4);
    }
    let d3 = false;
    n3.version === h3.__version ? h3.needsLights && h3.lightsStateVersion !== u2.state.version || h3.outputEncoding !== s3 || r2.isInstancedMesh && false === h3.instancing ? d3 = true : r2.isInstancedMesh || true !== h3.instancing ? h3.envMap !== l3 || n3.fog && h3.fog !== a3 ? d3 = true : void 0 === h3.numClippingPlanes || h3.numClippingPlanes === ae2.numPlanes && h3.numIntersection === ae2.numIntersection ? h3.vertexAlphas !== c3 && (d3 = true) : d3 = true : d3 = true : (d3 = true, h3.__version = n3.version);
    let p3 = h3.currentProgram;
    true === d3 && (p3 = Le2(n3, t3, r2));
    let f2 = false, m3 = false, v3 = false;
    const x3 = p3.getUniforms(), _3 = h3.uniforms;
    if (X2.useProgram(p3.program) && (f2 = true, m3 = true, v3 = true), n3.id !== S2 && (S2 = n3.id, m3 = true), f2 || T2 !== e3) {
      if (x3.setValue(pe2, "projectionMatrix", e3.projectionMatrix), q2.logarithmicDepthBuffer && x3.setValue(pe2, "logDepthBufFC", 2 / (Math.log(e3.far + 1) / Math.LN2)), T2 !== e3 && (T2 = e3, m3 = true, v3 = true), n3.isShaderMaterial || n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshStandardMaterial || n3.envMap) {
        const t4 = x3.map.cameraPosition;
        void 0 !== t4 && t4.setValue(pe2, G2.setFromMatrixPosition(e3.matrixWorld));
      }
      (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial) && x3.setValue(pe2, "isOrthographic", true === e3.isOrthographicCamera), (n3.isMeshPhongMaterial || n3.isMeshToonMaterial || n3.isMeshLambertMaterial || n3.isMeshBasicMaterial || n3.isMeshStandardMaterial || n3.isShaderMaterial || n3.isShadowMaterial || n3.skinning) && x3.setValue(pe2, "viewMatrix", e3.matrixWorldInverse);
    }
    if (n3.skinning) {
      x3.setOptional(pe2, r2, "bindMatrix"), x3.setOptional(pe2, r2, "bindMatrixInverse");
      const e4 = r2.skeleton;
      if (e4) {
        const t4 = e4.bones;
        if (q2.floatVertexTextures) {
          if (null === e4.boneTexture) {
            let n4 = Math.sqrt(4 * t4.length);
            n4 = i.ceilPowerOfTwo(n4), n4 = Math.max(n4, 4);
            const r3 = new Float32Array(n4 * n4 * 4);
            r3.set(e4.boneMatrices);
            const a4 = new zt(r3, n4, n4, 1023, 1015);
            e4.boneMatrices = r3, e4.boneTexture = a4, e4.boneTextureSize = n4;
          }
          x3.setValue(pe2, "boneTexture", e4.boneTexture, J2), x3.setValue(pe2, "boneTextureSize", e4.boneTextureSize);
        } else x3.setOptional(pe2, e4, "boneMatrices");
      }
    }
    var b3, w3;
    return (m3 || h3.receiveShadow !== r2.receiveShadow) && (h3.receiveShadow = r2.receiveShadow, x3.setValue(pe2, "receiveShadow", r2.receiveShadow)), m3 && (x3.setValue(pe2, "toneMappingExposure", y2.toneMappingExposure), h3.needsLights && (w3 = v3, (b3 = _3).ambientLightColor.needsUpdate = w3, b3.lightProbe.needsUpdate = w3, b3.directionalLights.needsUpdate = w3, b3.directionalLightShadows.needsUpdate = w3, b3.pointLights.needsUpdate = w3, b3.pointLightShadows.needsUpdate = w3, b3.spotLights.needsUpdate = w3, b3.spotLightShadows.needsUpdate = w3, b3.rectAreaLights.needsUpdate = w3, b3.hemisphereLights.needsUpdate = w3), a3 && n3.fog && ne2.refreshFogUniforms(_3, a3), ne2.refreshMaterialUniforms(_3, n3, C2, P2), pi.upload(pe2, h3.uniformsList, _3, J2)), n3.isShaderMaterial && true === n3.uniformsNeedUpdate && (pi.upload(pe2, h3.uniformsList, _3, J2), n3.uniformsNeedUpdate = false), n3.isSpriteMaterial && x3.setValue(pe2, "center", r2.center), x3.setValue(pe2, "modelViewMatrix", r2.modelViewMatrix), x3.setValue(pe2, "normalMatrix", r2.normalMatrix), x3.setValue(pe2, "modelMatrix", r2.matrixWorld), p3;
  }
  Me2.setAnimationLoop(function(e3) {
    _e2 && _e2(e3);
  }), "undefined" != typeof window && Me2.setContext(window), this.setAnimationLoop = function(e3) {
    _e2 = e3, ge2.setAnimationLoop(e3), null === e3 ? Me2.stop() : Me2.start();
  }, ge2.addEventListener("sessionstart", be2), ge2.addEventListener("sessionend", we2), this.render = function(e3, t3) {
    let n3, i2;
    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n3 = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i2 = arguments[3]), void 0 !== t3 && true !== t3.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    if (true === _2) return;
    true === e3.autoUpdate && e3.updateMatrixWorld(), null === t3.parent && t3.updateMatrixWorld(), true === ge2.enabled && true === ge2.isPresenting && (t3 = ge2.getCamera(t3)), true === e3.isScene && e3.onBeforeRender(y2, e3, t3, n3 || M2), g2 = re2.get(e3, x2.length), g2.init(), x2.push(g2), B2.multiplyMatrices(t3.projectionMatrix, t3.matrixWorldInverse), F2.setFromProjectionMatrix(B2), z2 = this.localClippingEnabled, H2 = ae2.init(this.clippingPlanes, z2, t3), m2 = ie2.get(e3, v2.length), m2.init(), v2.push(m2), Se2(e3, t3, 0, y2.sortObjects), m2.finish(), true === y2.sortObjects && m2.sort(D2, I2), true === H2 && ae2.beginShadows();
    const r2 = g2.state.shadowsArray;
    oe2.render(r2, e3, t3), g2.setupLights(), g2.setupLightsView(t3), true === H2 && ae2.endShadows(), true === this.info.autoReset && this.info.reset(), void 0 !== n3 && this.setRenderTarget(n3), se2.render(m2, e3, t3, i2);
    const a3 = m2.opaque, o3 = m2.transparent;
    a3.length > 0 && Te2(a3, e3, t3), o3.length > 0 && Te2(o3, e3, t3), null !== M2 && (J2.updateRenderTargetMipmap(M2), J2.updateMultisampleRenderTarget(M2)), true === e3.isScene && e3.onAfterRender(y2, e3, t3), X2.buffers.depth.setTest(true), X2.buffers.depth.setMask(true), X2.buffers.color.setMask(true), X2.setPolygonOffset(false), de2.resetDefaultState(), S2 = -1, T2 = null, x2.pop(), g2 = x2.length > 0 ? x2[x2.length - 1] : null, v2.pop(), m2 = v2.length > 0 ? v2[v2.length - 1] : null;
  }, this.getActiveCubeFace = function() {
    return b2;
  }, this.getActiveMipmapLevel = function() {
    return w2;
  }, this.getRenderTarget = function() {
    return M2;
  }, this.setRenderTarget = function(e3, t3 = 0, n3 = 0) {
    M2 = e3, b2 = t3, w2 = n3, e3 && void 0 === Z2.get(e3).__webglFramebuffer && J2.setupRenderTarget(e3);
    let i2 = null, r2 = false, a3 = false;
    if (e3) {
      const n4 = e3.texture;
      (n4.isDataTexture3D || n4.isDataTexture2DArray) && (a3 = true);
      const o3 = Z2.get(e3).__webglFramebuffer;
      e3.isWebGLCubeRenderTarget ? (i2 = o3[t3], r2 = true) : i2 = e3.isWebGLMultisampleRenderTarget ? Z2.get(e3).__webglMultisampledFramebuffer : o3, E2.copy(e3.viewport), L2.copy(e3.scissor), R2 = e3.scissorTest;
    } else E2.copy(N2).multiplyScalar(C2).floor(), L2.copy(O2).multiplyScalar(C2).floor(), R2 = U2;
    if (X2.bindFramebuffer(36160, i2), X2.viewport(E2), X2.scissor(L2), X2.setScissorTest(R2), r2) {
      const i3 = Z2.get(e3.texture);
      pe2.framebufferTexture2D(36160, 36064, 34069 + t3, i3.__webglTexture, n3);
    } else if (a3) {
      const i3 = Z2.get(e3.texture), r3 = t3 || 0;
      pe2.framebufferTextureLayer(36160, 36064, i3.__webglTexture, n3 || 0, r3);
    }
  }, this.readRenderTargetPixels = function(e3, t3, n3, i2, r2, a3, o3) {
    if (!e3 || !e3.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
    let s3 = Z2.get(e3).__webglFramebuffer;
    if (e3.isWebGLCubeRenderTarget && void 0 !== o3 && (s3 = s3[o3]), s3) {
      X2.bindFramebuffer(36160, s3);
      try {
        const o4 = e3.texture, s4 = o4.format, l3 = o4.type;
        if (1023 !== s4 && ue2.convert(s4) !== pe2.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
        const c3 = 1016 === l3 && (W2.has("EXT_color_buffer_half_float") || q2.isWebGL2 && W2.has("EXT_color_buffer_float"));
        if (!(1009 === l3 || ue2.convert(l3) === pe2.getParameter(35738) || 1015 === l3 && (q2.isWebGL2 || W2.has("OES_texture_float") || W2.has("WEBGL_color_buffer_float")) || c3)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
        36053 === pe2.checkFramebufferStatus(36160) ? t3 >= 0 && t3 <= e3.width - i2 && n3 >= 0 && n3 <= e3.height - r2 && pe2.readPixels(t3, n3, i2, r2, ue2.convert(s4), ue2.convert(l3), a3) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
      } finally {
        const e4 = null !== M2 ? Z2.get(M2).__webglFramebuffer : null;
        X2.bindFramebuffer(36160, e4);
      }
    }
  }, this.copyFramebufferToTexture = function(e3, t3, n3 = 0) {
    const i2 = Math.pow(2, -n3), r2 = Math.floor(t3.image.width * i2), a3 = Math.floor(t3.image.height * i2), o3 = ue2.convert(t3.format);
    J2.setTexture2D(t3, 0), pe2.copyTexImage2D(3553, n3, o3, e3.x, e3.y, r2, a3, 0), X2.unbindTexture();
  }, this.copyTextureToTexture = function(e3, t3, n3, i2 = 0) {
    const r2 = t3.image.width, a3 = t3.image.height, o3 = ue2.convert(n3.format), s3 = ue2.convert(n3.type);
    J2.setTexture2D(n3, 0), pe2.pixelStorei(37440, n3.flipY), pe2.pixelStorei(37441, n3.premultiplyAlpha), pe2.pixelStorei(3317, n3.unpackAlignment), t3.isDataTexture ? pe2.texSubImage2D(3553, i2, e3.x, e3.y, r2, a3, o3, s3, t3.image.data) : t3.isCompressedTexture ? pe2.compressedTexSubImage2D(3553, i2, e3.x, e3.y, t3.mipmaps[0].width, t3.mipmaps[0].height, o3, t3.mipmaps[0].data) : pe2.texSubImage2D(3553, i2, e3.x, e3.y, o3, s3, t3.image), 0 === i2 && n3.generateMipmaps && pe2.generateMipmap(3553), X2.unbindTexture();
  }, this.copyTextureToTexture3D = function(e3, t3, n3, i2, r2 = 0) {
    if (y2.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
    const { width: a3, height: o3, data: s3 } = n3.image, l3 = ue2.convert(i2.format), c3 = ue2.convert(i2.type);
    let h3;
    if (i2.isDataTexture3D) J2.setTexture3D(i2, 0), h3 = 32879;
    else {
      if (!i2.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      J2.setTexture2DArray(i2, 0), h3 = 35866;
    }
    pe2.pixelStorei(37440, i2.flipY), pe2.pixelStorei(37441, i2.premultiplyAlpha), pe2.pixelStorei(3317, i2.unpackAlignment);
    const u2 = pe2.getParameter(3314), d3 = pe2.getParameter(32878), p3 = pe2.getParameter(3316), f2 = pe2.getParameter(3315), m3 = pe2.getParameter(32877);
    pe2.pixelStorei(3314, a3), pe2.pixelStorei(32878, o3), pe2.pixelStorei(3316, e3.min.x), pe2.pixelStorei(3315, e3.min.y), pe2.pixelStorei(32877, e3.min.z), pe2.texSubImage3D(h3, r2, t3.x, t3.y, t3.z, e3.max.x - e3.min.x + 1, e3.max.y - e3.min.y + 1, e3.max.z - e3.min.z + 1, l3, c3, s3), pe2.pixelStorei(3314, u2), pe2.pixelStorei(32878, d3), pe2.pixelStorei(3316, p3), pe2.pixelStorei(3315, f2), pe2.pixelStorei(32877, m3), 0 === r2 && i2.generateMipmaps && pe2.generateMipmap(h3), X2.unbindTexture();
  }, this.initTexture = function(e3) {
    J2.setTexture2D(e3, 0), X2.unbindTexture();
  }, this.resetState = function() {
    b2 = 0, w2 = 0, M2 = null, X2.reset(), de2.reset();
  }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
$i.prototype.isGroup = true, Object.assign(er.prototype, { constructor: er, getHandSpace: function() {
  return null === this._hand && (this._hand = new $i(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
}, getTargetRaySpace: function() {
  return null === this._targetRay && (this._targetRay = new $i(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false), this._targetRay;
}, getGripSpace: function() {
  return null === this._grip && (this._grip = new $i(), this._grip.matrixAutoUpdate = false, this._grip.visible = false), this._grip;
}, dispatchEvent: function(e2) {
  return null !== this._targetRay && this._targetRay.dispatchEvent(e2), null !== this._grip && this._grip.dispatchEvent(e2), null !== this._hand && this._hand.dispatchEvent(e2), this;
}, disconnect: function(e2) {
  return this.dispatchEvent({ type: "disconnected", data: e2 }), null !== this._targetRay && (this._targetRay.visible = false), null !== this._grip && (this._grip.visible = false), null !== this._hand && (this._hand.visible = false), this;
}, update: function(e2, t2, n2) {
  let i2 = null, r2 = null, a2 = null;
  const o2 = this._targetRay, s2 = this._grip, l2 = this._hand;
  if (e2 && "visible-blurred" !== t2.session.visibilityState) if (null !== o2 && (i2 = t2.getPose(e2.targetRaySpace, n2), null !== i2 && (o2.matrix.fromArray(i2.transform.matrix), o2.matrix.decompose(o2.position, o2.rotation, o2.scale))), l2 && e2.hand) {
    a2 = true;
    for (const a3 of e2.hand.values()) {
      const e3 = t2.getJointPose(a3, n2);
      if (void 0 === l2.joints[a3.jointName]) {
        const e4 = new $i();
        e4.matrixAutoUpdate = false, e4.visible = false, l2.joints[a3.jointName] = e4, l2.add(e4);
      }
      const i4 = l2.joints[a3.jointName];
      null !== e3 && (i4.matrix.fromArray(e3.transform.matrix), i4.matrix.decompose(i4.position, i4.rotation, i4.scale), i4.jointRadius = e3.radius), i4.visible = null !== e3;
    }
    const i3 = l2.joints["index-finger-tip"], r3 = l2.joints["thumb-tip"], o3 = i3.position.distanceTo(r3.position), s3 = 0.02, c2 = 5e-3;
    l2.inputState.pinching && o3 > s3 + c2 ? (l2.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e2.handedness, target: this })) : !l2.inputState.pinching && o3 <= s3 - c2 && (l2.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e2.handedness, target: this }));
  } else null !== s2 && e2.gripSpace && (r2 = t2.getPose(e2.gripSpace, n2), null !== r2 && (s2.matrix.fromArray(r2.transform.matrix), s2.matrix.decompose(s2.position, s2.rotation, s2.scale)));
  return null !== o2 && (o2.visible = null !== i2), null !== s2 && (s2.visible = null !== r2), null !== l2 && (l2.visible = null !== a2), this;
} }), Object.assign(tr.prototype, e.prototype);
var rr = class extends ge {
  constructor() {
    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e2, t2) {
    return super.copy(e2, t2), null !== e2.background && (this.background = e2.background.clone()), null !== e2.environment && (this.environment = e2.environment.clone()), null !== e2.fog && (this.fog = e2.fog.clone()), null !== e2.overrideMaterial && (this.overrideMaterial = e2.overrideMaterial.clone()), this.autoUpdate = e2.autoUpdate, this.matrixAutoUpdate = e2.matrixAutoUpdate, this;
  }
  toJSON(e2) {
    const t2 = super.toJSON(e2);
    return null !== this.background && (t2.object.background = this.background.toJSON(e2)), null !== this.environment && (t2.object.environment = this.environment.toJSON(e2)), null !== this.fog && (t2.object.fog = this.fog.toJSON()), t2;
  }
};
function ar(e2, t2) {
  this.array = e2, this.stride = t2, this.count = void 0 !== e2 ? e2.length / t2 : 0, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = i.generateUUID();
}
rr.prototype.isScene = true, Object.defineProperty(ar.prototype, "needsUpdate", { set: function(e2) {
  true === e2 && this.version++;
} }), Object.assign(ar.prototype, { isInterleavedBuffer: true, onUploadCallback: function() {
}, setUsage: function(e2) {
  return this.usage = e2, this;
}, copy: function(e2) {
  return this.array = new e2.array.constructor(e2.array), this.count = e2.count, this.stride = e2.stride, this.usage = e2.usage, this;
}, copyAt: function(e2, t2, n2) {
  e2 *= this.stride, n2 *= t2.stride;
  for (let i2 = 0, r2 = this.stride; i2 < r2; i2++) this.array[e2 + i2] = t2.array[n2 + i2];
  return this;
}, set: function(e2, t2 = 0) {
  return this.array.set(e2, t2), this;
}, clone: function(e2) {
  void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = i.generateUUID()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
  const t2 = new ar(new this.array.constructor(e2.arrayBuffers[this.array.buffer._uuid]), this.stride);
  return t2.setUsage(this.usage), t2;
}, onUpload: function(e2) {
  return this.onUploadCallback = e2, this;
}, toJSON: function(e2) {
  return void 0 === e2.arrayBuffers && (e2.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = i.generateUUID()), void 0 === e2.arrayBuffers[this.array.buffer._uuid] && (e2.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
} });
var or = new f();
function sr(e2, t2, n2, i2) {
  this.name = "", this.data = e2, this.itemSize = t2, this.offset = n2, this.normalized = true === i2;
}
Object.defineProperties(sr.prototype, { count: { get: function() {
  return this.data.count;
} }, array: { get: function() {
  return this.data.array;
} }, needsUpdate: { set: function(e2) {
  this.data.needsUpdate = e2;
} } }), Object.assign(sr.prototype, { isInterleavedBufferAttribute: true, applyMatrix4: function(e2) {
  for (let t2 = 0, n2 = this.data.count; t2 < n2; t2++) or.x = this.getX(t2), or.y = this.getY(t2), or.z = this.getZ(t2), or.applyMatrix4(e2), this.setXYZ(t2, or.x, or.y, or.z);
  return this;
}, applyNormalMatrix: function(e2) {
  for (let t2 = 0, n2 = this.count; t2 < n2; t2++) or.x = this.getX(t2), or.y = this.getY(t2), or.z = this.getZ(t2), or.applyNormalMatrix(e2), this.setXYZ(t2, or.x, or.y, or.z);
  return this;
}, transformDirection: function(e2) {
  for (let t2 = 0, n2 = this.count; t2 < n2; t2++) or.x = this.getX(t2), or.y = this.getY(t2), or.z = this.getZ(t2), or.transformDirection(e2), this.setXYZ(t2, or.x, or.y, or.z);
  return this;
}, setX: function(e2, t2) {
  return this.data.array[e2 * this.data.stride + this.offset] = t2, this;
}, setY: function(e2, t2) {
  return this.data.array[e2 * this.data.stride + this.offset + 1] = t2, this;
}, setZ: function(e2, t2) {
  return this.data.array[e2 * this.data.stride + this.offset + 2] = t2, this;
}, setW: function(e2, t2) {
  return this.data.array[e2 * this.data.stride + this.offset + 3] = t2, this;
}, getX: function(e2) {
  return this.data.array[e2 * this.data.stride + this.offset];
}, getY: function(e2) {
  return this.data.array[e2 * this.data.stride + this.offset + 1];
}, getZ: function(e2) {
  return this.data.array[e2 * this.data.stride + this.offset + 2];
}, getW: function(e2) {
  return this.data.array[e2 * this.data.stride + this.offset + 3];
}, setXY: function(e2, t2, n2) {
  return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = n2, this;
}, setXYZ: function(e2, t2, n2, i2) {
  return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = n2, this.data.array[e2 + 2] = i2, this;
}, setXYZW: function(e2, t2, n2, i2, r2) {
  return e2 = e2 * this.data.stride + this.offset, this.data.array[e2 + 0] = t2, this.data.array[e2 + 1] = n2, this.data.array[e2 + 2] = i2, this.data.array[e2 + 3] = r2, this;
}, clone: function(e2) {
  if (void 0 === e2) {
    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
    const e3 = [];
    for (let t2 = 0; t2 < this.count; t2++) {
      const n2 = t2 * this.data.stride + this.offset;
      for (let t3 = 0; t3 < this.itemSize; t3++) e3.push(this.data.array[n2 + t3]);
    }
    return new We(new this.array.constructor(e3), this.itemSize, this.normalized);
  }
  return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.clone(e2)), new sr(e2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
}, toJSON: function(e2) {
  if (void 0 === e2) {
    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
    const e3 = [];
    for (let t2 = 0; t2 < this.count; t2++) {
      const n2 = t2 * this.data.stride + this.offset;
      for (let t3 = 0; t3 < this.itemSize; t3++) e3.push(this.data.array[n2 + t3]);
    }
    return { itemSize: this.itemSize, type: this.array.constructor.name, array: e3, normalized: this.normalized };
  }
  return void 0 === e2.interleavedBuffers && (e2.interleavedBuffers = {}), void 0 === e2.interleavedBuffers[this.data.uuid] && (e2.interleavedBuffers[this.data.uuid] = this.data.toJSON(e2)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
} });
var lr = new f();
var cr = new u();
var hr = new u();
var ur = new f();
var dr = new j();
function pr(e2, t2) {
  Lt.call(this, e2, t2), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new j(), this.bindMatrixInverse = new j();
}
function fr() {
  ge.call(this), this.type = "Bone";
}
pr.prototype = Object.assign(Object.create(Lt.prototype), { constructor: pr, isSkinnedMesh: true, copy: function(e2) {
  return Lt.prototype.copy.call(this, e2), this.bindMode = e2.bindMode, this.bindMatrix.copy(e2.bindMatrix), this.bindMatrixInverse.copy(e2.bindMatrixInverse), this.skeleton = e2.skeleton, this;
}, bind: function(e2, t2) {
  this.skeleton = e2, void 0 === t2 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t2 = this.matrixWorld), this.bindMatrix.copy(t2), this.bindMatrixInverse.copy(t2).invert();
}, pose: function() {
  this.skeleton.pose();
}, normalizeSkinWeights: function() {
  const e2 = new u(), t2 = this.geometry.attributes.skinWeight;
  for (let n2 = 0, i2 = t2.count; n2 < i2; n2++) {
    e2.x = t2.getX(n2), e2.y = t2.getY(n2), e2.z = t2.getZ(n2), e2.w = t2.getW(n2);
    const i3 = 1 / e2.manhattanLength();
    i3 !== 1 / 0 ? e2.multiplyScalar(i3) : e2.set(1, 0, 0, 0), t2.setXYZW(n2, e2.x, e2.y, e2.z, e2.w);
  }
}, updateMatrixWorld: function(e2) {
  Lt.prototype.updateMatrixWorld.call(this, e2), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
}, boneTransform: function(e2, t2) {
  const n2 = this.skeleton, i2 = this.geometry;
  cr.fromBufferAttribute(i2.attributes.skinIndex, e2), hr.fromBufferAttribute(i2.attributes.skinWeight, e2), lr.fromBufferAttribute(i2.attributes.position, e2).applyMatrix4(this.bindMatrix), t2.set(0, 0, 0);
  for (let r2 = 0; r2 < 4; r2++) {
    const e3 = hr.getComponent(r2);
    if (0 !== e3) {
      const i3 = cr.getComponent(r2);
      dr.multiplyMatrices(n2.bones[i3].matrixWorld, n2.boneInverses[i3]), t2.addScaledVector(ur.copy(lr).applyMatrix4(dr), e3);
    }
  }
  return t2.applyMatrix4(this.bindMatrixInverse);
} }), fr.prototype = Object.assign(Object.create(ge.prototype), { constructor: fr, isBone: true });
var mr = new j();
var gr = new j();
var vr = class _vr {
  constructor(e2 = [], t2 = []) {
    this.uuid = i.generateUUID(), this.bones = e2.slice(0), this.boneInverses = t2, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e2 = this.bones, t2 = this.boneInverses;
    if (this.boneMatrices = new Float32Array(16 * e2.length), 0 === t2.length) this.calculateInverses();
    else if (e2.length !== t2.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let e3 = 0, t3 = this.bones.length; e3 < t3; e3++) this.boneInverses.push(new j());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
      const t3 = new j();
      this.bones[e2] && t3.copy(this.bones[e2].matrixWorld).invert(), this.boneInverses.push(t3);
    }
  }
  pose() {
    for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
      const t3 = this.bones[e2];
      t3 && t3.matrixWorld.copy(this.boneInverses[e2]).invert();
    }
    for (let e2 = 0, t2 = this.bones.length; e2 < t2; e2++) {
      const t3 = this.bones[e2];
      t3 && (t3.parent && t3.parent.isBone ? (t3.matrix.copy(t3.parent.matrixWorld).invert(), t3.matrix.multiply(t3.matrixWorld)) : t3.matrix.copy(t3.matrixWorld), t3.matrix.decompose(t3.position, t3.quaternion, t3.scale));
    }
  }
  update() {
    const e2 = this.bones, t2 = this.boneInverses, n2 = this.boneMatrices, i2 = this.boneTexture;
    for (let r2 = 0, a2 = e2.length; r2 < a2; r2++) {
      const i3 = e2[r2] ? e2[r2].matrixWorld : gr;
      mr.multiplyMatrices(i3, t2[r2]), mr.toArray(n2, 16 * r2);
    }
    null !== i2 && (i2.needsUpdate = true);
  }
  clone() {
    return new _vr(this.bones, this.boneInverses);
  }
  getBoneByName(e2) {
    for (let t2 = 0, n2 = this.bones.length; t2 < n2; t2++) {
      const n3 = this.bones[t2];
      if (n3.name === e2) return n3;
    }
  }
  dispose() {
    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e2, t2) {
    this.uuid = e2.uuid;
    for (let n2 = 0, i2 = e2.bones.length; n2 < i2; n2++) {
      const i3 = e2.bones[n2];
      let r2 = t2[i3];
      void 0 === r2 && (console.warn("THREE.Skeleton: No bone found with UUID:", i3), r2 = new fr()), this.bones.push(r2), this.boneInverses.push(new j().fromArray(e2.boneInverses[n2]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e2 = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    e2.uuid = this.uuid;
    const t2 = this.bones, n2 = this.boneInverses;
    for (let i2 = 0, r2 = t2.length; i2 < r2; i2++) {
      const r3 = t2[i2];
      e2.bones.push(r3.uuid);
      const a2 = n2[i2];
      e2.boneInverses.push(a2.toArray());
    }
    return e2;
  }
};
var xr = new j();
var yr = new j();
var _r = [];
var br = new Lt();
function wr(e2, t2, n2) {
  Lt.call(this, e2, t2), this.instanceMatrix = new We(new Float32Array(16 * n2), 16), this.instanceColor = null, this.count = n2, this.frustumCulled = false;
}
wr.prototype = Object.assign(Object.create(Lt.prototype), { constructor: wr, isInstancedMesh: true, copy: function(e2) {
  return Lt.prototype.copy.call(this, e2), this.instanceMatrix.copy(e2.instanceMatrix), null !== e2.instanceColor && (this.instanceColor = e2.instanceColor.clone()), this.count = e2.count, this;
}, getColorAt: function(e2, t2) {
  t2.fromArray(this.instanceColor.array, 3 * e2);
}, getMatrixAt: function(e2, t2) {
  t2.fromArray(this.instanceMatrix.array, 16 * e2);
}, raycast: function(e2, t2) {
  const n2 = this.matrixWorld, i2 = this.count;
  if (br.geometry = this.geometry, br.material = this.material, void 0 !== br.material) for (let r2 = 0; r2 < i2; r2++) {
    this.getMatrixAt(r2, xr), yr.multiplyMatrices(n2, xr), br.matrixWorld = yr, br.raycast(e2, _r);
    for (let e3 = 0, n3 = _r.length; e3 < n3; e3++) {
      const n4 = _r[e3];
      n4.instanceId = r2, n4.object = this, t2.push(n4);
    }
    _r.length = 0;
  }
}, setColorAt: function(e2, t2) {
  null === this.instanceColor && (this.instanceColor = new We(new Float32Array(3 * this.count), 3)), t2.toArray(this.instanceColor.array, 3 * e2);
}, setMatrixAt: function(e2, t2) {
  t2.toArray(this.instanceMatrix.array, 16 * e2);
}, updateMorphTargets: function() {
}, dispose: function() {
  this.dispatchEvent({ type: "dispose" });
} });
var Mr = class extends Ie {
  constructor(e2) {
    super(), this.type = "LineBasicMaterial", this.color = new Be(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = false, this.setValues(e2);
  }
  copy(e2) {
    return super.copy(e2), this.color.copy(e2.color), this.linewidth = e2.linewidth, this.linecap = e2.linecap, this.linejoin = e2.linejoin, this.morphTargets = e2.morphTargets, this;
  }
};
Mr.prototype.isLineBasicMaterial = true;
var Sr = new f();
var Tr = new f();
var Er = new j();
var Lr = new W();
var Rr = new U();
function Ar(e2 = new ct(), t2 = new Mr()) {
  ge.call(this), this.type = "Line", this.geometry = e2, this.material = t2, this.updateMorphTargets();
}
Ar.prototype = Object.assign(Object.create(ge.prototype), { constructor: Ar, isLine: true, copy: function(e2) {
  return ge.prototype.copy.call(this, e2), this.material = e2.material, this.geometry = e2.geometry, this;
}, computeLineDistances: function() {
  const e2 = this.geometry;
  if (e2.isBufferGeometry) if (null === e2.index) {
    const t2 = e2.attributes.position, n2 = [0];
    for (let e3 = 1, i2 = t2.count; e3 < i2; e3++) Sr.fromBufferAttribute(t2, e3 - 1), Tr.fromBufferAttribute(t2, e3), n2[e3] = n2[e3 - 1], n2[e3] += Sr.distanceTo(Tr);
    e2.setAttribute("lineDistance", new $e(n2, 1));
  } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
  else e2.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  return this;
}, raycast: function(e2, t2) {
  const n2 = this.geometry, i2 = this.matrixWorld, r2 = e2.params.Line.threshold, a2 = n2.drawRange;
  if (null === n2.boundingSphere && n2.computeBoundingSphere(), Rr.copy(n2.boundingSphere), Rr.applyMatrix4(i2), Rr.radius += r2, false === e2.ray.intersectsSphere(Rr)) return;
  Er.copy(i2).invert(), Lr.copy(e2.ray).applyMatrix4(Er);
  const o2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), s2 = o2 * o2, l2 = new f(), c2 = new f(), h2 = new f(), u2 = new f(), d2 = this.isLineSegments ? 2 : 1;
  if (n2.isBufferGeometry) {
    const i3 = n2.index, r3 = n2.attributes.position;
    if (null !== i3) {
      for (let n3 = Math.max(0, a2.start), o3 = Math.min(i3.count, a2.start + a2.count) - 1; n3 < o3; n3 += d2) {
        const a3 = i3.getX(n3), o4 = i3.getX(n3 + 1);
        l2.fromBufferAttribute(r3, a3), c2.fromBufferAttribute(r3, o4);
        if (Lr.distanceSqToSegment(l2, c2, u2, h2) > s2) continue;
        u2.applyMatrix4(this.matrixWorld);
        const d3 = e2.ray.origin.distanceTo(u2);
        d3 < e2.near || d3 > e2.far || t2.push({ distance: d3, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
      }
    } else {
      for (let n3 = Math.max(0, a2.start), i4 = Math.min(r3.count, a2.start + a2.count) - 1; n3 < i4; n3 += d2) {
        l2.fromBufferAttribute(r3, n3), c2.fromBufferAttribute(r3, n3 + 1);
        if (Lr.distanceSqToSegment(l2, c2, u2, h2) > s2) continue;
        u2.applyMatrix4(this.matrixWorld);
        const i5 = e2.ray.origin.distanceTo(u2);
        i5 < e2.near || i5 > e2.far || t2.push({ distance: i5, point: h2.clone().applyMatrix4(this.matrixWorld), index: n3, face: null, faceIndex: null, object: this });
      }
    }
  } else n2.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
}, updateMorphTargets: function() {
  const e2 = this.geometry;
  if (e2.isBufferGeometry) {
    const t2 = e2.morphAttributes, n2 = Object.keys(t2);
    if (n2.length > 0) {
      const e3 = t2[n2[0]];
      if (void 0 !== e3) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let t3 = 0, n3 = e3.length; t3 < n3; t3++) {
          const n4 = e3[t3].name || String(t3);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = t3;
        }
      }
    }
  } else {
    const t2 = e2.morphTargets;
    void 0 !== t2 && t2.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
} });
var Pr = new f();
var Cr = new f();
function Dr(e2, t2) {
  Ar.call(this, e2, t2), this.type = "LineSegments";
}
Dr.prototype = Object.assign(Object.create(Ar.prototype), { constructor: Dr, isLineSegments: true, computeLineDistances: function() {
  const e2 = this.geometry;
  if (e2.isBufferGeometry) if (null === e2.index) {
    const t2 = e2.attributes.position, n2 = [];
    for (let e3 = 0, i2 = t2.count; e3 < i2; e3 += 2) Pr.fromBufferAttribute(t2, e3), Cr.fromBufferAttribute(t2, e3 + 1), n2[e3] = 0 === e3 ? 0 : n2[e3 - 1], n2[e3 + 1] = n2[e3] + Pr.distanceTo(Cr);
    e2.setAttribute("lineDistance", new $e(n2, 1));
  } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
  else e2.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
  return this;
} });
var Ir = class extends Ar {
  constructor(e2, t2) {
    super(e2, t2), this.type = "LineLoop";
  }
};
Ir.prototype.isLineLoop = true;
var Nr = class extends Ie {
  constructor(e2) {
    super(), this.type = "PointsMaterial", this.color = new Be(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.morphTargets = false, this.setValues(e2);
  }
  copy(e2) {
    return super.copy(e2), this.color.copy(e2.color), this.map = e2.map, this.alphaMap = e2.alphaMap, this.size = e2.size, this.sizeAttenuation = e2.sizeAttenuation, this.morphTargets = e2.morphTargets, this;
  }
};
Nr.prototype.isPointsMaterial = true;
var Or = new j();
var Ur = new W();
var Fr = new U();
var Hr = new f();
function zr(e2 = new ct(), t2 = new Nr()) {
  ge.call(this), this.type = "Points", this.geometry = e2, this.material = t2, this.updateMorphTargets();
}
function Br(e2, t2, n2, i2, r2, a2, o2) {
  const s2 = Ur.distanceSqToPoint(e2);
  if (s2 < n2) {
    const n3 = new f();
    Ur.closestPointToPoint(e2, n3), n3.applyMatrix4(i2);
    const l2 = r2.ray.origin.distanceTo(n3);
    if (l2 < r2.near || l2 > r2.far) return;
    a2.push({ distance: l2, distanceToRay: Math.sqrt(s2), point: n3, index: t2, face: null, object: o2 });
  }
}
zr.prototype = Object.assign(Object.create(ge.prototype), { constructor: zr, isPoints: true, copy: function(e2) {
  return ge.prototype.copy.call(this, e2), this.material = e2.material, this.geometry = e2.geometry, this;
}, raycast: function(e2, t2) {
  const n2 = this.geometry, i2 = this.matrixWorld, r2 = e2.params.Points.threshold, a2 = n2.drawRange;
  if (null === n2.boundingSphere && n2.computeBoundingSphere(), Fr.copy(n2.boundingSphere), Fr.applyMatrix4(i2), Fr.radius += r2, false === e2.ray.intersectsSphere(Fr)) return;
  Or.copy(i2).invert(), Ur.copy(e2.ray).applyMatrix4(Or);
  const o2 = r2 / ((this.scale.x + this.scale.y + this.scale.z) / 3), s2 = o2 * o2;
  if (n2.isBufferGeometry) {
    const r3 = n2.index, o3 = n2.attributes.position;
    if (null !== r3) {
      for (let n3 = Math.max(0, a2.start), l2 = Math.min(r3.count, a2.start + a2.count); n3 < l2; n3++) {
        const a3 = r3.getX(n3);
        Hr.fromBufferAttribute(o3, a3), Br(Hr, a3, s2, i2, e2, t2, this);
      }
    } else {
      for (let n3 = Math.max(0, a2.start), r4 = Math.min(o3.count, a2.start + a2.count); n3 < r4; n3++) Hr.fromBufferAttribute(o3, n3), Br(Hr, n3, s2, i2, e2, t2, this);
    }
  } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
}, updateMorphTargets: function() {
  const e2 = this.geometry;
  if (e2.isBufferGeometry) {
    const t2 = e2.morphAttributes, n2 = Object.keys(t2);
    if (n2.length > 0) {
      const e3 = t2[n2[0]];
      if (void 0 !== e3) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let t3 = 0, n3 = e3.length; t3 < n3; t3++) {
          const n4 = e3[t3].name || String(t3);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[n4] = t3;
        }
      }
    }
  } else {
    const t2 = e2.morphTargets;
    void 0 !== t2 && t2.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
  }
} });
var Gr = class extends c {
  constructor(e2, t2, n2, i2, r2, a2, o2, s2, l2, c2, h2, u2) {
    super(null, a2, o2, s2, l2, c2, i2, r2, h2, u2), this.image = { width: t2, height: n2 }, this.mipmaps = e2, this.flipY = false, this.generateMipmaps = false;
  }
};
Gr.prototype.isCompressedTexture = true;
var kr = class extends c {
  constructor(e2, t2, n2, i2, r2, a2, o2, s2, l2) {
    super(e2, t2, n2, i2, r2, a2, o2, s2, l2), this.needsUpdate = true;
  }
};
function Vr(e2, t2, n2) {
  ct.call(this), this.type = "ParametricGeometry", this.parameters = { func: e2, slices: t2, stacks: n2 };
  const i2 = [], r2 = [], a2 = [], o2 = [], s2 = 1e-5, l2 = new f(), c2 = new f(), h2 = new f(), u2 = new f(), d2 = new f();
  e2.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
  const p2 = t2 + 1;
  for (let f2 = 0; f2 <= n2; f2++) {
    const i3 = f2 / n2;
    for (let n3 = 0; n3 <= t2; n3++) {
      const p3 = n3 / t2;
      e2(p3, i3, c2), r2.push(c2.x, c2.y, c2.z), p3 - s2 >= 0 ? (e2(p3 - s2, i3, h2), u2.subVectors(c2, h2)) : (e2(p3 + s2, i3, h2), u2.subVectors(h2, c2)), i3 - s2 >= 0 ? (e2(p3, i3 - s2, h2), d2.subVectors(c2, h2)) : (e2(p3, i3 + s2, h2), d2.subVectors(h2, c2)), l2.crossVectors(u2, d2).normalize(), a2.push(l2.x, l2.y, l2.z), o2.push(p3, i3);
    }
  }
  for (let f2 = 0; f2 < n2; f2++) for (let e3 = 0; e3 < t2; e3++) {
    const t3 = f2 * p2 + e3, n3 = f2 * p2 + e3 + 1, r3 = (f2 + 1) * p2 + e3 + 1, a3 = (f2 + 1) * p2 + e3;
    i2.push(t3, n3, a3), i2.push(n3, r3, a3);
  }
  this.setIndex(i2), this.setAttribute("position", new $e(r2, 3)), this.setAttribute("normal", new $e(a2, 3)), this.setAttribute("uv", new $e(o2, 2));
}
function Wr(e2) {
  Ie.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Be(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Be(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new r(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = false, this.morphTargets = false, this.morphNormals = false, this.flatShading = false, this.vertexTangents = false, this.setValues(e2);
}
function jr(e2) {
  Wr.call(this), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new r(1, 1), this.clearcoatNormalMap = null, this.reflectivity = 0.5, Object.defineProperty(this, "ior", { get: function() {
    return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
  }, set: function(e3) {
    this.reflectivity = i.clamp(2.5 * (e3 - 1) / (e3 + 1), 0, 1);
  } }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(e2);
}
kr.prototype.isCanvasTexture = true, Vr.prototype = Object.create(ct.prototype), Vr.prototype.constructor = Vr, Wr.prototype = Object.create(Ie.prototype), Wr.prototype.constructor = Wr, Wr.prototype.isMeshStandardMaterial = true, Wr.prototype.copy = function(e2) {
  return Ie.prototype.copy.call(this, e2), this.defines = { STANDARD: "" }, this.color.copy(e2.color), this.roughness = e2.roughness, this.metalness = e2.metalness, this.map = e2.map, this.lightMap = e2.lightMap, this.lightMapIntensity = e2.lightMapIntensity, this.aoMap = e2.aoMap, this.aoMapIntensity = e2.aoMapIntensity, this.emissive.copy(e2.emissive), this.emissiveMap = e2.emissiveMap, this.emissiveIntensity = e2.emissiveIntensity, this.bumpMap = e2.bumpMap, this.bumpScale = e2.bumpScale, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(e2.normalScale), this.displacementMap = e2.displacementMap, this.displacementScale = e2.displacementScale, this.displacementBias = e2.displacementBias, this.roughnessMap = e2.roughnessMap, this.metalnessMap = e2.metalnessMap, this.alphaMap = e2.alphaMap, this.envMap = e2.envMap, this.envMapIntensity = e2.envMapIntensity, this.refractionRatio = e2.refractionRatio, this.wireframe = e2.wireframe, this.wireframeLinewidth = e2.wireframeLinewidth, this.wireframeLinecap = e2.wireframeLinecap, this.wireframeLinejoin = e2.wireframeLinejoin, this.skinning = e2.skinning, this.morphTargets = e2.morphTargets, this.morphNormals = e2.morphNormals, this.flatShading = e2.flatShading, this.vertexTangents = e2.vertexTangents, this;
}, jr.prototype = Object.create(Wr.prototype), jr.prototype.constructor = jr, jr.prototype.isMeshPhysicalMaterial = true, jr.prototype.copy = function(e2) {
  return Wr.prototype.copy.call(this, e2), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = e2.clearcoat, this.clearcoatMap = e2.clearcoatMap, this.clearcoatRoughness = e2.clearcoatRoughness, this.clearcoatRoughnessMap = e2.clearcoatRoughnessMap, this.clearcoatNormalMap = e2.clearcoatNormalMap, this.clearcoatNormalScale.copy(e2.clearcoatNormalScale), this.reflectivity = e2.reflectivity, e2.sheen ? this.sheen = (this.sheen || new Be()).copy(e2.sheen) : this.sheen = null, this.transmission = e2.transmission, this.transmissionMap = e2.transmissionMap, this;
};
var qr = { arraySlice: function(e2, t2, n2) {
  return qr.isTypedArray(e2) ? new e2.constructor(e2.subarray(t2, void 0 !== n2 ? n2 : e2.length)) : e2.slice(t2, n2);
}, convertArray: function(e2, t2, n2) {
  return !e2 || !n2 && e2.constructor === t2 ? e2 : "number" == typeof t2.BYTES_PER_ELEMENT ? new t2(e2) : Array.prototype.slice.call(e2);
}, isTypedArray: function(e2) {
  return ArrayBuffer.isView(e2) && !(e2 instanceof DataView);
}, getKeyframeOrder: function(e2) {
  const t2 = e2.length, n2 = new Array(t2);
  for (let i2 = 0; i2 !== t2; ++i2) n2[i2] = i2;
  return n2.sort(function(t3, n3) {
    return e2[t3] - e2[n3];
  }), n2;
}, sortedArray: function(e2, t2, n2) {
  const i2 = e2.length, r2 = new e2.constructor(i2);
  for (let a2 = 0, o2 = 0; o2 !== i2; ++a2) {
    const i3 = n2[a2] * t2;
    for (let n3 = 0; n3 !== t2; ++n3) r2[o2++] = e2[i3 + n3];
  }
  return r2;
}, flattenJSON: function(e2, t2, n2, i2) {
  let r2 = 1, a2 = e2[0];
  for (; void 0 !== a2 && void 0 === a2[i2]; ) a2 = e2[r2++];
  if (void 0 === a2) return;
  let o2 = a2[i2];
  if (void 0 !== o2) if (Array.isArray(o2)) do {
    o2 = a2[i2], void 0 !== o2 && (t2.push(a2.time), n2.push.apply(n2, o2)), a2 = e2[r2++];
  } while (void 0 !== a2);
  else if (void 0 !== o2.toArray) do {
    o2 = a2[i2], void 0 !== o2 && (t2.push(a2.time), o2.toArray(n2, n2.length)), a2 = e2[r2++];
  } while (void 0 !== a2);
  else do {
    o2 = a2[i2], void 0 !== o2 && (t2.push(a2.time), n2.push(o2)), a2 = e2[r2++];
  } while (void 0 !== a2);
}, subclip: function(e2, t2, n2, i2, r2 = 30) {
  const a2 = e2.clone();
  a2.name = t2;
  const o2 = [];
  for (let l2 = 0; l2 < a2.tracks.length; ++l2) {
    const e3 = a2.tracks[l2], t3 = e3.getValueSize(), s3 = [], c2 = [];
    for (let a3 = 0; a3 < e3.times.length; ++a3) {
      const o3 = e3.times[a3] * r2;
      if (!(o3 < n2 || o3 >= i2)) {
        s3.push(e3.times[a3]);
        for (let n3 = 0; n3 < t3; ++n3) c2.push(e3.values[a3 * t3 + n3]);
      }
    }
    0 !== s3.length && (e3.times = qr.convertArray(s3, e3.times.constructor), e3.values = qr.convertArray(c2, e3.values.constructor), o2.push(e3));
  }
  a2.tracks = o2;
  let s2 = 1 / 0;
  for (let l2 = 0; l2 < a2.tracks.length; ++l2) s2 > a2.tracks[l2].times[0] && (s2 = a2.tracks[l2].times[0]);
  for (let l2 = 0; l2 < a2.tracks.length; ++l2) a2.tracks[l2].shift(-1 * s2);
  return a2.resetDuration(), a2;
}, makeClipAdditive: function(e2, t2 = 0, n2 = e2, i2 = 30) {
  i2 <= 0 && (i2 = 30);
  const r2 = n2.tracks.length, a2 = t2 / i2;
  for (let o2 = 0; o2 < r2; ++o2) {
    const t3 = n2.tracks[o2], i3 = t3.ValueTypeName;
    if ("bool" === i3 || "string" === i3) continue;
    const r3 = e2.tracks.find(function(e3) {
      return e3.name === t3.name && e3.ValueTypeName === i3;
    });
    if (void 0 === r3) continue;
    let s2 = 0;
    const l2 = t3.getValueSize();
    t3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (s2 = l2 / 3);
    let c2 = 0;
    const h2 = r3.getValueSize();
    r3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c2 = h2 / 3);
    const u2 = t3.times.length - 1;
    let d2;
    if (a2 <= t3.times[0]) {
      const e3 = s2, n3 = l2 - s2;
      d2 = qr.arraySlice(t3.values, e3, n3);
    } else if (a2 >= t3.times[u2]) {
      const e3 = u2 * l2 + s2, n3 = e3 + l2 - s2;
      d2 = qr.arraySlice(t3.values, e3, n3);
    } else {
      const e3 = t3.createInterpolant(), n3 = s2, i4 = l2 - s2;
      e3.evaluate(a2), d2 = qr.arraySlice(e3.resultBuffer, n3, i4);
    }
    if ("quaternion" === i3) {
      new p().fromArray(d2).normalize().conjugate().toArray(d2);
    }
    const f2 = r3.times.length;
    for (let e3 = 0; e3 < f2; ++e3) {
      const t4 = e3 * h2 + c2;
      if ("quaternion" === i3) p.multiplyQuaternionsFlat(r3.values, t4, d2, 0, r3.values, t4);
      else {
        const e4 = h2 - 2 * c2;
        for (let n3 = 0; n3 < e4; ++n3) r3.values[t4 + n3] -= d2[n3];
      }
    }
  }
  return e2.blendMode = 2501, e2;
} };
function Xr(e2, t2, n2, i2) {
  this.parameterPositions = e2, this._cachedIndex = 0, this.resultBuffer = void 0 !== i2 ? i2 : new t2.constructor(n2), this.sampleValues = t2, this.valueSize = n2;
}
function Yr(e2, t2, n2, i2) {
  Xr.call(this, e2, t2, n2, i2), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0;
}
function Zr(e2, t2, n2, i2) {
  Xr.call(this, e2, t2, n2, i2);
}
function Jr(e2, t2, n2, i2) {
  Xr.call(this, e2, t2, n2, i2);
}
Object.assign(Xr.prototype, { evaluate: function(e2) {
  const t2 = this.parameterPositions;
  let n2 = this._cachedIndex, i2 = t2[n2], r2 = t2[n2 - 1];
  e: {
    t: {
      let a2;
      n: {
        i: if (!(e2 < i2)) {
          for (let a3 = n2 + 2; ; ) {
            if (void 0 === i2) {
              if (e2 < r2) break i;
              return n2 = t2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, e2, r2);
            }
            if (n2 === a3) break;
            if (r2 = i2, i2 = t2[++n2], e2 < i2) break t;
          }
          a2 = t2.length;
          break n;
        }
        if (e2 >= r2) break e;
        {
          const o2 = t2[1];
          e2 < o2 && (n2 = 2, r2 = o2);
          for (let a3 = n2 - 2; ; ) {
            if (void 0 === r2) return this._cachedIndex = 0, this.beforeStart_(0, e2, i2);
            if (n2 === a3) break;
            if (i2 = r2, r2 = t2[--n2 - 1], e2 >= r2) break t;
          }
          a2 = n2, n2 = 0;
        }
      }
      for (; n2 < a2; ) {
        const i3 = n2 + a2 >>> 1;
        e2 < t2[i3] ? a2 = i3 : n2 = i3 + 1;
      }
      if (i2 = t2[n2], r2 = t2[n2 - 1], void 0 === r2) return this._cachedIndex = 0, this.beforeStart_(0, e2, i2);
      if (void 0 === i2) return n2 = t2.length, this._cachedIndex = n2, this.afterEnd_(n2 - 1, r2, e2);
    }
    this._cachedIndex = n2, this.intervalChanged_(n2, r2, i2);
  }
  return this.interpolate_(n2, r2, e2, i2);
}, settings: null, DefaultSettings_: {}, getSettings_: function() {
  return this.settings || this.DefaultSettings_;
}, copySampleValue_: function(e2) {
  const t2 = this.resultBuffer, n2 = this.sampleValues, i2 = this.valueSize, r2 = e2 * i2;
  for (let a2 = 0; a2 !== i2; ++a2) t2[a2] = n2[r2 + a2];
  return t2;
}, interpolate_: function() {
  throw new Error("call to abstract method");
}, intervalChanged_: function() {
} }), Object.assign(Xr.prototype, { beforeStart_: Xr.prototype.copySampleValue_, afterEnd_: Xr.prototype.copySampleValue_ }), Yr.prototype = Object.assign(Object.create(Xr.prototype), { constructor: Yr, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function(e2, t2, n2) {
  const i2 = this.parameterPositions;
  let r2 = e2 - 2, a2 = e2 + 1, o2 = i2[r2], s2 = i2[a2];
  if (void 0 === o2) switch (this.getSettings_().endingStart) {
    case 2401:
      r2 = e2, o2 = 2 * t2 - n2;
      break;
    case 2402:
      r2 = i2.length - 2, o2 = t2 + i2[r2] - i2[r2 + 1];
      break;
    default:
      r2 = e2, o2 = n2;
  }
  if (void 0 === s2) switch (this.getSettings_().endingEnd) {
    case 2401:
      a2 = e2, s2 = 2 * n2 - t2;
      break;
    case 2402:
      a2 = 1, s2 = n2 + i2[1] - i2[0];
      break;
    default:
      a2 = e2 - 1, s2 = t2;
  }
  const l2 = 0.5 * (n2 - t2), c2 = this.valueSize;
  this._weightPrev = l2 / (t2 - o2), this._weightNext = l2 / (s2 - n2), this._offsetPrev = r2 * c2, this._offsetNext = a2 * c2;
}, interpolate_: function(e2, t2, n2, i2) {
  const r2 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = e2 * o2, l2 = s2 - o2, c2 = this._offsetPrev, h2 = this._offsetNext, u2 = this._weightPrev, d2 = this._weightNext, p2 = (n2 - t2) / (i2 - t2), f2 = p2 * p2, m2 = f2 * p2, g2 = -u2 * m2 + 2 * u2 * f2 - u2 * p2, v2 = (1 + u2) * m2 + (-1.5 - 2 * u2) * f2 + (-0.5 + u2) * p2 + 1, x2 = (-1 - d2) * m2 + (1.5 + d2) * f2 + 0.5 * p2, y2 = d2 * m2 - d2 * f2;
  for (let _2 = 0; _2 !== o2; ++_2) r2[_2] = g2 * a2[c2 + _2] + v2 * a2[l2 + _2] + x2 * a2[s2 + _2] + y2 * a2[h2 + _2];
  return r2;
} }), Zr.prototype = Object.assign(Object.create(Xr.prototype), { constructor: Zr, interpolate_: function(e2, t2, n2, i2) {
  const r2 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = e2 * o2, l2 = s2 - o2, c2 = (n2 - t2) / (i2 - t2), h2 = 1 - c2;
  for (let u2 = 0; u2 !== o2; ++u2) r2[u2] = a2[l2 + u2] * h2 + a2[s2 + u2] * c2;
  return r2;
} }), Jr.prototype = Object.assign(Object.create(Xr.prototype), { constructor: Jr, interpolate_: function(e2) {
  return this.copySampleValue_(e2 - 1);
} });
var Kr = class {
  constructor(e2, t2, n2, i2) {
    if (void 0 === e2) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === t2 || 0 === t2.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e2);
    this.name = e2, this.times = qr.convertArray(t2, this.TimeBufferType), this.values = qr.convertArray(n2, this.ValueBufferType), this.setInterpolation(i2 || this.DefaultInterpolation);
  }
  static toJSON(e2) {
    const t2 = e2.constructor;
    let n2;
    if (t2.toJSON !== this.toJSON) n2 = t2.toJSON(e2);
    else {
      n2 = { name: e2.name, times: qr.convertArray(e2.times, Array), values: qr.convertArray(e2.values, Array) };
      const t3 = e2.getInterpolation();
      t3 !== e2.DefaultInterpolation && (n2.interpolation = t3);
    }
    return n2.type = e2.ValueTypeName, n2;
  }
  InterpolantFactoryMethodDiscrete(e2) {
    return new Jr(this.times, this.values, this.getValueSize(), e2);
  }
  InterpolantFactoryMethodLinear(e2) {
    return new Zr(this.times, this.values, this.getValueSize(), e2);
  }
  InterpolantFactoryMethodSmooth(e2) {
    return new Yr(this.times, this.values, this.getValueSize(), e2);
  }
  setInterpolation(e2) {
    let t2;
    switch (e2) {
      case 2300:
        t2 = this.InterpolantFactoryMethodDiscrete;
        break;
      case 2301:
        t2 = this.InterpolantFactoryMethodLinear;
        break;
      case 2302:
        t2 = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === t2) {
      const t3 = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (void 0 === this.createInterpolant) {
        if (e2 === this.DefaultInterpolation) throw new Error(t3);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", t3), this;
    }
    return this.createInterpolant = t2, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return 2300;
      case this.InterpolantFactoryMethodLinear:
        return 2301;
      case this.InterpolantFactoryMethodSmooth:
        return 2302;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e2) {
    if (0 !== e2) {
      const t2 = this.times;
      for (let n2 = 0, i2 = t2.length; n2 !== i2; ++n2) t2[n2] += e2;
    }
    return this;
  }
  scale(e2) {
    if (1 !== e2) {
      const t2 = this.times;
      for (let n2 = 0, i2 = t2.length; n2 !== i2; ++n2) t2[n2] *= e2;
    }
    return this;
  }
  trim(e2, t2) {
    const n2 = this.times, i2 = n2.length;
    let r2 = 0, a2 = i2 - 1;
    for (; r2 !== i2 && n2[r2] < e2; ) ++r2;
    for (; -1 !== a2 && n2[a2] > t2; ) --a2;
    if (++a2, 0 !== r2 || a2 !== i2) {
      r2 >= a2 && (a2 = Math.max(a2, 1), r2 = a2 - 1);
      const e3 = this.getValueSize();
      this.times = qr.arraySlice(n2, r2, a2), this.values = qr.arraySlice(this.values, r2 * e3, a2 * e3);
    }
    return this;
  }
  validate() {
    let e2 = true;
    const t2 = this.getValueSize();
    t2 - Math.floor(t2) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e2 = false);
    const n2 = this.times, i2 = this.values, r2 = n2.length;
    0 === r2 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e2 = false);
    let a2 = null;
    for (let o2 = 0; o2 !== r2; o2++) {
      const t3 = n2[o2];
      if ("number" == typeof t3 && isNaN(t3)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o2, t3), e2 = false;
        break;
      }
      if (null !== a2 && a2 > t3) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o2, t3, a2), e2 = false;
        break;
      }
      a2 = t3;
    }
    if (void 0 !== i2 && qr.isTypedArray(i2)) for (let o2 = 0, s2 = i2.length; o2 !== s2; ++o2) {
      const t3 = i2[o2];
      if (isNaN(t3)) {
        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o2, t3), e2 = false;
        break;
      }
    }
    return e2;
  }
  optimize() {
    const e2 = qr.arraySlice(this.times), t2 = qr.arraySlice(this.values), n2 = this.getValueSize(), i2 = 2302 === this.getInterpolation(), r2 = e2.length - 1;
    let a2 = 1;
    for (let o2 = 1; o2 < r2; ++o2) {
      let r3 = false;
      const s2 = e2[o2];
      if (s2 !== e2[o2 + 1] && (1 !== o2 || s2 !== e2[0])) if (i2) r3 = true;
      else {
        const e3 = o2 * n2, i3 = e3 - n2, a3 = e3 + n2;
        for (let o3 = 0; o3 !== n2; ++o3) {
          const n3 = t2[e3 + o3];
          if (n3 !== t2[i3 + o3] || n3 !== t2[a3 + o3]) {
            r3 = true;
            break;
          }
        }
      }
      if (r3) {
        if (o2 !== a2) {
          e2[a2] = e2[o2];
          const i3 = o2 * n2, r4 = a2 * n2;
          for (let e3 = 0; e3 !== n2; ++e3) t2[r4 + e3] = t2[i3 + e3];
        }
        ++a2;
      }
    }
    if (r2 > 0) {
      e2[a2] = e2[r2];
      for (let e3 = r2 * n2, i3 = a2 * n2, o2 = 0; o2 !== n2; ++o2) t2[i3 + o2] = t2[e3 + o2];
      ++a2;
    }
    return a2 !== e2.length ? (this.times = qr.arraySlice(e2, 0, a2), this.values = qr.arraySlice(t2, 0, a2 * n2)) : (this.times = e2, this.values = t2), this;
  }
  clone() {
    const e2 = qr.arraySlice(this.times, 0), t2 = qr.arraySlice(this.values, 0), n2 = new (0, this.constructor)(this.name, e2, t2);
    return n2.createInterpolant = this.createInterpolant, n2;
  }
};
Kr.prototype.TimeBufferType = Float32Array, Kr.prototype.ValueBufferType = Float32Array, Kr.prototype.DefaultInterpolation = 2301;
var Qr = class extends Kr {
};
Qr.prototype.ValueTypeName = "bool", Qr.prototype.ValueBufferType = Array, Qr.prototype.DefaultInterpolation = 2300, Qr.prototype.InterpolantFactoryMethodLinear = void 0, Qr.prototype.InterpolantFactoryMethodSmooth = void 0;
var $r = class extends Kr {
};
$r.prototype.ValueTypeName = "color";
var ea = class extends Kr {
};
function ta(e2, t2, n2, i2) {
  Xr.call(this, e2, t2, n2, i2);
}
ea.prototype.ValueTypeName = "number", ta.prototype = Object.assign(Object.create(Xr.prototype), { constructor: ta, interpolate_: function(e2, t2, n2, i2) {
  const r2 = this.resultBuffer, a2 = this.sampleValues, o2 = this.valueSize, s2 = (n2 - t2) / (i2 - t2);
  let l2 = e2 * o2;
  for (let c2 = l2 + o2; l2 !== c2; l2 += 4) p.slerpFlat(r2, 0, a2, l2 - o2, a2, l2, s2);
  return r2;
} });
var na = class extends Kr {
  InterpolantFactoryMethodLinear(e2) {
    return new ta(this.times, this.values, this.getValueSize(), e2);
  }
};
na.prototype.ValueTypeName = "quaternion", na.prototype.DefaultInterpolation = 2301, na.prototype.InterpolantFactoryMethodSmooth = void 0;
var ia = class extends Kr {
};
ia.prototype.ValueTypeName = "string", ia.prototype.ValueBufferType = Array, ia.prototype.DefaultInterpolation = 2300, ia.prototype.InterpolantFactoryMethodLinear = void 0, ia.prototype.InterpolantFactoryMethodSmooth = void 0;
var ra = class extends Kr {
};
ra.prototype.ValueTypeName = "vector";
var aa = class {
  constructor(e2, t2 = -1, n2, r2 = 2500) {
    this.name = e2, this.tracks = n2, this.duration = t2, this.blendMode = r2, this.uuid = i.generateUUID(), this.duration < 0 && this.resetDuration();
  }
  static parse(e2) {
    const t2 = [], n2 = e2.tracks, i2 = 1 / (e2.fps || 1);
    for (let a2 = 0, o2 = n2.length; a2 !== o2; ++a2) t2.push(oa(n2[a2]).scale(i2));
    const r2 = new this(e2.name, e2.duration, t2, e2.blendMode);
    return r2.uuid = e2.uuid, r2;
  }
  static toJSON(e2) {
    const t2 = [], n2 = e2.tracks, i2 = { name: e2.name, duration: e2.duration, tracks: t2, uuid: e2.uuid, blendMode: e2.blendMode };
    for (let r2 = 0, a2 = n2.length; r2 !== a2; ++r2) t2.push(Kr.toJSON(n2[r2]));
    return i2;
  }
  static CreateFromMorphTargetSequence(e2, t2, n2, i2) {
    const r2 = t2.length, a2 = [];
    for (let o2 = 0; o2 < r2; o2++) {
      let e3 = [], s2 = [];
      e3.push((o2 + r2 - 1) % r2, o2, (o2 + 1) % r2), s2.push(0, 1, 0);
      const l2 = qr.getKeyframeOrder(e3);
      e3 = qr.sortedArray(e3, 1, l2), s2 = qr.sortedArray(s2, 1, l2), i2 || 0 !== e3[0] || (e3.push(r2), s2.push(s2[0])), a2.push(new ea(".morphTargetInfluences[" + t2[o2].name + "]", e3, s2).scale(1 / n2));
    }
    return new this(e2, -1, a2);
  }
  static findByName(e2, t2) {
    let n2 = e2;
    if (!Array.isArray(e2)) {
      const t3 = e2;
      n2 = t3.geometry && t3.geometry.animations || t3.animations;
    }
    for (let i2 = 0; i2 < n2.length; i2++) if (n2[i2].name === t2) return n2[i2];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e2, t2, n2) {
    const i2 = {}, r2 = /^([\w-]*?)([\d]+)$/;
    for (let o2 = 0, s2 = e2.length; o2 < s2; o2++) {
      const t3 = e2[o2], n3 = t3.name.match(r2);
      if (n3 && n3.length > 1) {
        const e3 = n3[1];
        let r3 = i2[e3];
        r3 || (i2[e3] = r3 = []), r3.push(t3);
      }
    }
    const a2 = [];
    for (const o2 in i2) a2.push(this.CreateFromMorphTargetSequence(o2, i2[o2], t2, n2));
    return a2;
  }
  static parseAnimation(e2, t2) {
    if (!e2) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n2 = function(e3, t3, n3, i3, r3) {
      if (0 !== n3.length) {
        const a3 = [], o3 = [];
        qr.flattenJSON(n3, a3, o3, i3), 0 !== a3.length && r3.push(new e3(t3, a3, o3));
      }
    }, i2 = [], r2 = e2.name || "default", a2 = e2.fps || 30, o2 = e2.blendMode;
    let s2 = e2.length || -1;
    const l2 = e2.hierarchy || [];
    for (let c2 = 0; c2 < l2.length; c2++) {
      const e3 = l2[c2].keys;
      if (e3 && 0 !== e3.length) if (e3[0].morphTargets) {
        const t3 = {};
        let n3;
        for (n3 = 0; n3 < e3.length; n3++) if (e3[n3].morphTargets) for (let i3 = 0; i3 < e3[n3].morphTargets.length; i3++) t3[e3[n3].morphTargets[i3]] = -1;
        for (const r3 in t3) {
          const t4 = [], a3 = [];
          for (let i3 = 0; i3 !== e3[n3].morphTargets.length; ++i3) {
            const i4 = e3[n3];
            t4.push(i4.time), a3.push(i4.morphTarget === r3 ? 1 : 0);
          }
          i2.push(new ea(".morphTargetInfluence[" + r3 + "]", t4, a3));
        }
        s2 = t3.length * (a2 || 1);
      } else {
        const r3 = ".bones[" + t2[c2].name + "]";
        n2(ra, r3 + ".position", e3, "pos", i2), n2(na, r3 + ".quaternion", e3, "rot", i2), n2(ra, r3 + ".scale", e3, "scl", i2);
      }
    }
    if (0 === i2.length) return null;
    return new this(r2, s2, i2, o2);
  }
  resetDuration() {
    let e2 = 0;
    for (let t2 = 0, n2 = this.tracks.length; t2 !== n2; ++t2) {
      const n3 = this.tracks[t2];
      e2 = Math.max(e2, n3.times[n3.times.length - 1]);
    }
    return this.duration = e2, this;
  }
  trim() {
    for (let e2 = 0; e2 < this.tracks.length; e2++) this.tracks[e2].trim(0, this.duration);
    return this;
  }
  validate() {
    let e2 = true;
    for (let t2 = 0; t2 < this.tracks.length; t2++) e2 = e2 && this.tracks[t2].validate();
    return e2;
  }
  optimize() {
    for (let e2 = 0; e2 < this.tracks.length; e2++) this.tracks[e2].optimize();
    return this;
  }
  clone() {
    const e2 = [];
    for (let t2 = 0; t2 < this.tracks.length; t2++) e2.push(this.tracks[t2].clone());
    return new this.constructor(this.name, this.duration, e2, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function oa(e2) {
  if (void 0 === e2.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const t2 = function(e3) {
    switch (e3.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return ea;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ra;
      case "color":
        return $r;
      case "quaternion":
        return na;
      case "bool":
      case "boolean":
        return Qr;
      case "string":
        return ia;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e3);
  }(e2.type);
  if (void 0 === e2.times) {
    const t3 = [], n2 = [];
    qr.flattenJSON(e2.keys, t3, n2, "value"), e2.times = t3, e2.values = n2;
  }
  return void 0 !== t2.parse ? t2.parse(e2) : new t2(e2.name, e2.times, e2.values, e2.interpolation);
}
var sa = { enabled: false, files: {}, add: function(e2, t2) {
  false !== this.enabled && (this.files[e2] = t2);
}, get: function(e2) {
  if (false !== this.enabled) return this.files[e2];
}, remove: function(e2) {
  delete this.files[e2];
}, clear: function() {
  this.files = {};
} };
var la = new function(e2, t2, n2) {
  const i2 = this;
  let r2, a2 = false, o2 = 0, s2 = 0;
  const l2 = [];
  this.onStart = void 0, this.onLoad = e2, this.onProgress = t2, this.onError = n2, this.itemStart = function(e3) {
    s2++, false === a2 && void 0 !== i2.onStart && i2.onStart(e3, o2, s2), a2 = true;
  }, this.itemEnd = function(e3) {
    o2++, void 0 !== i2.onProgress && i2.onProgress(e3, o2, s2), o2 === s2 && (a2 = false, void 0 !== i2.onLoad && i2.onLoad());
  }, this.itemError = function(e3) {
    void 0 !== i2.onError && i2.onError(e3);
  }, this.resolveURL = function(e3) {
    return r2 ? r2(e3) : e3;
  }, this.setURLModifier = function(e3) {
    return r2 = e3, this;
  }, this.addHandler = function(e3, t3) {
    return l2.push(e3, t3), this;
  }, this.removeHandler = function(e3) {
    const t3 = l2.indexOf(e3);
    return -1 !== t3 && l2.splice(t3, 2), this;
  }, this.getHandler = function(e3) {
    for (let t3 = 0, n3 = l2.length; t3 < n3; t3 += 2) {
      const n4 = l2[t3], i3 = l2[t3 + 1];
      if (n4.global && (n4.lastIndex = 0), n4.test(e3)) return i3;
    }
    return null;
  };
}();
function ca(e2) {
  this.manager = void 0 !== e2 ? e2 : la, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
}
Object.assign(ca.prototype, { load: function() {
}, loadAsync: function(e2, t2) {
  const n2 = this;
  return new Promise(function(i2, r2) {
    n2.load(e2, i2, t2, r2);
  });
}, parse: function() {
}, setCrossOrigin: function(e2) {
  return this.crossOrigin = e2, this;
}, setWithCredentials: function(e2) {
  return this.withCredentials = e2, this;
}, setPath: function(e2) {
  return this.path = e2, this;
}, setResourcePath: function(e2) {
  return this.resourcePath = e2, this;
}, setRequestHeader: function(e2) {
  return this.requestHeader = e2, this;
} });
var ha = {};
function ua(e2) {
  ca.call(this, e2);
}
function da(e2) {
  ca.call(this, e2);
}
ua.prototype = Object.assign(Object.create(ca.prototype), { constructor: ua, load: function(e2, t2, n2, i2) {
  void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
  const r2 = this, a2 = sa.get(e2);
  if (void 0 !== a2) return r2.manager.itemStart(e2), setTimeout(function() {
    t2 && t2(a2), r2.manager.itemEnd(e2);
  }, 0), a2;
  if (void 0 !== ha[e2]) return void ha[e2].push({ onLoad: t2, onProgress: n2, onError: i2 });
  const o2 = e2.match(/^data:(.*?)(;base64)?,(.*)$/);
  let s2;
  if (o2) {
    const n3 = o2[1], a3 = !!o2[2];
    let s3 = o2[3];
    s3 = decodeURIComponent(s3), a3 && (s3 = atob(s3));
    try {
      let i3;
      const a4 = (this.responseType || "").toLowerCase();
      switch (a4) {
        case "arraybuffer":
        case "blob":
          const e3 = new Uint8Array(s3.length);
          for (let n4 = 0; n4 < s3.length; n4++) e3[n4] = s3.charCodeAt(n4);
          i3 = "blob" === a4 ? new Blob([e3.buffer], { type: n3 }) : e3.buffer;
          break;
        case "document":
          const t3 = new DOMParser();
          i3 = t3.parseFromString(s3, n3);
          break;
        case "json":
          i3 = JSON.parse(s3);
          break;
        default:
          i3 = s3;
      }
      setTimeout(function() {
        t2 && t2(i3), r2.manager.itemEnd(e2);
      }, 0);
    } catch (l2) {
      setTimeout(function() {
        i2 && i2(l2), r2.manager.itemError(e2), r2.manager.itemEnd(e2);
      }, 0);
    }
  } else {
    ha[e2] = [], ha[e2].push({ onLoad: t2, onProgress: n2, onError: i2 }), s2 = new XMLHttpRequest(), s2.open("GET", e2, true), s2.addEventListener("load", function(t3) {
      const n3 = this.response, i3 = ha[e2];
      if (delete ha[e2], 200 === this.status || 0 === this.status) {
        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), sa.add(e2, n3);
        for (let e3 = 0, t4 = i3.length; e3 < t4; e3++) {
          const t5 = i3[e3];
          t5.onLoad && t5.onLoad(n3);
        }
        r2.manager.itemEnd(e2);
      } else {
        for (let e3 = 0, n4 = i3.length; e3 < n4; e3++) {
          const n5 = i3[e3];
          n5.onError && n5.onError(t3);
        }
        r2.manager.itemError(e2), r2.manager.itemEnd(e2);
      }
    }, false), s2.addEventListener("progress", function(t3) {
      const n3 = ha[e2];
      for (let e3 = 0, i3 = n3.length; e3 < i3; e3++) {
        const i4 = n3[e3];
        i4.onProgress && i4.onProgress(t3);
      }
    }, false), s2.addEventListener("error", function(t3) {
      const n3 = ha[e2];
      delete ha[e2];
      for (let e3 = 0, i3 = n3.length; e3 < i3; e3++) {
        const i4 = n3[e3];
        i4.onError && i4.onError(t3);
      }
      r2.manager.itemError(e2), r2.manager.itemEnd(e2);
    }, false), s2.addEventListener("abort", function(t3) {
      const n3 = ha[e2];
      delete ha[e2];
      for (let e3 = 0, i3 = n3.length; e3 < i3; e3++) {
        const i4 = n3[e3];
        i4.onError && i4.onError(t3);
      }
      r2.manager.itemError(e2), r2.manager.itemEnd(e2);
    }, false), void 0 !== this.responseType && (s2.responseType = this.responseType), void 0 !== this.withCredentials && (s2.withCredentials = this.withCredentials), s2.overrideMimeType && s2.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
    for (const e3 in this.requestHeader) s2.setRequestHeader(e3, this.requestHeader[e3]);
    s2.send(null);
  }
  return r2.manager.itemStart(e2), s2;
}, setResponseType: function(e2) {
  return this.responseType = e2, this;
}, setMimeType: function(e2) {
  return this.mimeType = e2, this;
} }), da.prototype = Object.assign(Object.create(ca.prototype), { constructor: da, load: function(e2, t2, n2, i2) {
  const r2 = this, a2 = [], o2 = new Gr(), s2 = new ua(this.manager);
  s2.setPath(this.path), s2.setResponseType("arraybuffer"), s2.setRequestHeader(this.requestHeader), s2.setWithCredentials(r2.withCredentials);
  let l2 = 0;
  function c2(c3) {
    s2.load(e2[c3], function(e3) {
      const n3 = r2.parse(e3, true);
      a2[c3] = { width: n3.width, height: n3.height, format: n3.format, mipmaps: n3.mipmaps }, l2 += 1, 6 === l2 && (1 === n3.mipmapCount && (o2.minFilter = 1006), o2.image = a2, o2.format = n3.format, o2.needsUpdate = true, t2 && t2(o2));
    }, n2, i2);
  }
  if (Array.isArray(e2)) for (let h2 = 0, u2 = e2.length; h2 < u2; ++h2) c2(h2);
  else s2.load(e2, function(e3) {
    const n3 = r2.parse(e3, true);
    if (n3.isCubemap) {
      const e4 = n3.mipmaps.length / n3.mipmapCount;
      for (let t3 = 0; t3 < e4; t3++) {
        a2[t3] = { mipmaps: [] };
        for (let e5 = 0; e5 < n3.mipmapCount; e5++) a2[t3].mipmaps.push(n3.mipmaps[t3 * n3.mipmapCount + e5]), a2[t3].format = n3.format, a2[t3].width = n3.width, a2[t3].height = n3.height;
      }
      o2.image = a2;
    } else o2.image.width = n3.width, o2.image.height = n3.height, o2.mipmaps = n3.mipmaps;
    1 === n3.mipmapCount && (o2.minFilter = 1006), o2.format = n3.format, o2.needsUpdate = true, t2 && t2(o2);
  }, n2, i2);
  return o2;
} });
var pa = class extends ca {
  constructor(e2) {
    super(e2);
  }
  load(e2, t2, n2, i2) {
    void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
    const r2 = this, a2 = sa.get(e2);
    if (void 0 !== a2) return r2.manager.itemStart(e2), setTimeout(function() {
      t2 && t2(a2), r2.manager.itemEnd(e2);
    }, 0), a2;
    const o2 = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
    function s2() {
      o2.removeEventListener("load", s2, false), o2.removeEventListener("error", l2, false), sa.add(e2, this), t2 && t2(this), r2.manager.itemEnd(e2);
    }
    function l2(t3) {
      o2.removeEventListener("load", s2, false), o2.removeEventListener("error", l2, false), i2 && i2(t3), r2.manager.itemError(e2), r2.manager.itemEnd(e2);
    }
    return o2.addEventListener("load", s2, false), o2.addEventListener("error", l2, false), "data:" !== e2.substr(0, 5) && void 0 !== this.crossOrigin && (o2.crossOrigin = this.crossOrigin), r2.manager.itemStart(e2), o2.src = e2, o2;
  }
};
var fa = class extends ca {
  constructor(e2) {
    super(e2);
  }
  load(e2, t2, n2, i2) {
    const r2 = new Ft(), a2 = new pa(this.manager);
    a2.setCrossOrigin(this.crossOrigin), a2.setPath(this.path);
    let o2 = 0;
    function s2(n3) {
      a2.load(e2[n3], function(e3) {
        r2.images[n3] = e3, o2++, 6 === o2 && (r2.needsUpdate = true, t2 && t2(r2));
      }, void 0, i2);
    }
    for (let l2 = 0; l2 < e2.length; ++l2) s2(l2);
    return r2;
  }
};
function ma(e2) {
  ca.call(this, e2);
}
function ga(e2) {
  ca.call(this, e2);
}
function va() {
  this.type = "Curve", this.arcLengthDivisions = 200;
}
ma.prototype = Object.assign(Object.create(ca.prototype), { constructor: ma, load: function(e2, t2, n2, i2) {
  const r2 = this, a2 = new zt(), o2 = new ua(this.manager);
  return o2.setResponseType("arraybuffer"), o2.setRequestHeader(this.requestHeader), o2.setPath(this.path), o2.setWithCredentials(r2.withCredentials), o2.load(e2, function(e3) {
    const n3 = r2.parse(e3);
    n3 && (void 0 !== n3.image ? a2.image = n3.image : void 0 !== n3.data && (a2.image.width = n3.width, a2.image.height = n3.height, a2.image.data = n3.data), a2.wrapS = void 0 !== n3.wrapS ? n3.wrapS : 1001, a2.wrapT = void 0 !== n3.wrapT ? n3.wrapT : 1001, a2.magFilter = void 0 !== n3.magFilter ? n3.magFilter : 1006, a2.minFilter = void 0 !== n3.minFilter ? n3.minFilter : 1006, a2.anisotropy = void 0 !== n3.anisotropy ? n3.anisotropy : 1, void 0 !== n3.encoding && (a2.encoding = n3.encoding), void 0 !== n3.flipY && (a2.flipY = n3.flipY), void 0 !== n3.format && (a2.format = n3.format), void 0 !== n3.type && (a2.type = n3.type), void 0 !== n3.mipmaps && (a2.mipmaps = n3.mipmaps, a2.minFilter = 1008), 1 === n3.mipmapCount && (a2.minFilter = 1006), void 0 !== n3.generateMipmaps && (a2.generateMipmaps = n3.generateMipmaps), a2.needsUpdate = true, t2 && t2(a2, n3));
  }, n2, i2), a2;
} }), ga.prototype = Object.assign(Object.create(ca.prototype), { constructor: ga, load: function(e2, t2, n2, i2) {
  const r2 = new c(), a2 = new pa(this.manager);
  return a2.setCrossOrigin(this.crossOrigin), a2.setPath(this.path), a2.load(e2, function(n3) {
    r2.image = n3;
    const i3 = e2.search(/\.jpe?g($|\?)/i) > 0 || 0 === e2.search(/^data\:image\/jpeg/);
    r2.format = i3 ? 1022 : 1023, r2.needsUpdate = true, void 0 !== t2 && t2(r2);
  }, n2, i2), r2;
} }), Object.assign(va.prototype, { getPoint: function() {
  return console.warn("THREE.Curve: .getPoint() not implemented."), null;
}, getPointAt: function(e2, t2) {
  const n2 = this.getUtoTmapping(e2);
  return this.getPoint(n2, t2);
}, getPoints: function(e2 = 5) {
  const t2 = [];
  for (let n2 = 0; n2 <= e2; n2++) t2.push(this.getPoint(n2 / e2));
  return t2;
}, getSpacedPoints: function(e2 = 5) {
  const t2 = [];
  for (let n2 = 0; n2 <= e2; n2++) t2.push(this.getPointAt(n2 / e2));
  return t2;
}, getLength: function() {
  const e2 = this.getLengths();
  return e2[e2.length - 1];
}, getLengths: function(e2) {
  if (void 0 === e2 && (e2 = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e2 + 1 && !this.needsUpdate) return this.cacheArcLengths;
  this.needsUpdate = false;
  const t2 = [];
  let n2, i2 = this.getPoint(0), r2 = 0;
  t2.push(0);
  for (let a2 = 1; a2 <= e2; a2++) n2 = this.getPoint(a2 / e2), r2 += n2.distanceTo(i2), t2.push(r2), i2 = n2;
  return this.cacheArcLengths = t2, t2;
}, updateArcLengths: function() {
  this.needsUpdate = true, this.getLengths();
}, getUtoTmapping: function(e2, t2) {
  const n2 = this.getLengths();
  let i2 = 0;
  const r2 = n2.length;
  let a2;
  a2 = t2 || e2 * n2[r2 - 1];
  let o2, s2 = 0, l2 = r2 - 1;
  for (; s2 <= l2; ) if (i2 = Math.floor(s2 + (l2 - s2) / 2), o2 = n2[i2] - a2, o2 < 0) s2 = i2 + 1;
  else {
    if (!(o2 > 0)) {
      l2 = i2;
      break;
    }
    l2 = i2 - 1;
  }
  if (i2 = l2, n2[i2] === a2) return i2 / (r2 - 1);
  const c2 = n2[i2];
  return (i2 + (a2 - c2) / (n2[i2 + 1] - c2)) / (r2 - 1);
}, getTangent: function(e2, t2) {
  const n2 = 1e-4;
  let i2 = e2 - n2, a2 = e2 + n2;
  i2 < 0 && (i2 = 0), a2 > 1 && (a2 = 1);
  const o2 = this.getPoint(i2), s2 = this.getPoint(a2), l2 = t2 || (o2.isVector2 ? new r() : new f());
  return l2.copy(s2).sub(o2).normalize(), l2;
}, getTangentAt: function(e2, t2) {
  const n2 = this.getUtoTmapping(e2);
  return this.getTangent(n2, t2);
}, computeFrenetFrames: function(e2, t2) {
  const n2 = new f(), r2 = [], a2 = [], o2 = [], s2 = new f(), l2 = new j();
  for (let i2 = 0; i2 <= e2; i2++) {
    const t3 = i2 / e2;
    r2[i2] = this.getTangentAt(t3, new f()), r2[i2].normalize();
  }
  a2[0] = new f(), o2[0] = new f();
  let c2 = Number.MAX_VALUE;
  const h2 = Math.abs(r2[0].x), u2 = Math.abs(r2[0].y), d2 = Math.abs(r2[0].z);
  h2 <= c2 && (c2 = h2, n2.set(1, 0, 0)), u2 <= c2 && (c2 = u2, n2.set(0, 1, 0)), d2 <= c2 && n2.set(0, 0, 1), s2.crossVectors(r2[0], n2).normalize(), a2[0].crossVectors(r2[0], s2), o2[0].crossVectors(r2[0], a2[0]);
  for (let p2 = 1; p2 <= e2; p2++) {
    if (a2[p2] = a2[p2 - 1].clone(), o2[p2] = o2[p2 - 1].clone(), s2.crossVectors(r2[p2 - 1], r2[p2]), s2.length() > Number.EPSILON) {
      s2.normalize();
      const e3 = Math.acos(i.clamp(r2[p2 - 1].dot(r2[p2]), -1, 1));
      a2[p2].applyMatrix4(l2.makeRotationAxis(s2, e3));
    }
    o2[p2].crossVectors(r2[p2], a2[p2]);
  }
  if (true === t2) {
    let t3 = Math.acos(i.clamp(a2[0].dot(a2[e2]), -1, 1));
    t3 /= e2, r2[0].dot(s2.crossVectors(a2[0], a2[e2])) > 0 && (t3 = -t3);
    for (let n3 = 1; n3 <= e2; n3++) a2[n3].applyMatrix4(l2.makeRotationAxis(r2[n3], t3 * n3)), o2[n3].crossVectors(r2[n3], a2[n3]);
  }
  return { tangents: r2, normals: a2, binormals: o2 };
}, clone: function() {
  return new this.constructor().copy(this);
}, copy: function(e2) {
  return this.arcLengthDivisions = e2.arcLengthDivisions, this;
}, toJSON: function() {
  const e2 = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
  return e2.arcLengthDivisions = this.arcLengthDivisions, e2.type = this.type, e2;
}, fromJSON: function(e2) {
  return this.arcLengthDivisions = e2.arcLengthDivisions, this;
} });
var xa = class extends ge {
  constructor(e2, t2 = 1) {
    super(), this.type = "Light", this.color = new Be(e2), this.intensity = t2;
  }
  copy(e2) {
    return super.copy(e2), this.color.copy(e2.color), this.intensity = e2.intensity, this;
  }
  toJSON(e2) {
    const t2 = super.toJSON(e2);
    return t2.object.color = this.color.getHex(), t2.object.intensity = this.intensity, void 0 !== this.groundColor && (t2.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t2.object.distance = this.distance), void 0 !== this.angle && (t2.object.angle = this.angle), void 0 !== this.decay && (t2.object.decay = this.decay), void 0 !== this.penumbra && (t2.object.penumbra = this.penumbra), void 0 !== this.shadow && (t2.object.shadow = this.shadow.toJSON()), t2;
  }
};
xa.prototype.isLight = true;
var ya = new j();
var _a = new f();
var ba = new f();
var wa = class {
  constructor(e2) {
    this.camera = e2, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new r(512, 512), this.map = null, this.mapPass = null, this.matrix = new j(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new kt(), this._frameExtents = new r(1, 1), this._viewportCount = 1, this._viewports = [new u(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e2) {
    const t2 = this.camera, n2 = this.matrix;
    _a.setFromMatrixPosition(e2.matrixWorld), t2.position.copy(_a), ba.setFromMatrixPosition(e2.target.matrixWorld), t2.lookAt(ba), t2.updateMatrixWorld(), ya.multiplyMatrices(t2.projectionMatrix, t2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ya), n2.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n2.multiply(t2.projectionMatrix), n2.multiply(t2.matrixWorldInverse);
  }
  getViewport(e2) {
    return this._viewports[e2];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  copy(e2) {
    return this.camera = e2.camera.clone(), this.bias = e2.bias, this.radius = e2.radius, this.mapSize.copy(e2.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e2 = {};
    return 0 !== this.bias && (e2.bias = this.bias), 0 !== this.normalBias && (e2.normalBias = this.normalBias), 1 !== this.radius && (e2.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e2.mapSize = this.mapSize.toArray()), e2.camera = this.camera.toJSON(false).object, delete e2.camera.matrix, e2;
  }
};
var Ma = class extends wa {
  constructor() {
    super(new Ot(50, 1, 0.5, 500)), this.focus = 1;
  }
  updateMatrices(e2) {
    const t2 = this.camera, n2 = 2 * i.RAD2DEG * e2.angle * this.focus, r2 = this.mapSize.width / this.mapSize.height, a2 = e2.distance || t2.far;
    n2 === t2.fov && r2 === t2.aspect && a2 === t2.far || (t2.fov = n2, t2.aspect = r2, t2.far = a2, t2.updateProjectionMatrix()), super.updateMatrices(e2);
  }
  copy(e2) {
    return super.copy(e2), this.focus = e2.focus, this;
  }
};
Ma.prototype.isSpotLightShadow = true;
var Sa = class extends xa {
  constructor(e2, t2, n2 = 0, i2 = Math.PI / 3, r2 = 0, a2 = 1) {
    super(e2, t2), this.type = "SpotLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.target = new ge(), this.distance = n2, this.angle = i2, this.penumbra = r2, this.decay = a2, this.shadow = new Ma();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e2) {
    this.intensity = e2 / Math.PI;
  }
  copy(e2) {
    return super.copy(e2), this.distance = e2.distance, this.angle = e2.angle, this.penumbra = e2.penumbra, this.decay = e2.decay, this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
  }
};
Sa.prototype.isSpotLight = true;
var Ta = new j();
var Ea = new f();
var La = new f();
var Ra = class extends wa {
  constructor() {
    super(new Ot(90, 1, 0.5, 500)), this._frameExtents = new r(4, 2), this._viewportCount = 6, this._viewports = [new u(2, 1, 1, 1), new u(0, 1, 1, 1), new u(3, 1, 1, 1), new u(1, 1, 1, 1), new u(3, 0, 1, 1), new u(1, 0, 1, 1)], this._cubeDirections = [new f(1, 0, 0), new f(-1, 0, 0), new f(0, 0, 1), new f(0, 0, -1), new f(0, 1, 0), new f(0, -1, 0)], this._cubeUps = [new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 0, 1), new f(0, 0, -1)];
  }
  updateMatrices(e2, t2 = 0) {
    const n2 = this.camera, i2 = this.matrix, r2 = e2.distance || n2.far;
    r2 !== n2.far && (n2.far = r2, n2.updateProjectionMatrix()), Ea.setFromMatrixPosition(e2.matrixWorld), n2.position.copy(Ea), La.copy(n2.position), La.add(this._cubeDirections[t2]), n2.up.copy(this._cubeUps[t2]), n2.lookAt(La), n2.updateMatrixWorld(), i2.makeTranslation(-Ea.x, -Ea.y, -Ea.z), Ta.multiplyMatrices(n2.projectionMatrix, n2.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Ta);
  }
};
Ra.prototype.isPointLightShadow = true;
var Aa = class extends xa {
  constructor(e2, t2, n2 = 0, i2 = 1) {
    super(e2, t2), this.type = "PointLight", this.distance = n2, this.decay = i2, this.shadow = new Ra();
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e2) {
    this.intensity = e2 / (4 * Math.PI);
  }
  copy(e2) {
    return super.copy(e2), this.distance = e2.distance, this.decay = e2.decay, this.shadow = e2.shadow.clone(), this;
  }
};
Aa.prototype.isPointLight = true;
var Pa = class extends Nt {
  constructor(e2 = -1, t2 = 1, n2 = 1, i2 = -1, r2 = 0.1, a2 = 2e3) {
    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e2, this.right = t2, this.top = n2, this.bottom = i2, this.near = r2, this.far = a2, this.updateProjectionMatrix();
  }
  copy(e2, t2) {
    return super.copy(e2, t2), this.left = e2.left, this.right = e2.right, this.top = e2.top, this.bottom = e2.bottom, this.near = e2.near, this.far = e2.far, this.zoom = e2.zoom, this.view = null === e2.view ? null : Object.assign({}, e2.view), this;
  }
  setViewOffset(e2, t2, n2, i2, r2, a2) {
    null === this.view && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e2, this.view.fullHeight = t2, this.view.offsetX = n2, this.view.offsetY = i2, this.view.width = r2, this.view.height = a2, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e2 = (this.right - this.left) / (2 * this.zoom), t2 = (this.top - this.bottom) / (2 * this.zoom), n2 = (this.right + this.left) / 2, i2 = (this.top + this.bottom) / 2;
    let r2 = n2 - e2, a2 = n2 + e2, o2 = i2 + t2, s2 = i2 - t2;
    if (null !== this.view && this.view.enabled) {
      const e3 = (this.right - this.left) / this.view.fullWidth / this.zoom, t3 = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r2 += e3 * this.view.offsetX, a2 = r2 + e3 * this.view.width, o2 -= t3 * this.view.offsetY, s2 = o2 - t3 * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r2, a2, o2, s2, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e2) {
    const t2 = ge.prototype.toJSON.call(this, e2);
    return t2.object.zoom = this.zoom, t2.object.left = this.left, t2.object.right = this.right, t2.object.top = this.top, t2.object.bottom = this.bottom, t2.object.near = this.near, t2.object.far = this.far, null !== this.view && (t2.object.view = Object.assign({}, this.view)), t2;
  }
};
Pa.prototype.isOrthographicCamera = true;
var Ca = class extends wa {
  constructor() {
    super(new Pa(-5, 5, 5, -5, 0.5, 500));
  }
};
Ca.prototype.isDirectionalLightShadow = true;
var Da = class extends xa {
  constructor(e2, t2) {
    super(e2, t2), this.type = "DirectionalLight", this.position.copy(ge.DefaultUp), this.updateMatrix(), this.target = new ge(), this.shadow = new Ca();
  }
  copy(e2) {
    return super.copy(e2), this.target = e2.target.clone(), this.shadow = e2.shadow.clone(), this;
  }
};
Da.prototype.isDirectionalLight = true;
var Ia = function(e2) {
  if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e2);
  let t2 = "";
  for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) t2 += String.fromCharCode(e2[i2]);
  try {
    return decodeURIComponent(escape(t2));
  } catch (n2) {
    return t2;
  }
};
var Na = function(e2) {
  const t2 = e2.lastIndexOf("/");
  return -1 === t2 ? "./" : e2.substr(0, t2 + 1);
};
function Oa() {
  ct.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
}
function Ua(e2, t2, n2, i2) {
  "number" == typeof n2 && (i2 = n2, n2 = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), We.call(this, e2, t2, n2), this.meshPerAttribute = i2 || 1;
}
function Fa(e2) {
  "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), ca.call(this, e2), this.options = { premultiplyAlpha: "none" };
}
Oa.prototype = Object.assign(Object.create(ct.prototype), { constructor: Oa, isInstancedBufferGeometry: true, copy: function(e2) {
  return ct.prototype.copy.call(this, e2), this.instanceCount = e2.instanceCount, this;
}, clone: function() {
  return new this.constructor().copy(this);
}, toJSON: function() {
  const e2 = ct.prototype.toJSON.call(this);
  return e2.instanceCount = this.instanceCount, e2.isInstancedBufferGeometry = true, e2;
} }), Ua.prototype = Object.assign(Object.create(We.prototype), { constructor: Ua, isInstancedBufferAttribute: true, copy: function(e2) {
  return We.prototype.copy.call(this, e2), this.meshPerAttribute = e2.meshPerAttribute, this;
}, toJSON: function() {
  const e2 = We.prototype.toJSON.call(this);
  return e2.meshPerAttribute = this.meshPerAttribute, e2.isInstancedBufferAttribute = true, e2;
} }), Fa.prototype = Object.assign(Object.create(ca.prototype), { constructor: Fa, isImageBitmapLoader: true, setOptions: function(e2) {
  return this.options = e2, this;
}, load: function(e2, t2, n2, i2) {
  void 0 === e2 && (e2 = ""), void 0 !== this.path && (e2 = this.path + e2), e2 = this.manager.resolveURL(e2);
  const r2 = this, a2 = sa.get(e2);
  if (void 0 !== a2) return r2.manager.itemStart(e2), setTimeout(function() {
    t2 && t2(a2), r2.manager.itemEnd(e2);
  }, 0), a2;
  const o2 = {};
  o2.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o2.headers = this.requestHeader, fetch(e2, o2).then(function(e3) {
    return e3.blob();
  }).then(function(e3) {
    return createImageBitmap(e3, Object.assign(r2.options, { colorSpaceConversion: "none" }));
  }).then(function(n3) {
    sa.add(e2, n3), t2 && t2(n3), r2.manager.itemEnd(e2);
  }).catch(function(t3) {
    i2 && i2(t3), r2.manager.itemError(e2), r2.manager.itemEnd(e2);
  }), r2.manager.itemStart(e2);
} }), new j(), new j();
var Ha = class {
  constructor(e2) {
    this.autoStart = void 0 === e2 || e2, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
  }
  start() {
    this.startTime = za(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
  }
  stop() {
    this.getElapsedTime(), this.running = false, this.autoStart = false;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e2 = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t2 = za();
      e2 = (t2 - this.oldTime) / 1e3, this.oldTime = t2, this.elapsedTime += e2;
    }
    return e2;
  }
};
function za() {
  return ("undefined" == typeof performance ? Date : performance).now();
}
var Ba = new RegExp("[\\[\\]\\.:\\/]", "g");
var Ga = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]";
var ka = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
var Va = /(WCOD+)?/.source.replace("WCOD", Ga);
var Wa = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]");
var ja = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]");
var qa = new RegExp("^" + ka + Va + Wa + ja + "$");
var Xa = ["material", "materials", "bones"];
function Ya(e2, t2, n2) {
  const i2 = n2 || Za.parseTrackName(t2);
  this._targetGroup = e2, this._bindings = e2.subscribe_(t2, i2);
}
function Za(e2, t2, n2) {
  this.path = t2, this.parsedPath = n2 || Za.parseTrackName(t2), this.node = Za.findNode(e2, this.parsedPath.nodeName) || e2, this.rootNode = e2;
}
function Ja(e2, t2, n2) {
  ar.call(this, e2, t2), this.meshPerAttribute = n2 || 1;
}
function Ka(e2, t2, n2, i2, r2) {
  this.buffer = e2, this.type = t2, this.itemSize = n2, this.elementSize = i2, this.count = r2, this.version = 0;
}
function Qa(e2, t2, n2 = 0, i2 = 1 / 0) {
  this.ray = new W(e2, t2), this.near = n2, this.far = i2, this.camera = null, this.layers = new ne(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() {
    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points;
  } } });
}
function $a(e2, t2) {
  return e2.distance - t2.distance;
}
function eo(e2, t2, n2, i2) {
  if (e2.layers.test(t2.layers) && e2.raycast(t2, n2), true === i2) {
    const i3 = e2.children;
    for (let e3 = 0, r2 = i3.length; e3 < r2; e3++) eo(i3[e3], t2, n2, true);
  }
}
function to(e2) {
  ge.call(this), this.material = e2, this.render = function() {
  }, this.hasPositions = false, this.hasNormals = false, this.hasColors = false, this.hasUvs = false, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0;
}
Object.assign(Ya.prototype, { getValue: function(e2, t2) {
  this.bind();
  const n2 = this._targetGroup.nCachedObjects_, i2 = this._bindings[n2];
  void 0 !== i2 && i2.getValue(e2, t2);
}, setValue: function(e2, t2) {
  const n2 = this._bindings;
  for (let i2 = this._targetGroup.nCachedObjects_, r2 = n2.length; i2 !== r2; ++i2) n2[i2].setValue(e2, t2);
}, bind: function() {
  const e2 = this._bindings;
  for (let t2 = this._targetGroup.nCachedObjects_, n2 = e2.length; t2 !== n2; ++t2) e2[t2].bind();
}, unbind: function() {
  const e2 = this._bindings;
  for (let t2 = this._targetGroup.nCachedObjects_, n2 = e2.length; t2 !== n2; ++t2) e2[t2].unbind();
} }), Object.assign(Za, { Composite: Ya, create: function(e2, t2, n2) {
  return e2 && e2.isAnimationObjectGroup ? new Za.Composite(e2, t2, n2) : new Za(e2, t2, n2);
}, sanitizeNodeName: function(e2) {
  return e2.replace(/\s/g, "_").replace(Ba, "");
}, parseTrackName: function(e2) {
  const t2 = qa.exec(e2);
  if (!t2) throw new Error("PropertyBinding: Cannot parse trackName: " + e2);
  const n2 = { nodeName: t2[2], objectName: t2[3], objectIndex: t2[4], propertyName: t2[5], propertyIndex: t2[6] }, i2 = n2.nodeName && n2.nodeName.lastIndexOf(".");
  if (void 0 !== i2 && -1 !== i2) {
    const e3 = n2.nodeName.substring(i2 + 1);
    -1 !== Xa.indexOf(e3) && (n2.nodeName = n2.nodeName.substring(0, i2), n2.objectName = e3);
  }
  if (null === n2.propertyName || 0 === n2.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e2);
  return n2;
}, findNode: function(e2, t2) {
  if (!t2 || "" === t2 || "." === t2 || -1 === t2 || t2 === e2.name || t2 === e2.uuid) return e2;
  if (e2.skeleton) {
    const n2 = e2.skeleton.getBoneByName(t2);
    if (void 0 !== n2) return n2;
  }
  if (e2.children) {
    const n2 = function(e3) {
      for (let i3 = 0; i3 < e3.length; i3++) {
        const r2 = e3[i3];
        if (r2.name === t2 || r2.uuid === t2) return r2;
        const a2 = n2(r2.children);
        if (a2) return a2;
      }
      return null;
    }, i2 = n2(e2.children);
    if (i2) return i2;
  }
  return null;
} }), Object.assign(Za.prototype, { _getValue_unavailable: function() {
}, _setValue_unavailable: function() {
}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function(e2, t2) {
  e2[t2] = this.node[this.propertyName];
}, function(e2, t2) {
  const n2 = this.resolvedProperty;
  for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2) e2[t2++] = n2[i2];
}, function(e2, t2) {
  e2[t2] = this.resolvedProperty[this.propertyIndex];
}, function(e2, t2) {
  this.resolvedProperty.toArray(e2, t2);
}], SetterByBindingTypeAndVersioning: [[function(e2, t2) {
  this.targetObject[this.propertyName] = e2[t2];
}, function(e2, t2) {
  this.targetObject[this.propertyName] = e2[t2], this.targetObject.needsUpdate = true;
}, function(e2, t2) {
  this.targetObject[this.propertyName] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
}], [function(e2, t2) {
  const n2 = this.resolvedProperty;
  for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2) n2[i2] = e2[t2++];
}, function(e2, t2) {
  const n2 = this.resolvedProperty;
  for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2) n2[i2] = e2[t2++];
  this.targetObject.needsUpdate = true;
}, function(e2, t2) {
  const n2 = this.resolvedProperty;
  for (let i2 = 0, r2 = n2.length; i2 !== r2; ++i2) n2[i2] = e2[t2++];
  this.targetObject.matrixWorldNeedsUpdate = true;
}], [function(e2, t2) {
  this.resolvedProperty[this.propertyIndex] = e2[t2];
}, function(e2, t2) {
  this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.needsUpdate = true;
}, function(e2, t2) {
  this.resolvedProperty[this.propertyIndex] = e2[t2], this.targetObject.matrixWorldNeedsUpdate = true;
}], [function(e2, t2) {
  this.resolvedProperty.fromArray(e2, t2);
}, function(e2, t2) {
  this.resolvedProperty.fromArray(e2, t2), this.targetObject.needsUpdate = true;
}, function(e2, t2) {
  this.resolvedProperty.fromArray(e2, t2), this.targetObject.matrixWorldNeedsUpdate = true;
}]], getValue: function(e2, t2) {
  this.bind(), this.getValue(e2, t2);
}, setValue: function(e2, t2) {
  this.bind(), this.setValue(e2, t2);
}, bind: function() {
  let e2 = this.node;
  const t2 = this.parsedPath, n2 = t2.objectName, i2 = t2.propertyName;
  let r2 = t2.propertyIndex;
  if (e2 || (e2 = Za.findNode(this.rootNode, t2.nodeName) || this.rootNode, this.node = e2), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e2) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
  if (n2) {
    let i3 = t2.objectIndex;
    switch (n2) {
      case "materials":
        if (!e2.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
        if (!e2.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
        e2 = e2.material.materials;
        break;
      case "bones":
        if (!e2.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
        e2 = e2.skeleton.bones;
        for (let t3 = 0; t3 < e2.length; t3++) if (e2[t3].name === i3) {
          i3 = t3;
          break;
        }
        break;
      default:
        if (void 0 === e2[n2]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
        e2 = e2[n2];
    }
    if (void 0 !== i3) {
      if (void 0 === e2[i3]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e2);
      e2 = e2[i3];
    }
  }
  const a2 = e2[i2];
  if (void 0 === a2) {
    const n3 = t2.nodeName;
    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n3 + "." + i2 + " but it wasn't found.", e2);
  }
  let o2 = this.Versioning.None;
  this.targetObject = e2, void 0 !== e2.needsUpdate ? o2 = this.Versioning.NeedsUpdate : void 0 !== e2.matrixWorldNeedsUpdate && (o2 = this.Versioning.MatrixWorldNeedsUpdate);
  let s2 = this.BindingType.Direct;
  if (void 0 !== r2) {
    if ("morphTargetInfluences" === i2) {
      if (!e2.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
      if (!e2.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
      if (!e2.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
      void 0 !== e2.morphTargetDictionary[r2] && (r2 = e2.morphTargetDictionary[r2]);
    }
    s2 = this.BindingType.ArrayElement, this.resolvedProperty = a2, this.propertyIndex = r2;
  } else void 0 !== a2.fromArray && void 0 !== a2.toArray ? (s2 = this.BindingType.HasFromToArray, this.resolvedProperty = a2) : Array.isArray(a2) ? (s2 = this.BindingType.EntireArray, this.resolvedProperty = a2) : this.propertyName = i2;
  this.getValue = this.GetterByBindingType[s2], this.setValue = this.SetterByBindingTypeAndVersioning[s2][o2];
}, unbind: function() {
  this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
} }), Object.assign(Za.prototype, { _getValue_unbound: Za.prototype.getValue, _setValue_unbound: Za.prototype.setValue }), Ja.prototype = Object.assign(Object.create(ar.prototype), { constructor: Ja, isInstancedInterleavedBuffer: true, copy: function(e2) {
  return ar.prototype.copy.call(this, e2), this.meshPerAttribute = e2.meshPerAttribute, this;
}, clone: function(e2) {
  const t2 = ar.prototype.clone.call(this, e2);
  return t2.meshPerAttribute = this.meshPerAttribute, t2;
}, toJSON: function(e2) {
  const t2 = ar.prototype.toJSON.call(this, e2);
  return t2.isInstancedInterleavedBuffer = true, t2.meshPerAttribute = this.meshPerAttribute, t2;
} }), Object.defineProperty(Ka.prototype, "needsUpdate", { set: function(e2) {
  true === e2 && this.version++;
} }), Object.assign(Ka.prototype, { isGLBufferAttribute: true, setBuffer: function(e2) {
  return this.buffer = e2, this;
}, setType: function(e2, t2) {
  return this.type = e2, this.elementSize = t2, this;
}, setItemSize: function(e2) {
  return this.itemSize = e2, this;
}, setCount: function(e2) {
  return this.count = e2, this;
} }), Object.assign(Qa.prototype, { set: function(e2, t2) {
  this.ray.set(e2, t2);
}, setFromCamera: function(e2, t2) {
  t2 && t2.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t2.matrixWorld), this.ray.direction.set(e2.x, e2.y, 0.5).unproject(t2).sub(this.ray.origin).normalize(), this.camera = t2) : t2 && t2.isOrthographicCamera ? (this.ray.origin.set(e2.x, e2.y, (t2.near + t2.far) / (t2.near - t2.far)).unproject(t2), this.ray.direction.set(0, 0, -1).transformDirection(t2.matrixWorld), this.camera = t2) : console.error("THREE.Raycaster: Unsupported camera type: " + t2.type);
}, intersectObject: function(e2, t2 = false, n2 = []) {
  return eo(e2, this, n2, t2), n2.sort($a), n2;
}, intersectObjects: function(e2, t2 = false, n2 = []) {
  for (let i2 = 0, r2 = e2.length; i2 < r2; i2++) eo(e2[i2], this, n2, t2);
  return n2.sort($a), n2;
} }), to.prototype = Object.create(ge.prototype), to.prototype.constructor = to, to.prototype.isImmediateRenderObject = true;
var no = new Ge({ side: 1, depthWrite: false, depthTest: false });
new Lt(new At(), no), va.create = function(e2, t2) {
  return console.log("THREE.Curve.create() has been deprecated"), e2.prototype = Object.create(va.prototype), e2.prototype.constructor = e2, e2.prototype.getPoint = t2, e2;
}, ca.prototype.extractUrlBase = function(e2) {
  return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Na(e2);
}, ca.Handlers = { add: function() {
  console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
}, get: function() {
  console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
} }, v.prototype.center = function(e2) {
  return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e2);
}, v.prototype.empty = function() {
  return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, v.prototype.isIntersectionBox = function(e2) {
  return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e2);
}, v.prototype.isIntersectionSphere = function(e2) {
  return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e2);
}, v.prototype.size = function(e2) {
  return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e2);
}, U.prototype.empty = function() {
  return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
}, kt.prototype.setFromMatrix = function(e2) {
  return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(e2);
}, i.random16 = function() {
  return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random();
}, i.nearestPowerOfTwo = function(e2) {
  return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), i.floorPowerOfTwo(e2);
}, i.nextPowerOfTwo = function(e2) {
  return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), i.ceilPowerOfTwo(e2);
}, a.prototype.flattenToArrayOffset = function(e2, t2) {
  return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e2, t2);
}, a.prototype.multiplyVector3 = function(e2) {
  return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e2.applyMatrix3(this);
}, a.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
}, a.prototype.applyToBufferAttribute = function(e2) {
  return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), e2.applyMatrix3(this);
}, a.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
}, a.prototype.getInverse = function(e2) {
  return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e2).invert();
}, j.prototype.extractPosition = function(e2) {
  return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e2);
}, j.prototype.flattenToArrayOffset = function(e2, t2) {
  return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e2, t2);
}, j.prototype.getPosition = function() {
  return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new f().setFromMatrixColumn(this, 3);
}, j.prototype.setRotationFromQuaternion = function(e2) {
  return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e2);
}, j.prototype.multiplyToArray = function() {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
}, j.prototype.multiplyVector3 = function(e2) {
  return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
}, j.prototype.multiplyVector4 = function(e2) {
  return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
}, j.prototype.multiplyVector3Array = function() {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
}, j.prototype.rotateAxis = function(e2) {
  console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e2.transformDirection(this);
}, j.prototype.crossVector = function(e2) {
  return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
}, j.prototype.translate = function() {
  console.error("THREE.Matrix4: .translate() has been removed.");
}, j.prototype.rotateX = function() {
  console.error("THREE.Matrix4: .rotateX() has been removed.");
}, j.prototype.rotateY = function() {
  console.error("THREE.Matrix4: .rotateY() has been removed.");
}, j.prototype.rotateZ = function() {
  console.error("THREE.Matrix4: .rotateZ() has been removed.");
}, j.prototype.rotateByAxis = function() {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
}, j.prototype.applyToBufferAttribute = function(e2) {
  return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), e2.applyMatrix4(this);
}, j.prototype.applyToVector3Array = function() {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
}, j.prototype.makeFrustum = function(e2, t2, n2, i2, r2, a2) {
  return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e2, t2, i2, n2, r2, a2);
}, j.prototype.getInverse = function(e2) {
  return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(e2).invert();
}, _e.prototype.isIntersectionLine = function(e2) {
  return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e2);
}, p.prototype.multiplyVector3 = function(e2) {
  return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e2.applyQuaternion(this);
}, p.prototype.inverse = function() {
  return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
}, W.prototype.isIntersectionBox = function(e2) {
  return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e2);
}, W.prototype.isIntersectionPlane = function(e2) {
  return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e2);
}, W.prototype.isIntersectionSphere = function(e2) {
  return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e2);
}, Ce.prototype.area = function() {
  return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
}, Ce.prototype.barycoordFromPoint = function(e2, t2) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e2, t2);
}, Ce.prototype.midpoint = function(e2) {
  return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e2);
}, Ce.prototypenormal = function(e2) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e2);
}, Ce.prototype.plane = function(e2) {
  return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e2);
}, Ce.barycoordFromPoint = function(e2, t2, n2, i2, r2) {
  return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ce.getBarycoord(e2, t2, n2, i2, r2);
}, Ce.normal = function(e2, t2, n2, i2) {
  return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ce.getNormal(e2, t2, n2, i2);
}, r.prototype.fromAttribute = function(e2, t2, n2) {
  return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e2, t2, n2);
}, r.prototype.distanceToManhattan = function(e2) {
  return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e2);
}, r.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, f.prototype.setEulerFromRotationMatrix = function() {
  console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
}, f.prototype.setEulerFromQuaternion = function() {
  console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
}, f.prototype.getPositionFromMatrix = function(e2) {
  return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e2);
}, f.prototype.getScaleFromMatrix = function(e2) {
  return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e2);
}, f.prototype.getColumnFromMatrix = function(e2, t2) {
  return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t2, e2);
}, f.prototype.applyProjection = function(e2) {
  return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e2);
}, f.prototype.fromAttribute = function(e2, t2, n2) {
  return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e2, t2, n2);
}, f.prototype.distanceToManhattan = function(e2) {
  return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e2);
}, f.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, u.prototype.fromAttribute = function(e2, t2, n2) {
  return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e2, t2, n2);
}, u.prototype.lengthManhattan = function() {
  return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
}, ge.prototype.getChildByName = function(e2) {
  return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e2);
}, ge.prototype.renderDepth = function() {
  console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
}, ge.prototype.translate = function(e2, t2) {
  return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t2, e2);
}, ge.prototype.getWorldRotation = function() {
  console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
}, ge.prototype.applyMatrix = function(e2) {
  return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e2);
}, Object.defineProperties(ge.prototype, { eulerOrder: { get: function() {
  return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
}, set: function(e2) {
  console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e2;
} }, useQuaternion: { get: function() {
  console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
}, set: function() {
  console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
} } }), Lt.prototype.setDrawMode = function() {
  console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
}, Object.defineProperties(Lt.prototype, { drawMode: { get: function() {
  return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0;
}, set: function() {
  console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
} } }), pr.prototype.initBones = function() {
  console.error("THREE.SkinnedMesh: initBones() has been removed.");
}, Object.defineProperty(va.prototype, "__arcLengthDivisions", { get: function() {
  return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions;
}, set: function(e2) {
  console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e2;
} }), Ot.prototype.setLens = function(e2, t2) {
  console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t2 && (this.filmGauge = t2), this.setFocalLength(e2);
}, Object.defineProperties(xa.prototype, { onlyShadow: { set: function() {
  console.warn("THREE.Light: .onlyShadow has been removed.");
} }, shadowCameraFov: { set: function(e2) {
  console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e2;
} }, shadowCameraLeft: { set: function(e2) {
  console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e2;
} }, shadowCameraRight: { set: function(e2) {
  console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e2;
} }, shadowCameraTop: { set: function(e2) {
  console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e2;
} }, shadowCameraBottom: { set: function(e2) {
  console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e2;
} }, shadowCameraNear: { set: function(e2) {
  console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e2;
} }, shadowCameraFar: { set: function(e2) {
  console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e2;
} }, shadowCameraVisible: { set: function() {
  console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
} }, shadowBias: { set: function(e2) {
  console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e2;
} }, shadowDarkness: { set: function() {
  console.warn("THREE.Light: .shadowDarkness has been removed.");
} }, shadowMapWidth: { set: function(e2) {
  console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e2;
} }, shadowMapHeight: { set: function(e2) {
  console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e2;
} } }), Object.defineProperties(We.prototype, { length: { get: function() {
  return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
} }, dynamic: { get: function() {
  return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), 35048 === this.usage;
}, set: function() {
  console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(35048);
} } }), We.prototype.setDynamic = function(e2) {
  return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === e2 ? 35048 : 35044), this;
}, We.prototype.copyIndicesArray = function() {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
}, We.prototype.setArray = function() {
  console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, ct.prototype.addIndex = function(e2) {
  console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e2);
}, ct.prototype.addAttribute = function(e2, t2) {
  return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), t2 && t2.isBufferAttribute || t2 && t2.isInterleavedBufferAttribute ? "index" === e2 ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t2), this) : this.setAttribute(e2, t2) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(e2, new We(arguments[1], arguments[2])));
}, ct.prototype.addDrawCall = function(e2, t2, n2) {
  void 0 !== n2 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e2, t2);
}, ct.prototype.clearDrawCalls = function() {
  console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
}, ct.prototype.computeOffsets = function() {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
}, ct.prototype.removeAttribute = function(e2) {
  return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(e2);
}, ct.prototype.applyMatrix = function(e2) {
  return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(e2);
}, Object.defineProperties(ct.prototype, { drawcalls: { get: function() {
  return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
} }, offsets: { get: function() {
  return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
} } }), Object.defineProperties(Oa.prototype, { maxInstancedCount: { get: function() {
  return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount;
}, set: function(e2) {
  console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = e2;
} } }), Object.defineProperties(Qa.prototype, { linePrecision: { get: function() {
  return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold;
}, set: function(e2) {
  console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = e2;
} } }), Object.defineProperties(ar.prototype, { dynamic: { get: function() {
  return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), 35048 === this.usage;
}, set: function(e2) {
  console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(e2);
} } }), ar.prototype.setDynamic = function(e2) {
  return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(true === e2 ? 35048 : 35044), this;
}, ar.prototype.setArray = function() {
  console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
}, rr.prototype.dispose = function() {
  console.error("THREE.Scene: .dispose() has been removed.");
}, Object.defineProperties(Ie.prototype, { wrapAround: { get: function() {
  console.warn("THREE.Material: .wrapAround has been removed.");
}, set: function() {
  console.warn("THREE.Material: .wrapAround has been removed.");
} }, overdraw: { get: function() {
  console.warn("THREE.Material: .overdraw has been removed.");
}, set: function() {
  console.warn("THREE.Material: .overdraw has been removed.");
} }, wrapRGB: { get: function() {
  return console.warn("THREE.Material: .wrapRGB has been removed."), new Be();
} }, shading: { get: function() {
  console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
}, set: function(e2) {
  console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e2;
} }, stencilMask: { get: function() {
  return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
}, set: function(e2) {
  console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = e2;
} } }), Object.defineProperties(jr.prototype, { transparency: { get: function() {
  return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission;
}, set: function(e2) {
  console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = e2;
} } }), Object.defineProperties(It.prototype, { derivatives: { get: function() {
  return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
}, set: function(e2) {
  console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e2;
} } }), ir.prototype.clearTarget = function(e2, t2, n2, i2) {
  console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e2), this.clear(t2, n2, i2);
}, ir.prototype.animate = function(e2) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e2);
}, ir.prototype.getCurrentRenderTarget = function() {
  return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
}, ir.prototype.getMaxAnisotropy = function() {
  return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
}, ir.prototype.getPrecision = function() {
  return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
}, ir.prototype.resetGLState = function() {
  return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
}, ir.prototype.supportsFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
}, ir.prototype.supportsHalfFloatTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
}, ir.prototype.supportsStandardDerivatives = function() {
  return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
}, ir.prototype.supportsCompressedTextureS3TC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
}, ir.prototype.supportsCompressedTexturePVRTC = function() {
  return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
}, ir.prototype.supportsBlendMinMax = function() {
  return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
}, ir.prototype.supportsVertexTextures = function() {
  return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
}, ir.prototype.supportsInstancedArrays = function() {
  return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
}, ir.prototype.enableScissorTest = function(e2) {
  console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e2);
}, ir.prototype.initMaterial = function() {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
}, ir.prototype.addPrePlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
}, ir.prototype.addPostPlugin = function() {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
}, ir.prototype.updateShadowMap = function() {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
}, ir.prototype.setFaceCulling = function() {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
}, ir.prototype.allocTextureUnit = function() {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
}, ir.prototype.setTexture = function() {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
}, ir.prototype.setTexture2D = function() {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
}, ir.prototype.setTextureCube = function() {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
}, ir.prototype.getActiveMipMapLevel = function() {
  return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
}, Object.defineProperties(ir.prototype, { shadowMapEnabled: { get: function() {
  return this.shadowMap.enabled;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e2;
} }, shadowMapType: { get: function() {
  return this.shadowMap.type;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e2;
} }, shadowMapCullFace: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
} }, context: { get: function() {
  return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
} }, vr: { get: function() {
  return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
} }, gammaInput: { get: function() {
  return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
}, set: function() {
  console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
} }, gammaOutput: { get: function() {
  return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = true === e2 ? 3001 : 3e3;
} }, toneMappingWhitePoint: { get: function() {
  return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
}, set: function() {
  console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
} } }), Object.defineProperties(Yi.prototype, { cullFace: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
} }, renderReverseSided: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
} }, renderSingleSided: { get: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
}, set: function() {
  console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
} } }), Object.defineProperties(d.prototype, { wrapS: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e2;
} }, wrapT: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e2;
} }, magFilter: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e2;
} }, minFilter: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e2;
} }, anisotropy: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e2;
} }, offset: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e2;
} }, repeat: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e2;
} }, format: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e2;
} }, type: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e2;
} }, generateMipmaps: { get: function() {
  return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
}, set: function(e2) {
  console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e2;
} } }), Ut.prototype.updateCubeMap = function(e2, t2) {
  return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e2, t2);
}, Ut.prototype.clear = function(e2, t2, n2, i2) {
  return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(e2, t2, n2, i2);
}, s.crossOrigin = void 0, s.loadTexture = function(e2, t2, n2, i2) {
  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
  const r2 = new ga();
  r2.setCrossOrigin(this.crossOrigin);
  const a2 = r2.load(e2, n2, void 0, i2);
  return t2 && (a2.mapping = t2), a2;
}, s.loadTextureCube = function(e2, t2, n2, i2) {
  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
  const r2 = new fa();
  r2.setCrossOrigin(this.crossOrigin);
  const a2 = r2.load(e2, n2, void 0, i2);
  return t2 && (a2.mapping = t2), a2;
}, s.loadCompressedTexture = function() {
  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
}, s.loadCompressedTextureCube = function() {
  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: "127" } })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "127");
var io = class {
  constructor(e2) {
    this.paused = true, this.requestId = 0, this.onRender = () => {
      e2(), this.requestNextRender();
    };
  }
  start() {
    this.paused && (this.paused = false, this.requestNextRender());
  }
  pause() {
    this.paused || (this.paused = true, this.cancelNextRender());
  }
  cancelNextRender() {
    this.requestId && window.cancelAnimationFrame(this.requestId);
  }
  requestNextRender() {
    this.requestId = window.requestAnimationFrame(this.onRender);
  }
};
var ro = () => i.seededRandom();
var ao = (e2, t2, n2, r2) => {
  const a2 = i.lerp(e2, t2, n2);
  return Math.abs(t2 - a2) < r2 ? t2 : a2;
};
var oo = class {
  constructor(e2 = {}) {
    const { throttle: t2 = 0, throttleLerpFactor: n2 = 0.035, opacity: i2 = 1, opacityLerpFactor: r2 = 0.016, startOpacity: a2 = 0 } = e2;
    this.clock = new Ha(false), this.delta = 0, this.throttle = t2, this.throttleTarget = t2, this.throttleLerpFactor = n2, this.opacity = a2, this.opacityTarget = i2, this.opacityLerpFactor = r2, this.update();
  }
  get isPaused() {
    return !this.clock.running;
  }
  update() {
    this.delta = this.clock.getDelta(), this.throttle !== this.throttleTarget && (this.throttle = ao(this.throttle, this.throttleTarget, this.throttleLerpFactor, 0.01)), this.opacity !== this.opacityTarget && (this.opacity = ao(this.opacity, this.opacityTarget, this.opacityLerpFactor, 0.01));
  }
  start() {
    this.clock.start();
  }
  pause() {
    this.clock.stop();
  }
  setThrottle(e2) {
    this.throttleTarget = e2;
  }
  setOpacity(e2) {
    this.opacityTarget = e2;
  }
};
var so = class extends It {
  constructor(e2, t2 = {}) {
    const { container: { length: n2, depth: i2 } = { length: 40, depth: 40 }, colorRange: { min: a2, max: o2 } = { min: 3172607, max: 15945620 }, thicknessRange: { min: s2, max: l2 } = { min: 0.035, max: 0.06 }, rayLengthRange: { min: c2, max: h2 } = { min: 0.1, max: 2.5 }, stretchFactorRange: { min: u2, max: d2 } = { min: 0, max: 1.5 }, shakeSpeedFactor: p2 = 1e-3, shakeStrengthFactor: m2 = 35e-4, speedRange: g2 = { min: 0.5, max: 60 }, particleTextureUrl: x2 = "https://webgl-space-travel.requin.pro/particle-sprite.png", noiseTextureUrl: y2 = "https://webgl-space-travel.requin.pro/noise.jpg" } = t2, _2 = new ga(), b2 = _2.load(x2), w2 = _2.load(y2);
    w2.wrapT = 1e3, w2.wrapS = 1e3;
    const M2 = new v(new f(-n2 / 2, -n2 / 2, -i2 / 2), new f(n2 / 2, n2 / 2, i2 / 2));
    super({ vertexShader: "\nattribute float corner;\nattribute float colorMix;\n\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nuniform float globalOpacity;\nuniform sampler2D noise;\nuniform vec3 bboxMax;\nuniform vec3 bboxMin;\nuniform vec2 offset;\nuniform vec3 direction;\nuniform mat4 rotation;\nuniform vec3 color1;\nuniform vec3 color2;\nuniform float minThickness;\nuniform float maxThickness;\nuniform float minRayLength;\nuniform float maxRayLength;\nuniform float minStretchFactor;\nuniform float maxStretchFactor;\nuniform float shakeSpeedFactor;\nuniform float shakeStrengthFactor;\nuniform float throttle;\nuniform float distance;\n\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\n\nvoid main() {\n  vUv = uv;\n\n  // set particle color based on mix attribute\n  vColor = mix(color1, color2, colorMix);\n\n  float zRange = bboxMax.z - bboxMin.z;\n  float yRange = bboxMax.y - bboxMin.y;\n  float xRange = bboxMax.x - bboxMin.x;\n\n  vec3 pos = position;\n  pos += (distance * vec3(0.0, 0.0, 1.0));\n  pos.x -= offset.x;\n  pos.x = mod(pos.x, xRange) - xRange / 2.0;\n  pos.y -= offset.y;\n  pos.y = mod(pos.y, yRange) - (yRange / 2.0);\n  pos.z = mod(pos.z, zRange) - zRange / 2.0;\n\n  vec4 worldPos = modelMatrix * vec4(pos, 1.0);\n  vec4 worldOrigin = worldPos;\n  vec4 pOrigin = projectionMatrix * viewMatrix * worldOrigin;\n\n  float globalSizeFactor = clamp(remap(pOrigin.z, zRange, zRange * 0.925, 0.0, globalOpacity), 0.0, globalOpacity);\n  float rayLength = remap(throttle, 0.0, 1.0, minRayLength, maxRayLength);\n  float stretchFactor = remap(throttle, 0.0, 1.0, minStretchFactor, maxStretchFactor);\n\n  if (corner == 3.0 || corner == 1.0) {\n    worldPos.xyz -= (direction * rayLength * stretchFactor * globalSizeFactor);\n  }\n\n  if (corner == 0.0 || corner == 2.0) {\n    worldPos.xyz += (direction * rayLength * stretchFactor * globalSizeFactor);\n  }\n\n  vec4 viewPosition = viewMatrix * worldPos;\n  viewPosition = rotation * vec4(viewPosition.xyz, 1.0);\n\n  float size =  0.1 * globalSizeFactor;\n  float thickness = remap(throttle, 0.0, 1.0, minThickness, maxThickness);\n  float verticalStretch = mix(size, thickness, stretchFactor);\n  float angle = atan(-worldOrigin.y, -worldOrigin.x);\n\n  if (corner == 0.0) {\n    viewPosition.xy += rotate(vec2(-size, -verticalStretch), angle);\n  }\n\n  if (corner == 1.0) {\n    viewPosition.xy += rotate(vec2(size, -verticalStretch), angle);\n  }\n\n  if (corner == 2.0) {\n    viewPosition.xy += rotate(vec2(-size, verticalStretch), angle);\n  }\n\n  if (corner == 3.0) {\n    viewPosition.xy += rotate(vec2(size, verticalStretch), angle);\n  }\n\n  // Camera Shake\n  float shakeSpeed = shakeSpeedFactor * throttle;\n  float offsetX = remap(texture2D(noise, vec2(distance * shakeSpeed, 0)).r, 0.0, 1.0, -1.0, 1.0);\n  float offsetY = remap(texture2D(noise, vec2(distance * shakeSpeed, 0.5)).r, 0.0, 1.0, -1.0, 1.0);\n  float shakeStrength = shakeStrengthFactor * throttle;\n  vec2 shakeOffset = vec2(offsetX, offsetY) * shakeStrength;\n\n  vec4 pPosition = projectionMatrix * viewPosition;\n  pPosition.xy /= pPosition.w;\n  pPosition.xy += shakeOffset;\n  pPosition.xy *= pPosition.w;\n\n  gl_Position = pPosition;\n}\n", fragmentShader: "\nvarying vec2 vUv;\nvarying vec3 vColor;\n\nuniform sampler2D map;\n\nvoid main() {\n  vec4 texel = texture2D(map, vUv);\n  float alpha = texel.r;\n  vec3 color = mix(vColor, vec3(1.0), texel.r);\n\n  gl_FragColor = vec4(color, alpha);\n}\n", uniforms: { globalOpacity: { value: 1 }, map: { value: b2 }, noise: { value: w2 }, bboxMin: { value: M2.min }, bboxMax: { value: M2.max }, offset: { value: new r(0, 0) }, direction: { value: new f(0, 0, 1) }, rotation: { value: new j() }, color1: { value: new Be(a2) }, color2: { value: new Be(o2) }, minThickness: { value: s2 }, maxThickness: { value: l2 }, minRayLength: { value: c2 }, maxRayLength: { value: h2 }, minStretchFactor: { value: u2 }, maxStretchFactor: { value: d2 }, shakeSpeedFactor: { value: p2 }, shakeStrengthFactor: { value: m2 }, throttle: { value: 0 }, distance: { value: 0 } } }), this.context = e2, this.speedRange = g2, this.depthWrite = false, this.transparent = true, this.side = 2, this.blending = 2;
  }
  update() {
    const { delta: e2, throttle: t2, opacity: n2 } = this.context;
    this.uniforms.throttle.value = t2, this.uniforms.globalOpacity.value = n2;
    const r2 = i.mapLinear(t2, 0, 1, this.speedRange.min, this.speedRange.max);
    this.uniforms.distance.value += e2 * r2;
  }
};
var lo = class extends Lt {
  constructor(e2, t2 = {}) {
    const { count: n2 = 1500, container: { length: r2, depth: a2 } = { length: 40, depth: 40 }, container: o2, colorRange: s2, thicknessRange: l2, rayLengthRange: c2, speedRange: h2, stretchFactorRange: u2, shakeSpeedFactor: d2, shakeStrengthFactor: p2 } = t2, f2 = ((e3, t3, n3) => {
      const r3 = [], a3 = [], o3 = [], s3 = [], l3 = [], c3 = new ct();
      for (let h3 = 0; h3 < e3; h3++) {
        const e4 = i.mapLinear(ro(), 0, 1, -t3 / 2, t3 / 2), c4 = i.mapLinear(ro(), 0, 1, -t3 / 2, t3 / 2), u3 = i.mapLinear(ro(), 0, 1, -n3 / 2, n3 / 2);
        r3.push(e4, c4, u3, e4, c4, u3, e4, c4, u3, e4, c4, u3), o3.push(0, 1, 1, 1, 0, 0, 1, 0), a3.push(0, 1, 2, 3);
        const d3 = ro();
        l3.push(d3, d3, d3, d3);
        const p3 = 4 * h3;
        s3.push(p3, p3 + 1, p3 + 2, p3 + 1, p3 + 3, p3 + 2);
      }
      return c3.setAttribute("position", new We(new Float32Array(r3), 3)), c3.setAttribute("uv", new We(new Float32Array(o3), 2)), c3.setAttribute("corner", new We(new Float32Array(a3), 1)), c3.setAttribute("colorMix", new We(new Float32Array(l3), 1)), c3.setIndex(s3), c3;
    })(n2, r2, a2), m2 = new so(e2, { container: o2, colorRange: s2, thicknessRange: l2, rayLengthRange: c2, speedRange: h2, stretchFactorRange: u2, shakeSpeedFactor: d2, shakeStrengthFactor: p2 });
    super(f2, m2), this.frustumCulled = false, this.position.z -= a2 / 2, this.onBeforeRender = () => {
      m2.update();
    };
  }
};
var co = function() {
  function e2(e3) {
    ca.call(this, e3), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(e4) {
      return new s2(e4);
    }), this.register(function(e4) {
      return new c2(e4);
    }), this.register(function(e4) {
      return new h2(e4);
    }), this.register(function(e4) {
      return new l2(e4);
    }), this.register(function(e4) {
      return new a2(e4);
    }), this.register(function(e4) {
      return new u2(e4);
    });
  }
  function t2() {
    var e3 = {};
    return { get: function(t3) {
      return e3[t3];
    }, add: function(t3, n3) {
      e3[t3] = n3;
    }, remove: function(t3) {
      delete e3[t3];
    }, removeAll: function() {
      e3 = {};
    } };
  }
  e2.prototype = Object.assign(Object.create(ca.prototype), { constructor: e2, load: function(e3, t3, n3, i2) {
    var r2, a3 = this;
    r2 = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Na(e3), this.manager.itemStart(e3);
    var o3 = function(t4) {
      i2 ? i2(t4) : console.error(t4), a3.manager.itemError(e3), a3.manager.itemEnd(e3);
    }, s3 = new ua(this.manager);
    s3.setPath(this.path), s3.setResponseType("arraybuffer"), s3.setRequestHeader(this.requestHeader), s3.setWithCredentials(this.withCredentials), s3.load(e3, function(n4) {
      try {
        a3.parse(n4, r2, function(n5) {
          t3(n5), a3.manager.itemEnd(e3);
        }, o3);
      } catch (i3) {
        o3(i3);
      }
    }, n3, o3);
  }, setDRACOLoader: function(e3) {
    return this.dracoLoader = e3, this;
  }, setDDSLoader: function() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }, setKTX2Loader: function(e3) {
    return this.ktx2Loader = e3, this;
  }, setMeshoptDecoder: function(e3) {
    return this.meshoptDecoder = e3, this;
  }, register: function(e3) {
    return -1 === this.pluginCallbacks.indexOf(e3) && this.pluginCallbacks.push(e3), this;
  }, unregister: function(e3) {
    return -1 !== this.pluginCallbacks.indexOf(e3) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e3), 1), this;
  }, parse: function(e3, t3, i2, r2) {
    var a3, s3 = {}, l3 = {};
    if ("string" == typeof e3) a3 = e3;
    else if (Ia(new Uint8Array(e3, 0, 4)) === d2) {
      try {
        s3[n2.KHR_BINARY_GLTF] = new g2(e3);
      } catch (v2) {
        return void (r2 && r2(v2));
      }
      a3 = s3[n2.KHR_BINARY_GLTF].content;
    } else a3 = Ia(new Uint8Array(e3));
    var c3 = JSON.parse(a3);
    if (void 0 === c3.asset || c3.asset.version[0] < 2) r2 && r2(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
    else {
      var h3 = new Y2(c3, { path: t3 || this.resourcePath || "", crossOrigin: this.crossOrigin, requestHeader: this.requestHeader, manager: this.manager, ktx2Loader: this.ktx2Loader, meshoptDecoder: this.meshoptDecoder });
      h3.fileLoader.setRequestHeader(this.requestHeader);
      for (var u3 = 0; u3 < this.pluginCallbacks.length; u3++) {
        var p3 = this.pluginCallbacks[u3](h3);
        l3[p3.name] = p3, s3[p3.name] = true;
      }
      if (c3.extensionsUsed) for (u3 = 0; u3 < c3.extensionsUsed.length; ++u3) {
        var f2 = c3.extensionsUsed[u3], m3 = c3.extensionsRequired || [];
        switch (f2) {
          case n2.KHR_MATERIALS_UNLIT:
            s3[f2] = new o2();
            break;
          case n2.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            s3[f2] = new b2();
            break;
          case n2.KHR_DRACO_MESH_COMPRESSION:
            s3[f2] = new x2(c3, this.dracoLoader);
            break;
          case n2.KHR_TEXTURE_TRANSFORM:
            s3[f2] = new y2();
            break;
          case n2.KHR_MESH_QUANTIZATION:
            s3[f2] = new w2();
            break;
          default:
            m3.indexOf(f2) >= 0 && void 0 === l3[f2] && console.warn('THREE.GLTFLoader: Unknown extension "' + f2 + '".');
        }
      }
      h3.setExtensions(s3), h3.setPlugins(l3), h3.parse(i2, r2);
    }
  } });
  var n2 = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_BASISU: "KHR_texture_basisu", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", KHR_MESH_QUANTIZATION: "KHR_mesh_quantization", EXT_TEXTURE_WEBP: "EXT_texture_webp", EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression" };
  function a2(e3) {
    this.parser = e3, this.name = n2.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  function o2() {
    this.name = n2.KHR_MATERIALS_UNLIT;
  }
  function s2(e3) {
    this.parser = e3, this.name = n2.KHR_MATERIALS_CLEARCOAT;
  }
  function l2(e3) {
    this.parser = e3, this.name = n2.KHR_MATERIALS_TRANSMISSION;
  }
  function c2(e3) {
    this.parser = e3, this.name = n2.KHR_TEXTURE_BASISU;
  }
  function h2(e3) {
    this.parser = e3, this.name = n2.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  function u2(e3) {
    this.name = n2.EXT_MESHOPT_COMPRESSION, this.parser = e3;
  }
  a2.prototype._markDefs = function() {
    for (var e3 = this.parser, t3 = this.parser.json.nodes || [], n3 = 0, i2 = t3.length; n3 < i2; n3++) {
      var r2 = t3[n3];
      r2.extensions && r2.extensions[this.name] && void 0 !== r2.extensions[this.name].light && e3._addNodeRef(this.cache, r2.extensions[this.name].light);
    }
  }, a2.prototype._loadLight = function(e3) {
    var t3 = this.parser, n3 = "light:" + e3, i2 = t3.cache.get(n3);
    if (i2) return i2;
    var r2, a3 = t3.json, o3 = ((a3.extensions && a3.extensions[this.name] || {}).lights || [])[e3], s3 = new Be(16777215);
    void 0 !== o3.color && s3.fromArray(o3.color);
    var l3 = void 0 !== o3.range ? o3.range : 0;
    switch (o3.type) {
      case "directional":
        (r2 = new Da(s3)).target.position.set(0, 0, -1), r2.add(r2.target);
        break;
      case "point":
        (r2 = new Aa(s3)).distance = l3;
        break;
      case "spot":
        (r2 = new Sa(s3)).distance = l3, o3.spot = o3.spot || {}, o3.spot.innerConeAngle = void 0 !== o3.spot.innerConeAngle ? o3.spot.innerConeAngle : 0, o3.spot.outerConeAngle = void 0 !== o3.spot.outerConeAngle ? o3.spot.outerConeAngle : Math.PI / 4, r2.angle = o3.spot.outerConeAngle, r2.penumbra = 1 - o3.spot.innerConeAngle / o3.spot.outerConeAngle, r2.target.position.set(0, 0, -1), r2.add(r2.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + o3.type);
    }
    return r2.position.set(0, 0, 0), r2.decay = 2, void 0 !== o3.intensity && (r2.intensity = o3.intensity), r2.name = t3.createUniqueName(o3.name || "light_" + e3), i2 = Promise.resolve(r2), t3.cache.add(n3, i2), i2;
  }, a2.prototype.createNodeAttachment = function(e3) {
    var t3 = this, n3 = this.parser, i2 = n3.json.nodes[e3], r2 = (i2.extensions && i2.extensions[this.name] || {}).light;
    return void 0 === r2 ? null : this._loadLight(r2).then(function(e4) {
      return n3._getNodeRef(t3.cache, r2, e4);
    });
  }, o2.prototype.getMaterialType = function() {
    return Ge;
  }, o2.prototype.extendParams = function(e3, t3, n3) {
    var i2 = [];
    e3.color = new Be(1, 1, 1), e3.opacity = 1;
    var r2 = t3.pbrMetallicRoughness;
    if (r2) {
      if (Array.isArray(r2.baseColorFactor)) {
        var a3 = r2.baseColorFactor;
        e3.color.fromArray(a3), e3.opacity = a3[3];
      }
      void 0 !== r2.baseColorTexture && i2.push(n3.assignTexture(e3, "map", r2.baseColorTexture));
    }
    return Promise.all(i2);
  }, s2.prototype.getMaterialType = function(e3) {
    var t3 = this.parser.json.materials[e3];
    return t3.extensions && t3.extensions[this.name] ? jr : null;
  }, s2.prototype.extendMaterialParams = function(e3, t3) {
    var n3 = this.parser, i2 = n3.json.materials[e3];
    if (!i2.extensions || !i2.extensions[this.name]) return Promise.resolve();
    var a3 = [], o3 = i2.extensions[this.name];
    if (void 0 !== o3.clearcoatFactor && (t3.clearcoat = o3.clearcoatFactor), void 0 !== o3.clearcoatTexture && a3.push(n3.assignTexture(t3, "clearcoatMap", o3.clearcoatTexture)), void 0 !== o3.clearcoatRoughnessFactor && (t3.clearcoatRoughness = o3.clearcoatRoughnessFactor), void 0 !== o3.clearcoatRoughnessTexture && a3.push(n3.assignTexture(t3, "clearcoatRoughnessMap", o3.clearcoatRoughnessTexture)), void 0 !== o3.clearcoatNormalTexture && (a3.push(n3.assignTexture(t3, "clearcoatNormalMap", o3.clearcoatNormalTexture)), void 0 !== o3.clearcoatNormalTexture.scale)) {
      var s3 = o3.clearcoatNormalTexture.scale;
      t3.clearcoatNormalScale = new r(s3, -s3);
    }
    return Promise.all(a3);
  }, l2.prototype.getMaterialType = function(e3) {
    var t3 = this.parser.json.materials[e3];
    return t3.extensions && t3.extensions[this.name] ? jr : null;
  }, l2.prototype.extendMaterialParams = function(e3, t3) {
    var n3 = this.parser, i2 = n3.json.materials[e3];
    if (!i2.extensions || !i2.extensions[this.name]) return Promise.resolve();
    var r2 = [], a3 = i2.extensions[this.name];
    return void 0 !== a3.transmissionFactor && (t3.transmission = a3.transmissionFactor), void 0 !== a3.transmissionTexture && r2.push(n3.assignTexture(t3, "transmissionMap", a3.transmissionTexture)), Promise.all(r2);
  }, c2.prototype.loadTexture = function(e3) {
    var t3 = this.parser, n3 = t3.json, i2 = n3.textures[e3];
    if (!i2.extensions || !i2.extensions[this.name]) return null;
    var r2 = i2.extensions[this.name], a3 = n3.images[r2.source], o3 = t3.options.ktx2Loader;
    if (!o3) {
      if (n3.extensionsRequired && n3.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t3.loadTextureImage(e3, a3, o3);
  }, h2.prototype.loadTexture = function(e3) {
    var t3 = this.name, n3 = this.parser, i2 = n3.json, r2 = i2.textures[e3];
    if (!r2.extensions || !r2.extensions[t3]) return null;
    var a3 = r2.extensions[t3], o3 = i2.images[a3.source], s3 = n3.textureLoader;
    if (o3.uri) {
      var l3 = n3.options.manager.getHandler(o3.uri);
      null !== l3 && (s3 = l3);
    }
    return this.detectSupport().then(function(r3) {
      if (r3) return n3.loadTextureImage(e3, o3, s3);
      if (i2.extensionsRequired && i2.extensionsRequired.indexOf(t3) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n3.loadTexture(e3);
    });
  }, h2.prototype.detectSupport = function() {
    return this.isSupported || (this.isSupported = new Promise(function(e3) {
      var t3 = new Image();
      t3.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t3.onload = t3.onerror = function() {
        e3(1 === t3.height);
      };
    })), this.isSupported;
  }, u2.prototype.loadBufferView = function(e3) {
    var t3 = this.parser.json, n3 = t3.bufferViews[e3];
    if (n3.extensions && n3.extensions[this.name]) {
      var i2 = n3.extensions[this.name], r2 = this.parser.getDependency("buffer", i2.buffer), a3 = this.parser.options.meshoptDecoder;
      if (!a3 || !a3.supported) {
        if (t3.extensionsRequired && t3.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return Promise.all([r2, a3.ready]).then(function(e4) {
        var t4 = i2.byteOffset || 0, n4 = i2.byteLength || 0, r3 = i2.count, o3 = i2.byteStride, s3 = new ArrayBuffer(r3 * o3), l3 = new Uint8Array(e4[0], t4, n4);
        return a3.decodeGltfBuffer(new Uint8Array(s3), r3, o3, l3, i2.mode, i2.filter), s3;
      });
    }
    return null;
  };
  var d2 = "glTF", p2 = 1313821514, m2 = 5130562;
  function g2(e3) {
    this.name = n2.KHR_BINARY_GLTF, this.content = null, this.body = null;
    var t3 = new DataView(e3, 0, 12);
    if (this.header = { magic: Ia(new Uint8Array(e3.slice(0, 4))), version: t3.getUint32(4, true), length: t3.getUint32(8, true) }, this.header.magic !== d2) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    for (var i2 = this.header.length - 12, r2 = new DataView(e3, 12), a3 = 0; a3 < i2; ) {
      var o3 = r2.getUint32(a3, true);
      a3 += 4;
      var s3 = r2.getUint32(a3, true);
      if (a3 += 4, s3 === p2) {
        var l3 = new Uint8Array(e3, 12 + a3, o3);
        this.content = Ia(l3);
      } else if (s3 === m2) {
        var c3 = 12 + a3;
        this.body = e3.slice(c3, c3 + o3);
      }
      a3 += o3;
    }
    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
  function x2(e3, t3) {
    if (!t3) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = n2.KHR_DRACO_MESH_COMPRESSION, this.json = e3, this.dracoLoader = t3, this.dracoLoader.preload();
  }
  function y2() {
    this.name = n2.KHR_TEXTURE_TRANSFORM;
  }
  function _2(e3) {
    Wr.call(this), this.isGLTFSpecularGlossinessMaterial = true;
    var t3 = ["#ifdef USE_SPECULARMAP", "	uniform sampler2D specularMap;", "#endif"].join("\n"), n3 = ["#ifdef USE_GLOSSINESSMAP", "	uniform sampler2D glossinessMap;", "#endif"].join("\n"), i2 = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "	vec4 texelSpecular = texture2D( specularMap, vUv );", "	texelSpecular = sRGBToLinear( texelSpecular );", "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "	specularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), r2 = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );", "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "	glossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), a3 = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.specularRoughness += geometryRoughness;", "material.specularRoughness = min( material.specularRoughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"), o3 = { specular: { value: new Be().setHex(16777215) }, glossiness: { value: 1 }, specularMap: { value: null }, glossinessMap: { value: null } };
    this._extraUniforms = o3, this.onBeforeCompile = function(e4) {
      for (var s3 in o3) e4.uniforms[s3] = o3[s3];
      e4.fragmentShader = e4.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t3).replace("#include <metalnessmap_pars_fragment>", n3).replace("#include <roughnessmap_fragment>", i2).replace("#include <metalnessmap_fragment>", r2).replace("#include <lights_physical_fragment>", a3);
    }, Object.defineProperties(this, { specular: { get: function() {
      return o3.specular.value;
    }, set: function(e4) {
      o3.specular.value = e4;
    } }, specularMap: { get: function() {
      return o3.specularMap.value;
    }, set: function(e4) {
      o3.specularMap.value = e4, e4 ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP;
    } }, glossiness: { get: function() {
      return o3.glossiness.value;
    }, set: function(e4) {
      o3.glossiness.value = e4;
    } }, glossinessMap: { get: function() {
      return o3.glossinessMap.value;
    }, set: function(e4) {
      o3.glossinessMap.value = e4, e4 ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV);
    } } }), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(e3);
  }
  function b2() {
    return { name: n2.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function() {
      return _2;
    }, extendParams: function(e3, t3, n3) {
      var i2 = t3.extensions[this.name];
      e3.color = new Be(1, 1, 1), e3.opacity = 1;
      var r2 = [];
      if (Array.isArray(i2.diffuseFactor)) {
        var a3 = i2.diffuseFactor;
        e3.color.fromArray(a3), e3.opacity = a3[3];
      }
      if (void 0 !== i2.diffuseTexture && r2.push(n3.assignTexture(e3, "map", i2.diffuseTexture)), e3.emissive = new Be(0, 0, 0), e3.glossiness = void 0 !== i2.glossinessFactor ? i2.glossinessFactor : 1, e3.specular = new Be(1, 1, 1), Array.isArray(i2.specularFactor) && e3.specular.fromArray(i2.specularFactor), void 0 !== i2.specularGlossinessTexture) {
        var o3 = i2.specularGlossinessTexture;
        r2.push(n3.assignTexture(e3, "glossinessMap", o3)), r2.push(n3.assignTexture(e3, "specularMap", o3));
      }
      return Promise.all(r2);
    }, createMaterial: function(e3) {
      var t3 = new _2(e3);
      return t3.fog = true, t3.color = e3.color, t3.map = void 0 === e3.map ? null : e3.map, t3.lightMap = null, t3.lightMapIntensity = 1, t3.aoMap = void 0 === e3.aoMap ? null : e3.aoMap, t3.aoMapIntensity = 1, t3.emissive = e3.emissive, t3.emissiveIntensity = 1, t3.emissiveMap = void 0 === e3.emissiveMap ? null : e3.emissiveMap, t3.bumpMap = void 0 === e3.bumpMap ? null : e3.bumpMap, t3.bumpScale = 1, t3.normalMap = void 0 === e3.normalMap ? null : e3.normalMap, t3.normalMapType = 0, e3.normalScale && (t3.normalScale = e3.normalScale), t3.displacementMap = null, t3.displacementScale = 1, t3.displacementBias = 0, t3.specularMap = void 0 === e3.specularMap ? null : e3.specularMap, t3.specular = e3.specular, t3.glossinessMap = void 0 === e3.glossinessMap ? null : e3.glossinessMap, t3.glossiness = e3.glossiness, t3.alphaMap = null, t3.envMap = void 0 === e3.envMap ? null : e3.envMap, t3.envMapIntensity = 1, t3.refractionRatio = 0.98, t3;
    } };
  }
  function w2() {
    this.name = n2.KHR_MESH_QUANTIZATION;
  }
  function M2(e3, t3, n3, i2) {
    Xr.call(this, e3, t3, n3, i2);
  }
  x2.prototype.decodePrimitive = function(e3, t3) {
    var n3 = this.json, i2 = this.dracoLoader, r2 = e3.extensions[this.name].bufferView, a3 = e3.extensions[this.name].attributes, o3 = {}, s3 = {}, l3 = {};
    for (var c3 in a3) {
      var h3 = O2[c3] || c3.toLowerCase();
      o3[h3] = a3[c3];
    }
    for (c3 in e3.attributes) {
      h3 = O2[c3] || c3.toLowerCase();
      if (void 0 !== a3[c3]) {
        var u3 = n3.accessors[e3.attributes[c3]], d3 = C2[u3.componentType];
        l3[h3] = d3, s3[h3] = true === u3.normalized;
      }
    }
    return t3.getDependency("bufferView", r2).then(function(e4) {
      return new Promise(function(t4) {
        i2.decodeDracoFile(e4, function(e5) {
          for (var n4 in e5.attributes) {
            var i3 = e5.attributes[n4], r3 = s3[n4];
            void 0 !== r3 && (i3.normalized = r3);
          }
          t4(e5);
        }, o3, l3);
      });
    });
  }, y2.prototype.extendTexture = function(e3, t3) {
    return e3 = e3.clone(), void 0 !== t3.offset && e3.offset.fromArray(t3.offset), void 0 !== t3.rotation && (e3.rotation = t3.rotation), void 0 !== t3.scale && e3.repeat.fromArray(t3.scale), void 0 !== t3.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e3.needsUpdate = true, e3;
  }, _2.prototype = Object.create(Wr.prototype), _2.prototype.constructor = _2, _2.prototype.copy = function(e3) {
    return Wr.prototype.copy.call(this, e3), this.specularMap = e3.specularMap, this.specular.copy(e3.specular), this.glossinessMap = e3.glossinessMap, this.glossiness = e3.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this;
  }, M2.prototype = Object.create(Xr.prototype), M2.prototype.constructor = M2, M2.prototype.copySampleValue_ = function(e3) {
    for (var t3 = this.resultBuffer, n3 = this.sampleValues, i2 = this.valueSize, r2 = e3 * i2 * 3 + i2, a3 = 0; a3 !== i2; a3++) t3[a3] = n3[r2 + a3];
    return t3;
  }, M2.prototype.beforeStart_ = M2.prototype.copySampleValue_, M2.prototype.afterEnd_ = M2.prototype.copySampleValue_, M2.prototype.interpolate_ = function(e3, t3, n3, i2) {
    for (var r2 = this.resultBuffer, a3 = this.sampleValues, o3 = this.valueSize, s3 = 2 * o3, l3 = 3 * o3, c3 = i2 - t3, h3 = (n3 - t3) / c3, u3 = h3 * h3, d3 = u3 * h3, p3 = e3 * l3, f2 = p3 - l3, m3 = -2 * d3 + 3 * u3, g3 = d3 - u3, v2 = 1 - m3, x3 = g3 - u3 + h3, y3 = 0; y3 !== o3; y3++) {
      var _3 = a3[f2 + y3 + o3], b3 = a3[f2 + y3 + s3] * c3, w3 = a3[p3 + y3 + o3], M3 = a3[p3 + y3] * c3;
      r2[y3] = v2 * _3 + x3 * b3 + m3 * w3 + g3 * M3;
    }
    return r2;
  };
  var S2 = 0, T2 = 1, E2 = 2, L2 = 3, R2 = 4, A2 = 5, P2 = 6, C2 = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, D2 = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 }, I2 = { 33071: 1001, 33648: 1002, 10497: 1e3 }, N2 = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, O2 = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, F2 = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, H2 = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 }, z2 = "OPAQUE", B2 = "MASK", G2 = "BLEND";
  function k2(e3, t3) {
    return "string" != typeof e3 || "" === e3 ? "" : (/^https?:\/\//i.test(t3) && /^\//.test(e3) && (t3 = t3.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e3) || /^data:.*,.*$/i.test(e3) || /^blob:.*$/i.test(e3) ? e3 : t3 + e3);
  }
  function V2(e3, t3, n3) {
    for (var i2 in n3.extensions) void 0 === e3[i2] && (t3.userData.gltfExtensions = t3.userData.gltfExtensions || {}, t3.userData.gltfExtensions[i2] = n3.extensions[i2]);
  }
  function W2(e3, t3) {
    void 0 !== t3.extras && ("object" == typeof t3.extras ? Object.assign(e3.userData, t3.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t3.extras));
  }
  function q2(e3, t3) {
    if (e3.updateMorphTargets(), void 0 !== t3.weights) for (var n3 = 0, i2 = t3.weights.length; n3 < i2; n3++) e3.morphTargetInfluences[n3] = t3.weights[n3];
    if (t3.extras && Array.isArray(t3.extras.targetNames)) {
      var r2 = t3.extras.targetNames;
      if (e3.morphTargetInfluences.length === r2.length) {
        e3.morphTargetDictionary = {};
        for (n3 = 0, i2 = r2.length; n3 < i2; n3++) e3.morphTargetDictionary[r2[n3]] = n3;
      } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
  function X2(e3) {
    for (var t3 = "", n3 = Object.keys(e3).sort(), i2 = 0, r2 = n3.length; i2 < r2; i2++) t3 += n3[i2] + ":" + e3[n3[i2]] + ";";
    return t3;
  }
  function Y2(e3, n3) {
    this.json = e3 || {}, this.extensions = {}, this.plugins = {}, this.options = n3 || {}, this.cache = new t2(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && false === /Firefox/.test(navigator.userAgent) ? this.textureLoader = new Fa(this.options.manager) : this.textureLoader = new ga(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new ua(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(true);
  }
  function Z2(e3, t3, n3) {
    var i2 = t3.attributes, r2 = [];
    function a3(t4, i3) {
      return n3.getDependency("accessor", t4).then(function(t5) {
        e3.setAttribute(i3, t5);
      });
    }
    for (var o3 in i2) {
      var s3 = O2[o3] || o3.toLowerCase();
      s3 in e3.attributes || r2.push(a3(i2[o3], s3));
    }
    if (void 0 !== t3.indices && !e3.index) {
      var l3 = n3.getDependency("accessor", t3.indices).then(function(t4) {
        e3.setIndex(t4);
      });
      r2.push(l3);
    }
    return W2(e3, t3), function(e4, t4, n4) {
      var i3 = t4.attributes, r3 = new v();
      if (void 0 !== i3.POSITION) {
        var a4 = (d3 = n4.json.accessors[i3.POSITION]).min, o4 = d3.max;
        if (void 0 !== a4 && void 0 !== o4) {
          r3.set(new f(a4[0], a4[1], a4[2]), new f(o4[0], o4[1], o4[2]));
          var s4 = t4.targets;
          if (void 0 !== s4) {
            for (var l4 = new f(), c3 = new f(), h3 = 0, u3 = s4.length; h3 < u3; h3++) {
              var d3, p3 = s4[h3];
              if (void 0 !== p3.POSITION) a4 = (d3 = n4.json.accessors[p3.POSITION]).min, o4 = d3.max, void 0 !== a4 && void 0 !== o4 ? (c3.setX(Math.max(Math.abs(a4[0]), Math.abs(o4[0]))), c3.setY(Math.max(Math.abs(a4[1]), Math.abs(o4[1]))), c3.setZ(Math.max(Math.abs(a4[2]), Math.abs(o4[2]))), l4.max(c3)) : console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            }
            r3.expandByVector(l4);
          }
          e4.boundingBox = r3;
          var m3 = new U();
          r3.getCenter(m3.center), m3.radius = r3.min.distanceTo(r3.max) / 2, e4.boundingSphere = m3;
        } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }(e3, t3, n3), Promise.all(r2).then(function() {
      return void 0 !== t3.targets ? function(e4, t4, n4) {
        for (var i3 = false, r3 = false, a4 = 0, o4 = t4.length; a4 < o4 && (void 0 !== (c3 = t4[a4]).POSITION && (i3 = true), void 0 !== c3.NORMAL && (r3 = true), !i3 || !r3); a4++) ;
        if (!i3 && !r3) return Promise.resolve(e4);
        var s4 = [], l4 = [];
        for (a4 = 0, o4 = t4.length; a4 < o4; a4++) {
          var c3 = t4[a4];
          if (i3) {
            var h3 = void 0 !== c3.POSITION ? n4.getDependency("accessor", c3.POSITION) : e4.attributes.position;
            s4.push(h3);
          }
          r3 && (h3 = void 0 !== c3.NORMAL ? n4.getDependency("accessor", c3.NORMAL) : e4.attributes.normal, l4.push(h3));
        }
        return Promise.all([Promise.all(s4), Promise.all(l4)]).then(function(t5) {
          var n5 = t5[0], a5 = t5[1];
          return i3 && (e4.morphAttributes.position = n5), r3 && (e4.morphAttributes.normal = a5), e4.morphTargetsRelative = true, e4;
        });
      }(e3, t3.targets, n3) : e3;
    });
  }
  function J2(e3, t3) {
    var n3 = e3.getIndex();
    if (null === n3) {
      var i2 = [], r2 = e3.getAttribute("position");
      if (void 0 === r2) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e3;
      for (var a3 = 0; a3 < r2.count; a3++) i2.push(a3);
      e3.setIndex(i2), n3 = e3.getIndex();
    }
    var o3 = n3.count - 2, s3 = [];
    if (2 === t3) for (a3 = 1; a3 <= o3; a3++) s3.push(n3.getX(0)), s3.push(n3.getX(a3)), s3.push(n3.getX(a3 + 1));
    else for (a3 = 0; a3 < o3; a3++) a3 % 2 == 0 ? (s3.push(n3.getX(a3)), s3.push(n3.getX(a3 + 1)), s3.push(n3.getX(a3 + 2))) : (s3.push(n3.getX(a3 + 2)), s3.push(n3.getX(a3 + 1)), s3.push(n3.getX(a3)));
    s3.length / 3 !== o3 && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    var l3 = e3.clone();
    return l3.setIndex(s3), l3;
  }
  return Y2.prototype.setExtensions = function(e3) {
    this.extensions = e3;
  }, Y2.prototype.setPlugins = function(e3) {
    this.plugins = e3;
  }, Y2.prototype.parse = function(e3, t3) {
    var n3 = this, i2 = this.json, r2 = this.extensions;
    this.cache.removeAll(), this._invokeAll(function(e4) {
      return e4._markDefs && e4._markDefs();
    }), Promise.all(this._invokeAll(function(e4) {
      return e4.beforeRoot && e4.beforeRoot();
    })).then(function() {
      return Promise.all([n3.getDependencies("scene"), n3.getDependencies("animation"), n3.getDependencies("camera")]);
    }).then(function(t4) {
      var a3 = { scene: t4[0][i2.scene || 0], scenes: t4[0], animations: t4[1], cameras: t4[2], asset: i2.asset, parser: n3, userData: {} };
      V2(r2, a3, i2), W2(a3, i2), Promise.all(n3._invokeAll(function(e4) {
        return e4.afterRoot && e4.afterRoot(a3);
      })).then(function() {
        e3(a3);
      });
    }).catch(t3);
  }, Y2.prototype._markDefs = function() {
    for (var e3 = this.json.nodes || [], t3 = this.json.skins || [], n3 = this.json.meshes || [], i2 = 0, r2 = t3.length; i2 < r2; i2++) for (var a3 = t3[i2].joints, o3 = 0, s3 = a3.length; o3 < s3; o3++) e3[a3[o3]].isBone = true;
    for (var l3 = 0, c3 = e3.length; l3 < c3; l3++) {
      var h3 = e3[l3];
      void 0 !== h3.mesh && (this._addNodeRef(this.meshCache, h3.mesh), void 0 !== h3.skin && (n3[h3.mesh].isSkinnedMesh = true)), void 0 !== h3.camera && this._addNodeRef(this.cameraCache, h3.camera);
    }
  }, Y2.prototype._addNodeRef = function(e3, t3) {
    void 0 !== t3 && (void 0 === e3.refs[t3] && (e3.refs[t3] = e3.uses[t3] = 0), e3.refs[t3]++);
  }, Y2.prototype._getNodeRef = function(e3, t3, n3) {
    if (e3.refs[t3] <= 1) return n3;
    var i2 = n3.clone();
    return i2.name += "_instance_" + e3.uses[t3]++, i2;
  }, Y2.prototype._invokeOne = function(e3) {
    var t3 = Object.values(this.plugins);
    t3.push(this);
    for (var n3 = 0; n3 < t3.length; n3++) {
      var i2 = e3(t3[n3]);
      if (i2) return i2;
    }
  }, Y2.prototype._invokeAll = function(e3) {
    var t3 = Object.values(this.plugins);
    t3.unshift(this);
    for (var n3 = [], i2 = 0; i2 < t3.length; i2++) {
      var r2 = e3(t3[i2]);
      r2 && n3.push(r2);
    }
    return n3;
  }, Y2.prototype.getDependency = function(e3, t3) {
    var n3 = e3 + ":" + t3, i2 = this.cache.get(n3);
    if (!i2) {
      switch (e3) {
        case "scene":
          i2 = this.loadScene(t3);
          break;
        case "node":
          i2 = this.loadNode(t3);
          break;
        case "mesh":
          i2 = this._invokeOne(function(e4) {
            return e4.loadMesh && e4.loadMesh(t3);
          });
          break;
        case "accessor":
          i2 = this.loadAccessor(t3);
          break;
        case "bufferView":
          i2 = this._invokeOne(function(e4) {
            return e4.loadBufferView && e4.loadBufferView(t3);
          });
          break;
        case "buffer":
          i2 = this.loadBuffer(t3);
          break;
        case "material":
          i2 = this._invokeOne(function(e4) {
            return e4.loadMaterial && e4.loadMaterial(t3);
          });
          break;
        case "texture":
          i2 = this._invokeOne(function(e4) {
            return e4.loadTexture && e4.loadTexture(t3);
          });
          break;
        case "skin":
          i2 = this.loadSkin(t3);
          break;
        case "animation":
          i2 = this.loadAnimation(t3);
          break;
        case "camera":
          i2 = this.loadCamera(t3);
          break;
        default:
          throw new Error("Unknown type: " + e3);
      }
      this.cache.add(n3, i2);
    }
    return i2;
  }, Y2.prototype.getDependencies = function(e3) {
    var t3 = this.cache.get(e3);
    if (!t3) {
      var n3 = this, i2 = this.json[e3 + ("mesh" === e3 ? "es" : "s")] || [];
      t3 = Promise.all(i2.map(function(t4, i3) {
        return n3.getDependency(e3, i3);
      })), this.cache.add(e3, t3);
    }
    return t3;
  }, Y2.prototype.loadBuffer = function(e3) {
    var t3 = this.json.buffers[e3], i2 = this.fileLoader;
    if (t3.type && "arraybuffer" !== t3.type) throw new Error("THREE.GLTFLoader: " + t3.type + " buffer type is not supported.");
    if (void 0 === t3.uri && 0 === e3) return Promise.resolve(this.extensions[n2.KHR_BINARY_GLTF].body);
    var r2 = this.options;
    return new Promise(function(e4, n3) {
      i2.load(k2(t3.uri, r2.path), e4, void 0, function() {
        n3(new Error('THREE.GLTFLoader: Failed to load buffer "' + t3.uri + '".'));
      });
    });
  }, Y2.prototype.loadBufferView = function(e3) {
    var t3 = this.json.bufferViews[e3];
    return this.getDependency("buffer", t3.buffer).then(function(e4) {
      var n3 = t3.byteLength || 0, i2 = t3.byteOffset || 0;
      return e4.slice(i2, i2 + n3);
    });
  }, Y2.prototype.loadAccessor = function(e3) {
    var t3 = this, n3 = this.json, i2 = this.json.accessors[e3];
    if (void 0 === i2.bufferView && void 0 === i2.sparse) return Promise.resolve(null);
    var r2 = [];
    return void 0 !== i2.bufferView ? r2.push(this.getDependency("bufferView", i2.bufferView)) : r2.push(null), void 0 !== i2.sparse && (r2.push(this.getDependency("bufferView", i2.sparse.indices.bufferView)), r2.push(this.getDependency("bufferView", i2.sparse.values.bufferView))), Promise.all(r2).then(function(e4) {
      var r3, a3 = e4[0], o3 = N2[i2.type], s3 = C2[i2.componentType], l3 = s3.BYTES_PER_ELEMENT, c3 = l3 * o3, h3 = i2.byteOffset || 0, u3 = void 0 !== i2.bufferView ? n3.bufferViews[i2.bufferView].byteStride : void 0, d3 = true === i2.normalized;
      if (u3 && u3 !== c3) {
        var p3 = Math.floor(h3 / u3), f2 = "InterleavedBuffer:" + i2.bufferView + ":" + i2.componentType + ":" + p3 + ":" + i2.count, m3 = t3.cache.get(f2);
        m3 || (m3 = new ar(new s3(a3, p3 * u3, i2.count * u3 / l3), u3 / l3), t3.cache.add(f2, m3)), r3 = new sr(m3, o3, h3 % u3 / l3, d3);
      } else r3 = new We(null === a3 ? new s3(i2.count * o3) : new s3(a3, h3, i2.count * o3), o3, d3);
      if (void 0 !== i2.sparse) {
        var g3 = N2.SCALAR, v2 = C2[i2.sparse.indices.componentType], x3 = i2.sparse.indices.byteOffset || 0, y3 = i2.sparse.values.byteOffset || 0, _3 = new v2(e4[1], x3, i2.sparse.count * g3), b3 = new s3(e4[2], y3, i2.sparse.count * o3);
        null !== a3 && (r3 = new We(r3.array.slice(), r3.itemSize, r3.normalized));
        for (var w3 = 0, M3 = _3.length; w3 < M3; w3++) {
          var S3 = _3[w3];
          if (r3.setX(S3, b3[w3 * o3]), o3 >= 2 && r3.setY(S3, b3[w3 * o3 + 1]), o3 >= 3 && r3.setZ(S3, b3[w3 * o3 + 2]), o3 >= 4 && r3.setW(S3, b3[w3 * o3 + 3]), o3 >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return r3;
    });
  }, Y2.prototype.loadTexture = function(e3) {
    var t3 = this.json, n3 = this.options, i2 = t3.textures[e3], r2 = t3.images[i2.source], a3 = this.textureLoader;
    if (r2.uri) {
      var o3 = n3.manager.getHandler(r2.uri);
      null !== o3 && (a3 = o3);
    }
    return this.loadTextureImage(e3, r2, a3);
  }, Y2.prototype.loadTextureImage = function(e3, t3, n3) {
    var i2 = this, r2 = this.json, a3 = this.options, o3 = r2.textures[e3], s3 = self.URL || self.webkitURL, l3 = t3.uri, c3 = false, h3 = true;
    if ("image/jpeg" === t3.mimeType && (h3 = false), void 0 !== t3.bufferView) l3 = i2.getDependency("bufferView", t3.bufferView).then(function(e4) {
      if ("image/png" === t3.mimeType) {
        var n4 = new DataView(e4, 25, 1).getUint8(0, false);
        h3 = 6 === n4 || 4 === n4 || 3 === n4;
      }
      c3 = true;
      var i3 = new Blob([e4], { type: t3.mimeType });
      return l3 = s3.createObjectURL(i3);
    });
    else if (void 0 === t3.uri) throw new Error("THREE.GLTFLoader: Image " + e3 + " is missing URI and bufferView");
    return Promise.resolve(l3).then(function(e4) {
      return new Promise(function(t4, i3) {
        var r3 = t4;
        true === n3.isImageBitmapLoader && (r3 = function(e5) {
          t4(new kr(e5));
        }), n3.load(k2(e4, a3.path), r3, void 0, i3);
      });
    }).then(function(t4) {
      true === c3 && s3.revokeObjectURL(l3), t4.flipY = false, o3.name && (t4.name = o3.name), h3 || (t4.format = 1022);
      var n4 = (r2.samplers || {})[o3.sampler] || {};
      return t4.magFilter = D2[n4.magFilter] || 1006, t4.minFilter = D2[n4.minFilter] || 1008, t4.wrapS = I2[n4.wrapS] || 1e3, t4.wrapT = I2[n4.wrapT] || 1e3, i2.associations.set(t4, { type: "textures", index: e3 }), t4;
    });
  }, Y2.prototype.assignTexture = function(e3, t3, i2) {
    var r2 = this;
    return this.getDependency("texture", i2.index).then(function(a3) {
      if (void 0 === i2.texCoord || 0 == i2.texCoord || "aoMap" === t3 && 1 == i2.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + i2.texCoord + " for texture " + t3 + " not yet supported."), r2.extensions[n2.KHR_TEXTURE_TRANSFORM]) {
        var o3 = void 0 !== i2.extensions ? i2.extensions[n2.KHR_TEXTURE_TRANSFORM] : void 0;
        if (o3) {
          var s3 = r2.associations.get(a3);
          a3 = r2.extensions[n2.KHR_TEXTURE_TRANSFORM].extendTexture(a3, o3), r2.associations.set(a3, s3);
        }
      }
      e3[t3] = a3;
    });
  }, Y2.prototype.assignFinalMaterial = function(e3) {
    var t3 = e3.geometry, n3 = e3.material, i2 = void 0 !== t3.attributes.tangent, r2 = void 0 !== t3.attributes.color, a3 = void 0 === t3.attributes.normal, o3 = true === e3.isSkinnedMesh, s3 = Object.keys(t3.morphAttributes).length > 0, l3 = s3 && void 0 !== t3.morphAttributes.normal;
    if (e3.isPoints) {
      var c3 = "PointsMaterial:" + n3.uuid, h3 = this.cache.get(c3);
      h3 || (h3 = new Nr(), Ie.prototype.copy.call(h3, n3), h3.color.copy(n3.color), h3.map = n3.map, h3.sizeAttenuation = false, this.cache.add(c3, h3)), n3 = h3;
    } else if (e3.isLine) {
      c3 = "LineBasicMaterial:" + n3.uuid;
      var u3 = this.cache.get(c3);
      u3 || (u3 = new Mr(), Ie.prototype.copy.call(u3, n3), u3.color.copy(n3.color), this.cache.add(c3, u3)), n3 = u3;
    }
    if (i2 || r2 || a3 || o3 || s3) {
      c3 = "ClonedMaterial:" + n3.uuid + ":";
      n3.isGLTFSpecularGlossinessMaterial && (c3 += "specular-glossiness:"), o3 && (c3 += "skinning:"), i2 && (c3 += "vertex-tangents:"), r2 && (c3 += "vertex-colors:"), a3 && (c3 += "flat-shading:"), s3 && (c3 += "morph-targets:"), l3 && (c3 += "morph-normals:");
      var d3 = this.cache.get(c3);
      d3 || (d3 = n3.clone(), o3 && (d3.skinning = true), r2 && (d3.vertexColors = true), a3 && (d3.flatShading = true), s3 && (d3.morphTargets = true), l3 && (d3.morphNormals = true), i2 && (d3.vertexTangents = true, d3.normalScale && (d3.normalScale.y *= -1), d3.clearcoatNormalScale && (d3.clearcoatNormalScale.y *= -1)), this.cache.add(c3, d3), this.associations.set(d3, this.associations.get(n3))), n3 = d3;
    }
    n3.aoMap && void 0 === t3.attributes.uv2 && void 0 !== t3.attributes.uv && t3.setAttribute("uv2", t3.attributes.uv), e3.material = n3;
  }, Y2.prototype.getMaterialType = function() {
    return Wr;
  }, Y2.prototype.loadMaterial = function(e3) {
    var t3, i2 = this, a3 = this.json, o3 = this.extensions, s3 = a3.materials[e3], l3 = {}, c3 = s3.extensions || {}, h3 = [];
    if (c3[n2.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var u3 = o3[n2.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      t3 = u3.getMaterialType(), h3.push(u3.extendParams(l3, s3, i2));
    } else if (c3[n2.KHR_MATERIALS_UNLIT]) {
      var d3 = o3[n2.KHR_MATERIALS_UNLIT];
      t3 = d3.getMaterialType(), h3.push(d3.extendParams(l3, s3, i2));
    } else {
      var p3 = s3.pbrMetallicRoughness || {};
      if (l3.color = new Be(1, 1, 1), l3.opacity = 1, Array.isArray(p3.baseColorFactor)) {
        var f2 = p3.baseColorFactor;
        l3.color.fromArray(f2), l3.opacity = f2[3];
      }
      void 0 !== p3.baseColorTexture && h3.push(i2.assignTexture(l3, "map", p3.baseColorTexture)), l3.metalness = void 0 !== p3.metallicFactor ? p3.metallicFactor : 1, l3.roughness = void 0 !== p3.roughnessFactor ? p3.roughnessFactor : 1, void 0 !== p3.metallicRoughnessTexture && (h3.push(i2.assignTexture(l3, "metalnessMap", p3.metallicRoughnessTexture)), h3.push(i2.assignTexture(l3, "roughnessMap", p3.metallicRoughnessTexture))), t3 = this._invokeOne(function(t4) {
        return t4.getMaterialType && t4.getMaterialType(e3);
      }), h3.push(Promise.all(this._invokeAll(function(t4) {
        return t4.extendMaterialParams && t4.extendMaterialParams(e3, l3);
      })));
    }
    true === s3.doubleSided && (l3.side = 2);
    var m3 = s3.alphaMode || z2;
    return m3 === G2 ? (l3.transparent = true, l3.depthWrite = false) : (l3.transparent = false, m3 === B2 && (l3.alphaTest = void 0 !== s3.alphaCutoff ? s3.alphaCutoff : 0.5)), void 0 !== s3.normalTexture && t3 !== Ge && (h3.push(i2.assignTexture(l3, "normalMap", s3.normalTexture)), l3.normalScale = new r(1, -1), void 0 !== s3.normalTexture.scale && l3.normalScale.set(s3.normalTexture.scale, -s3.normalTexture.scale)), void 0 !== s3.occlusionTexture && t3 !== Ge && (h3.push(i2.assignTexture(l3, "aoMap", s3.occlusionTexture)), void 0 !== s3.occlusionTexture.strength && (l3.aoMapIntensity = s3.occlusionTexture.strength)), void 0 !== s3.emissiveFactor && t3 !== Ge && (l3.emissive = new Be().fromArray(s3.emissiveFactor)), void 0 !== s3.emissiveTexture && t3 !== Ge && h3.push(i2.assignTexture(l3, "emissiveMap", s3.emissiveTexture)), Promise.all(h3).then(function() {
      var r2;
      return r2 = t3 === _2 ? o3[n2.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(l3) : new t3(l3), s3.name && (r2.name = s3.name), r2.map && (r2.map.encoding = 3001), r2.emissiveMap && (r2.emissiveMap.encoding = 3001), W2(r2, s3), i2.associations.set(r2, { type: "materials", index: e3 }), s3.extensions && V2(o3, r2, s3), r2;
    });
  }, Y2.prototype.createUniqueName = function(e3) {
    for (var t3 = Za.sanitizeNodeName(e3 || ""), n3 = t3, i2 = 1; this.nodeNamesUsed[n3]; ++i2) n3 = t3 + "_" + i2;
    return this.nodeNamesUsed[n3] = true, n3;
  }, Y2.prototype.loadGeometries = function(e3) {
    var t3 = this, i2 = this.extensions, r2 = this.primitiveCache;
    function a3(e4) {
      return i2[n2.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e4, t3).then(function(n3) {
        return Z2(n3, e4, t3);
      });
    }
    for (var o3, s3, l3 = [], c3 = 0, h3 = e3.length; c3 < h3; c3++) {
      var u3, d3 = e3[c3], p3 = (s3 = void 0, (s3 = (o3 = d3).extensions && o3.extensions[n2.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + s3.bufferView + ":" + s3.indices + ":" + X2(s3.attributes) : o3.indices + ":" + X2(o3.attributes) + ":" + o3.mode), f2 = r2[p3];
      if (f2) l3.push(f2.promise);
      else u3 = d3.extensions && d3.extensions[n2.KHR_DRACO_MESH_COMPRESSION] ? a3(d3) : Z2(new ct(), d3, t3), r2[p3] = { primitive: d3, promise: u3 }, l3.push(u3);
    }
    return Promise.all(l3);
  }, Y2.prototype.loadMesh = function(e3) {
    for (var t3, n3 = this, i2 = this.json, r2 = this.extensions, a3 = i2.meshes[e3], o3 = a3.primitives, s3 = [], l3 = 0, c3 = o3.length; l3 < c3; l3++) {
      var h3 = void 0 === o3[l3].material ? (void 0 === (t3 = this.cache).DefaultMaterial && (t3.DefaultMaterial = new Wr({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: false, depthTest: true, side: 0 })), t3.DefaultMaterial) : this.getDependency("material", o3[l3].material);
      s3.push(h3);
    }
    return s3.push(n3.loadGeometries(o3)), Promise.all(s3).then(function(t4) {
      for (var i3 = t4.slice(0, t4.length - 1), s4 = t4[t4.length - 1], l4 = [], c4 = 0, h4 = s4.length; c4 < h4; c4++) {
        var u3, d3 = s4[c4], p3 = o3[c4], f2 = i3[c4];
        if (p3.mode === R2 || p3.mode === A2 || p3.mode === P2 || void 0 === p3.mode) true !== (u3 = true === a3.isSkinnedMesh ? new pr(d3, f2) : new Lt(d3, f2)).isSkinnedMesh || u3.geometry.attributes.skinWeight.normalized || u3.normalizeSkinWeights(), p3.mode === A2 ? u3.geometry = J2(u3.geometry, 1) : p3.mode === P2 && (u3.geometry = J2(u3.geometry, 2));
        else if (p3.mode === T2) u3 = new Dr(d3, f2);
        else if (p3.mode === L2) u3 = new Ar(d3, f2);
        else if (p3.mode === E2) u3 = new Ir(d3, f2);
        else {
          if (p3.mode !== S2) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + p3.mode);
          u3 = new zr(d3, f2);
        }
        Object.keys(u3.geometry.morphAttributes).length > 0 && q2(u3, a3), u3.name = n3.createUniqueName(a3.name || "mesh_" + e3), W2(u3, a3), p3.extensions && V2(r2, u3, p3), n3.assignFinalMaterial(u3), l4.push(u3);
      }
      if (1 === l4.length) return l4[0];
      var m3 = new $i();
      for (c4 = 0, h4 = l4.length; c4 < h4; c4++) m3.add(l4[c4]);
      return m3;
    });
  }, Y2.prototype.loadCamera = function(e3) {
    var t3, n3 = this.json.cameras[e3], r2 = n3[n3.type];
    if (r2) return "perspective" === n3.type ? t3 = new Ot(i.radToDeg(r2.yfov), r2.aspectRatio || 1, r2.znear || 1, r2.zfar || 2e6) : "orthographic" === n3.type && (t3 = new Pa(-r2.xmag, r2.xmag, r2.ymag, -r2.ymag, r2.znear, r2.zfar)), n3.name && (t3.name = this.createUniqueName(n3.name)), W2(t3, n3), Promise.resolve(t3);
    console.warn("THREE.GLTFLoader: Missing camera parameters.");
  }, Y2.prototype.loadSkin = function(e3) {
    var t3 = this.json.skins[e3], n3 = { joints: t3.joints };
    return void 0 === t3.inverseBindMatrices ? Promise.resolve(n3) : this.getDependency("accessor", t3.inverseBindMatrices).then(function(e4) {
      return n3.inverseBindMatrices = e4, n3;
    });
  }, Y2.prototype.loadAnimation = function(e3) {
    for (var t3 = this.json.animations[e3], n3 = [], i2 = [], r2 = [], a3 = [], o3 = [], s3 = 0, l3 = t3.channels.length; s3 < l3; s3++) {
      var c3 = t3.channels[s3], h3 = t3.samplers[c3.sampler], u3 = c3.target, d3 = void 0 !== u3.node ? u3.node : u3.id, p3 = void 0 !== t3.parameters ? t3.parameters[h3.input] : h3.input, f2 = void 0 !== t3.parameters ? t3.parameters[h3.output] : h3.output;
      n3.push(this.getDependency("node", d3)), i2.push(this.getDependency("accessor", p3)), r2.push(this.getDependency("accessor", f2)), a3.push(h3), o3.push(u3);
    }
    return Promise.all([Promise.all(n3), Promise.all(i2), Promise.all(r2), Promise.all(a3), Promise.all(o3)]).then(function(n4) {
      for (var i3 = n4[0], r3 = n4[1], a4 = n4[2], o4 = n4[3], s4 = n4[4], l4 = [], c4 = 0, h4 = i3.length; c4 < h4; c4++) {
        var u4 = i3[c4], d4 = r3[c4], p4 = a4[c4], f3 = o4[c4], m3 = s4[c4];
        if (void 0 !== u4) {
          var g3;
          switch (u4.updateMatrix(), u4.matrixAutoUpdate = true, F2[m3.path]) {
            case F2.weights:
              g3 = ea;
              break;
            case F2.rotation:
              g3 = na;
              break;
            case F2.position:
            case F2.scale:
            default:
              g3 = ra;
          }
          var v2 = u4.name ? u4.name : u4.uuid, x3 = void 0 !== f3.interpolation ? H2[f3.interpolation] : 2301, y3 = [];
          F2[m3.path] === F2.weights ? u4.traverse(function(e4) {
            true === e4.isMesh && e4.morphTargetInfluences && y3.push(e4.name ? e4.name : e4.uuid);
          }) : y3.push(v2);
          var _3 = p4.array;
          if (p4.normalized) {
            var b3;
            if (_3.constructor === Int8Array) b3 = 1 / 127;
            else if (_3.constructor === Uint8Array) b3 = 1 / 255;
            else if (_3.constructor == Int16Array) b3 = 1 / 32767;
            else {
              if (_3.constructor !== Uint16Array) throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");
              b3 = 1 / 65535;
            }
            for (var w3 = new Float32Array(_3.length), S3 = 0, T3 = _3.length; S3 < T3; S3++) w3[S3] = _3[S3] * b3;
            _3 = w3;
          }
          for (S3 = 0, T3 = y3.length; S3 < T3; S3++) {
            var E3 = new g3(y3[S3] + "." + F2[m3.path], d4.array, _3, x3);
            "CUBICSPLINE" === f3.interpolation && (E3.createInterpolant = function(e4) {
              return new M2(this.times, this.values, this.getValueSize() / 3, e4);
            }, E3.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true), l4.push(E3);
          }
        }
      }
      var L3 = t3.name ? t3.name : "animation_" + e3;
      return new aa(L3, void 0, l4);
    });
  }, Y2.prototype.loadNode = function(e3) {
    var t3, n3 = this.json, i2 = this.extensions, r2 = this, a3 = n3.nodes[e3], o3 = a3.name ? r2.createUniqueName(a3.name) : "";
    return (t3 = [], void 0 !== a3.mesh && t3.push(r2.getDependency("mesh", a3.mesh).then(function(e4) {
      var t4 = r2._getNodeRef(r2.meshCache, a3.mesh, e4);
      return void 0 !== a3.weights && t4.traverse(function(e5) {
        if (e5.isMesh) for (var t5 = 0, n4 = a3.weights.length; t5 < n4; t5++) e5.morphTargetInfluences[t5] = a3.weights[t5];
      }), t4;
    })), void 0 !== a3.camera && t3.push(r2.getDependency("camera", a3.camera).then(function(e4) {
      return r2._getNodeRef(r2.cameraCache, a3.camera, e4);
    })), r2._invokeAll(function(t4) {
      return t4.createNodeAttachment && t4.createNodeAttachment(e3);
    }).forEach(function(e4) {
      t3.push(e4);
    }), Promise.all(t3)).then(function(t4) {
      var n4;
      if ((n4 = true === a3.isBone ? new fr() : t4.length > 1 ? new $i() : 1 === t4.length ? t4[0] : new ge()) !== t4[0]) for (var s3 = 0, l3 = t4.length; s3 < l3; s3++) n4.add(t4[s3]);
      if (a3.name && (n4.userData.name = a3.name, n4.name = o3), W2(n4, a3), a3.extensions && V2(i2, n4, a3), void 0 !== a3.matrix) {
        var c3 = new j();
        c3.fromArray(a3.matrix), n4.applyMatrix4(c3);
      } else void 0 !== a3.translation && n4.position.fromArray(a3.translation), void 0 !== a3.rotation && n4.quaternion.fromArray(a3.rotation), void 0 !== a3.scale && n4.scale.fromArray(a3.scale);
      return r2.associations.set(n4, { type: "nodes", index: e3 }), n4;
    });
  }, Y2.prototype.loadScene = /* @__PURE__ */ function() {
    function e3(t3, n3, i2, r2) {
      var a3 = i2.nodes[t3];
      return r2.getDependency("node", t3).then(function(e4) {
        return void 0 === a3.skin ? e4 : r2.getDependency("skin", a3.skin).then(function(e5) {
          for (var n4 = [], i3 = 0, a4 = (t4 = e5).joints.length; i3 < a4; i3++) n4.push(r2.getDependency("node", t4.joints[i3]));
          return Promise.all(n4);
        }).then(function(n4) {
          return e4.traverse(function(e5) {
            if (e5.isMesh) {
              for (var i3 = [], r3 = [], a4 = 0, o3 = n4.length; a4 < o3; a4++) {
                var s3 = n4[a4];
                if (s3) {
                  i3.push(s3);
                  var l3 = new j();
                  void 0 !== t4.inverseBindMatrices && l3.fromArray(t4.inverseBindMatrices.array, 16 * a4), r3.push(l3);
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t4.joints[a4]);
              }
              e5.bind(new vr(i3, r3), e5.matrixWorld);
            }
          }), e4;
        });
        var t4;
      }).then(function(t4) {
        n3.add(t4);
        var o3 = [];
        if (a3.children) for (var s3 = a3.children, l3 = 0, c3 = s3.length; l3 < c3; l3++) {
          var h3 = s3[l3];
          o3.push(e3(h3, t4, i2, r2));
        }
        return Promise.all(o3);
      });
    }
    return function(t3) {
      var n3 = this.json, i2 = this.extensions, r2 = this.json.scenes[t3], a3 = new $i();
      r2.name && (a3.name = this.createUniqueName(r2.name)), W2(a3, r2), r2.extensions && V2(i2, a3, r2);
      for (var o3 = r2.nodes || [], s3 = [], l3 = 0, c3 = o3.length; l3 < c3; l3++) s3.push(e3(o3[l3], a3, n3, this));
      return Promise.all(s3).then(function() {
        return a3;
      });
    };
  }(), e2;
}();
var ho = new ga();
var uo = (e2) => {
  if (!e2) return new c();
  const t2 = ho.load(e2);
  return t2.wrapS = 1e3, t2.wrapT = 1e3, t2;
};
var po = class extends It {
  constructor(e2, t2) {
    const { textureUrl: n2 = "", colorRange: { min: i2, max: r2 } = { min: 16711680, max: 255 }, repeatOffsetRange: { min: a2, max: o2 } = { min: [1, 1], max: [0.15, 1] }, opacityRange: { min: s2, max: l2 } = { min: 0.5, max: 1 }, fallOffDistance: c2 = -8, speedRange: h2 = { min: 25e-4, max: 0.525 }, rotationSpeedRange: d2 = { min: 1, max: 45 } } = t2;
    super({ vertexShader: "\nvarying vec2 vUvSample1;\nvarying vec2 vUvSample2;\nvarying vec2 vUvSample3;\nvarying vec3 vViewPosition;\n\nuniform float throttle;\nuniform vec4 offsetRepeatMin;\nuniform vec4 offsetRepeatMax;\nuniform float distance;\nuniform float rotationDistance;\nuniform mat4 rotation;\n\nvec2 transformUV(in vec2 uv, in float t, in vec2 offset, in vec2 scale) {\n  vec2 result = vec2(uv.x, uv.y);\n  result *= scale;\n  result += (offset * t);\n  return result;\n}\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\nvoid main() {\n  vec4 offsetRepeat = mix(offsetRepeatMin, offsetRepeatMax, throttle);\n\n  vec2 uvOffset1 = offsetRepeat.xy * vec2(1.0, 1.0);\n  vec2 uvOffset2 = offsetRepeat.xy * vec2(1.0, 1.0);\n  vec2 uvOffset3 = offsetRepeat.xy * vec2(1.0, 1.0);\n\n  vec2 uvScale1 = offsetRepeat.zw * vec2(1.0, 1.0);\n  vec2 uvScale2 = offsetRepeat.zw * vec2(0.5, 1.0);\n  vec2 uvScale3 = offsetRepeat.zw * vec2(2.0, 1.0);\n\n  vUvSample1 = transformUV(uv, distance * 2.0, uvOffset1, uvScale1);\n  vUvSample2 = transformUV(uv, distance * 0.5, uvOffset2, uvScale2);\n  vUvSample3 = transformUV(uv, distance * 8.0, uvOffset3, uvScale3);\n\n  vec3 viewPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;\n\n  viewPosition.xy = rotate(viewPosition.xy, rotationDistance);\n\n  viewPosition = (rotation * vec4(viewPosition, 1.0)).xyz;\n\n  vViewPosition = viewPosition;\n\n  gl_Position = projectionMatrix * vec4(viewPosition, 1.0);\n}\n", fragmentShader: "\nvarying vec2 vUvSample1;\nvarying vec2 vUvSample2;\nvarying vec2 vUvSample3;\nvarying vec3 vViewPosition;\n\nuniform float throttle;\nuniform vec3 colorMin;\nuniform vec3 colorMax;\nuniform float opacityMin;\nuniform float opacityMax;\nuniform float globalOpacity;\nuniform sampler2D map;\nuniform float fallOffDistance;\n\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat linearTosRGB(const in float c) {\n  if (c >= 1.0) return 1.0;\n  float S1 = sqrt(c);\n  float S2 = sqrt(S1);\n  float S3 = sqrt(S2);\n  return 0.662002687 * S1 + 0.684122060 * S2 - 0.323583601 * S3 - 0.0225411470 * c;\n}\n\nvoid main() {\n  vec3 color = mix(colorMin, colorMax, throttle);\n  float opacity = mix(opacityMin, opacityMax, throttle) * globalOpacity;\n  vec4 outputColor = vec4(color, opacity);\n\n  vec4 sample1 = texture2D(map, vUvSample1);\n  vec4 sample2 = texture2D(map, vUvSample2);\n  vec4 sample3 = texture2D(map, vUvSample3);\n\n  float alpha = sample1.r * sample2.r * sample3.r * 4.0;\n\n  float falloff = clamp(remap(vViewPosition.z, 0.0, fallOffDistance, 1.0, 0.0), 0.0, 1.0);\n\n  outputColor.a *= alpha;\n\n  outputColor.a = linearTosRGB(outputColor.a);\n\n  outputColor.a *= falloff;\n\n  gl_FragColor = outputColor;\n}\n", uniforms: { globalOpacity: { value: 1 }, map: { value: uo(n2) }, colorMin: { value: new Be(i2) }, colorMax: { value: new Be(r2) }, opacityMin: { value: s2 }, opacityMax: { value: l2 }, offsetRepeatMin: { value: new u(1, 0, ...a2) }, offsetRepeatMax: { value: new u(1, 0, ...o2) }, fallOffDistance: { value: c2 }, rotation: { value: new j() }, throttle: { value: 0 }, distance: { value: 0 }, rotationDistance: { value: 0 } } }), this.context = e2, this.speedRange = h2, this.rotationSpeedRange = d2, this.transparent = true, this.depthWrite = false;
  }
  update() {
    const { delta: e2, throttle: t2, opacity: n2 } = this.context;
    this.uniforms.throttle.value = t2, this.uniforms.globalOpacity.value = n2;
    const r2 = i.mapLinear(t2, 0, 1, this.speedRange.min, this.speedRange.max);
    this.uniforms.distance.value += e2 * r2;
    const a2 = i.mapLinear(t2, 0, 1, this.rotationSpeedRange.min, this.rotationSpeedRange.max);
    this.uniforms.rotationDistance.value += i.degToRad(e2 * a2);
  }
};
var fo = class extends ge {
  constructor(e2, t2) {
    super(), this.createConeModel(e2, t2);
  }
  async createConeModel(e2, t2 = {}) {
    const { coneModelUrl: n2 = "https://webgl-space-travel.requin.pro/cone.glb", textureUrl: i2, colorRange: r2, opacityRange: a2, repeatOffsetRange: o2, fallOffDistance: s2, speedRange: l2, rotationSpeedRange: c2 } = t2, { scene: { children: [h2] } } = await new co().loadAsync(n2), u2 = h2, d2 = new po(e2, { textureUrl: i2, colorRange: r2, opacityRange: a2, repeatOffsetRange: o2, fallOffDistance: s2, speedRange: l2, rotationSpeedRange: c2 });
    u2.material = d2, u2.scale.set(2, 1, 2), u2.position.z -= 5, u2.rotation.z = -Math.PI, u2.onBeforeRender = () => {
      d2.update();
    }, this.add(u2);
  }
};
var mo = [{ textureUrl: "https://webgl-space-travel.requin.pro/clouds1.jpg", colorRange: { min: 16711746, max: 16711746 }, opacityRange: { min: 0.05, max: 0.2 }, speedRange: { min: 25e-4, max: 0.175 }, repeatOffsetRange: { min: [1, 1], max: [0.33, 1] }, fallOffDistance: -8, rotationSpeedRange: { min: 1, max: 30 } }, { textureUrl: "https://webgl-space-travel.requin.pro/noise3.jpg", colorRange: { min: 2513405, max: 2513405 }, opacityRange: { min: 0.05, max: 0.25 }, speedRange: { min: 3e-3, max: 0.075 }, repeatOffsetRange: { min: [0.5, 1], max: [0.25, 1] }, fallOffDistance: -6, rotationSpeedRange: { min: 0.5, max: 25 } }, { textureUrl: "https://webgl-space-travel.requin.pro/noise3.jpg", colorRange: { min: 8716527, max: 8716527 }, opacityRange: { min: 0.02, max: 0.25 }, speedRange: { min: 2e-3, max: 0.1125 }, repeatOffsetRange: { min: [0.75, 1], max: [0.35, 1] }, fallOffDistance: -6, rotationSpeedRange: { min: 1.09, max: 31 } }];
var go = class extends $i {
  constructor(e2, t2 = mo) {
    super();
    for (const n2 of t2) {
      const t3 = new fo(e2, n2);
      this.add(t3);
    }
  }
};
var vo = class extends rr {
  constructor(e2, t2 = {}) {
    super();
    const { backgroundColor: n2 = 524303, starfield: i2, nebulae: r2 } = t2, a2 = new lo(e2, i2), o2 = new go(e2, r2);
    this.camera = this.createCamera(), this.add(this.camera), this.setObjectRenderOrder(o2, 0), this.setObjectRenderOrder(a2, 1), this.camera.add(o2), this.camera.add(a2), this.frustumCulled = false, this.background = new Be(n2);
  }
  render(e2) {
    e2.render(this, this.camera);
  }
  setCameraAspectRatio(e2) {
    this.camera.aspect = e2, this.camera.updateProjectionMatrix();
  }
  createCamera() {
    const e2 = new Ot(60, 1, 0.01, 500);
    return e2.position.set(0, 0, -4), e2.lookAt(new f(0, 0, 0)), e2;
  }
  setObjectRenderOrder(e2, t2) {
    e2.traverse((e3) => {
      e3.renderOrder = t2;
    });
  }
};
var space_travel_es_default = class {
  constructor(e2) {
    const { canvas: t2, backgroundColor: n2, throttle: i2, throttleLerpFactor: r2, opacity: a2, startOpacity: o2, opacityLerpFactor: s2, starfield: l2, nebulae: c2 } = e2;
    if (!(t2 instanceof HTMLCanvasElement)) throw new TypeError("Invalid canvas");
    this.context = new oo({ throttle: i2, throttleLerpFactor: r2, opacity: a2, startOpacity: o2, opacityLerpFactor: s2 }), this.scene = new vo(this.context, { backgroundColor: n2, starfield: l2, nebulae: c2 }), this.renderer = this.createRenderer(t2), this.setSize(t2), this.renderLoop = new io(this.onRender.bind(this));
  }
  get throttle() {
    return this.context.throttleTarget;
  }
  set throttle(e2) {
    this.context.setThrottle(e2);
  }
  get opacity() {
    return this.context.opacityTarget;
  }
  set opacity(e2) {
    this.context.setOpacity(e2);
  }
  start() {
    this.context.start(), this.renderLoop.start();
  }
  resume() {
    this.start();
  }
  pause() {
    this.context.pause(), this.renderLoop.pause();
  }
  resize() {
    this.setSize(this.renderer.domElement);
  }
  createRenderer(e2) {
    const t2 = new ir({ canvas: e2 }), n2 = Math.min(window.devicePixelRatio, 1.5);
    return t2.setPixelRatio(n2), t2;
  }
  setSize(e2) {
    const t2 = e2.offsetWidth, n2 = e2.offsetHeight;
    this.renderer.setSize(t2, n2, false), this.scene.setCameraAspectRatio(t2 / n2);
  }
  isRenderable() {
    const { opacity: e2 } = this.context;
    return 0 !== e2;
  }
  onRender() {
    this.context.update(), this.isRenderable() && this.scene.render(this.renderer);
  }
};
export {
  space_travel_es_default as default
};
/*! Bundled license information:

space-travel/dist/space-travel.es.js:
  (**
   * @license
   * Copyright 2010-2021 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=space-travel.js.map
